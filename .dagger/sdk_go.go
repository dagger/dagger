package main

import (
	"context"
	"fmt"
	"strings"

	"github.com/dagger/dagger/.dagger/internal/dagger"
)

type GoSDK struct {
	// Needed for devEngineSidecar(). Remove once we can decouple from that.
	Dagger     *DaggerDev        // +private
	Workspace  *dagger.Directory //+private
	SourcePath string            // +private
}

// Develop the Dagger Go SDK
func (sdks *SDK) Go(
	// Workspace to develop the Go SDK
	// +defaultPath="/"
	// +ignore=[
	//  "*",
	//  "!sdk/go",
	//  "!**/go.mod",
	//  "!**/go.sum",
	//  "!cmd/codegen",
	//  "!engine/slog"
	// ]
	workspace *dagger.Directory,
	// Path of the Go SDK source within the workspace
	// +default="sdk/go"
	sourcePath string,
) *GoSDK {
	return &GoSDK{
		Workspace:  workspace,
		SourcePath: sourcePath,
	}
}

func (sdks *SDK) selfCallGo() *GoSDK {
	return sdks.Go(
		// workspace
		sdks.Dagger.Source.Filter(dagger.DirectoryFilterOpts{
			Include: []string{
				"sdk/go",
				// FIXME: narrow this down for better cache hit rate
				"**/go.mod",
				"**/go.sum",
				"cmd/codegen",
				"engine/slog",
			},
		}),
		// sourcePath
		"sdk/go",
	)
}

func (t GoSDK) DevContainer() *dagger.Container {
	return dag.Go(dagger.GoOpts{Source: t.Source()}).
		Env().
		With(t.Dagger.devEngineSidecar()).
		WithWorkdir("sdk/go")
}

func (t GoSDK) Name() string {
	return "go"
}

func (t GoSDK) Source() *dagger.Directory {
	return t.Workspace.Directory(t.SourcePath)
}

// Test the Go SDK
func (t GoSDK) Test(ctx context.Context) (MyCheckStatus, error) {
	// FIXME: merge into common go toolchain
	_, err := t.DevContainer().
		WithExec([]string{"go", "test", "-v", "-skip=TestProvision", "./..."}).
		Sync(ctx)
	return CheckCompleted, err
}

// Regenerate the Go SDK API
func (t GoSDK) Generate(ctx context.Context) (*dagger.Changeset, error) {
	return t.DevContainer().
		WithExec([]string{"go", "generate", "-v", "./..."}).
		WithExec([]string{"go", "mod", "tidy"}).
		Directory("../.."). // pop back to repo root
		Changes(t.Source()).
		Sync(ctx)
}

// Test the release
func (t GoSDK) ReleaseDryRun(
	ctx context.Context,
	// Git repository to publish *from*
	// +defaultPath="/"
	fromRepo *dagger.GitRepository,
) (MyCheckStatus, error) {
	return CheckCompleted, t.Publish(
		ctx,
		fromRepo,
		"HEAD",
		true, // dryRun
		"https://github.com/dagger/dagger-go-sdk.git",
		nil,
	)
}

// Publish the Go SDK
func (t GoSDK) Publish(
	ctx context.Context,
	// Git repository to publish *from*
	// +defaultPath="/"
	fromRepo *dagger.GitRepository,

	tag string,

	// +optional
	dryRun bool,

	// +optional
	// +default="https://github.com/dagger/dagger-go-sdk.git"
	gitRepo string,
	// +optional
	githubToken *dagger.Secret,
) error {
	version := strings.TrimPrefix(tag, "sdk/go/")

	if err := gitPublish(ctx, fromRepo, gitPublishOpts{
		sdk:        "go",
		sourceTag:  tag,
		sourcePath: "sdk/go/",
		// see https://github.com/newren/git-filter-repo/blob/main/Documentation/converting-from-filter-branch.md#cheat-sheet-additional-conversion-examples
		callback: `
tmpfile = os.path.basename(filename)
if tmpfile != b"go.mod":
  return (filename, mode, blob_id)  # no changes

contents = value.get_contents_by_identifier(blob_id)
with open(tmpfile, "wb") as f:
  f.write(contents)
subprocess.check_call(["go", "mod", "edit", "-dropreplace", "github.com/dagger/dagger", tmpfile])
with open(tmpfile, "rb") as f:
  contents = f.read()
new_blob_id = value.insert_file_with_contents(contents)

return (filename, mode, new_blob_id)
`,
		dest:        gitRepo,
		destTag:     version,
		githubToken: githubToken,
		dryRun:      dryRun,
	}); err != nil {
		return err
	}

	return nil
}

// Bump the Go SDK's Engine dependency
func (t GoSDK) Bump(_ context.Context, version string) (*dagger.Changeset, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")

	versionFile := fmt.Sprintf(`// Code generated by dagger. DO NOT EDIT.

package engineconn

const CLIVersion = %q
`, version)

	layer := t.Dagger.Source.WithNewFile("sdk/go/engineconn/version.gen.go", versionFile)
	return layer.Changes(t.Dagger.Source), nil
}
