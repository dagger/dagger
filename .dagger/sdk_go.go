package main

import (
	"context"
	"fmt"
	"strings"

	"github.com/dagger/dagger/.dagger/internal/dagger"
)

type GoSDK struct {
	Dagger *DaggerDev // +private
}

func (t GoSDK) Name() string {
	return "go"
}

func (t GoSDK) Source() *dagger.Directory {
	// FIXME: use pre-call filtering when this module is spun out
	// (or when we get self-calls)
	return t.Dagger.Source.Filter(dagger.DirectoryFilterOpts{
		Include: []string{
			"sdk/go",
			// FIXME: narrow this down for better cache hit rate
			"**/go.mod",
			"**/go.sum",
			"cmd/codegen",
			"engine/slog",
		},
	})
}

// Test the Go SDK
func (t GoSDK) Test(ctx context.Context) (rerr error) {
	output, err := t.DevContainer().
		WithExec([]string{"go", "test", "-v", "-skip=TestProvision", "./..."}).
		Stdout(ctx)
	if err != nil {
		err = fmt.Errorf("test failed: %w\n%s", err, output)
	}
	return err
}

func (t GoSDK) BaseContainer() *dagger.Container {
	return dag.Go(dag.Directory()).Base()
}

func (t GoSDK) DevContainer() *dagger.Container {
	return dag.Go(t.Source()).
		Env().
		With(t.Dagger.devEngineSidecar()).
		WithWorkdir("sdk/go")
}

// Regenerate the Go SDK API
func (t GoSDK) Generate(ctx context.Context) (*dagger.Changeset, error) {
	return t.DevContainer().
		WithExec([]string{"go", "generate", "-v", "./..."}).
		WithExec([]string{"go", "mod", "tidy"}).
		Directory("../.."). // pop back to repo root
		Changes(t.Source()).
		Sync(ctx)
}

// Test the release
func (t GoSDK) CheckReleaseDryRun(ctx context.Context) error {
	return t.Publish(
		ctx,
		"HEAD",
		true,
		"https://github.com/dagger/dagger-go-sdk.git",
		"dagger-ci",
		"hello@dagger.io",
		nil,
	)
}

// Publish the Go SDK
func (t GoSDK) Publish(
	ctx context.Context,
	tag string,

	// +optional
	dryRun bool,

	// +optional
	// +default="https://github.com/dagger/dagger-go-sdk.git"
	gitRepo string,
	// +optional
	// +default="dagger-ci"
	gitUserName string,
	// +optional
	// +default="hello@dagger.io"
	gitUserEmail string,

	// +optional
	githubToken *dagger.Secret,
) error {
	version := strings.TrimPrefix(tag, "sdk/go/")

	if err := gitPublish(ctx, t.Dagger.Git, gitPublishOpts{
		sdk:          "go",
		sourceTag:    tag,
		sourcePath:   "sdk/go/",
		sourceFilter: "if [ -f go.mod ]; then go mod edit -dropreplace github.com/dagger/dagger; fi",
		sourceEnv:    t.BaseContainer(), // Just need git and go installed
		dest:         gitRepo,
		destTag:      version,
		username:     gitUserName,
		email:        gitUserEmail,
		githubToken:  githubToken,
		dryRun:       dryRun,
	}); err != nil {
		return err
	}

	return nil
}

// Bump the Go SDK's Engine dependency
func (t GoSDK) Bump(_ context.Context, version string) (*dagger.Changeset, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")

	versionFile := fmt.Sprintf(`// Code generated by dagger. DO NOT EDIT.

package engineconn

const CLIVersion = %q
`, version)

	layer := t.Dagger.Source.WithNewFile("sdk/go/engineconn/version.gen.go", versionFile)
	return layer.Changes(t.Dagger.Source), nil
}
