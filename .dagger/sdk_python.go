package main

import (
	"context"
	"fmt"
	"strings"

	"github.com/dagger/dagger/.dagger/internal/dagger"
	"github.com/dagger/dagger/util/parallel"
)

type PythonSDK struct {
	Dagger *DaggerDev // +private
}

func (t PythonSDK) Name() string {
	return "python"
}

// CheckPythonFormat checks the Python code formatting
func (t PythonSDK) CheckLintPython(ctx context.Context) error {
	// Preserve same file hierarchy for docs because of extend rules in .ruff.toml
	_, err := dag.PythonSDKDev().
		WithDirectory(
			dag.Directory().
				WithDirectory(
					"",
					t.Dagger.Source,
					dagger.DirectoryWithDirectoryOpts{
						Include: []string{
							"docs/current_docs/**/*.py",
							"**/.ruff.toml",
						},
					},
				),
		).
		Lint(ctx, dagger.PythonSDKDevLintOpts{Paths: []string{"../.."}})
	return err
}

func (t PythonSDK) RuntimeSource() *dagger.Directory {
	return t.Dagger.Source.Filter(dagger.DirectoryFilterOpts{
		Include: []string{"sdk/python/runtime"},
	})
}

// CheckGoFormat checks the Go code formatting for the Python runtime
func (t PythonSDK) CheckLintGo(ctx context.Context) error {
	return t.godev().CheckLint(ctx)
}

func (t PythonSDK) godev() *dagger.Go {
	return dag.Go(t.RuntimeSource())
}

// Lint the Python SDK
func (t PythonSDK) CheckLint(ctx context.Context) error {
	return parallel.New().
		WithJob("lint Python code in the SDK and docs", t.CheckLintPython).
		WithJob("lint the python runtime, which is written in Go", t.CheckLintGo).
		Run(ctx)
}

// Test the Python SDK
func (t PythonSDK) Test(ctx context.Context) (rerr error) {
	base := dag.PythonSDKDev().Container().With(t.Dagger.devEngineSidecar())
	dev := dag.PythonSDKDev(dagger.PythonSDKDevOpts{Container: base})

	versions, err := dag.PythonSDKDev().SupportedVersions(ctx)
	if err != nil {
		return err
	}
	jobs := parallel.New()
	for _, version := range versions {
		jobs = jobs.WithJob(
			fmt.Sprintf("test with python version %s", version),
			func(ctx context.Context) error {
				_, err := dev.
					Test(dagger.PythonSDKDevTestOpts{Version: version}).
					Default().
					Sync(ctx)
				return err
			},
		)
	}
	return jobs.Run(ctx)
}

// Regenerate the Python SDK API
func (t PythonSDK) Generate(_ context.Context) (*dagger.Changeset, error) {
	devContainer := dag.PythonSDKDev().Container()

	// We don't control the input source, it's defined in wrapped native module
	srcMountPath := "/src"
	src := devContainer.Directory(srcMountPath)
	// FIXME: workaround for Directory.changes() bug
	src = dag.Directory().WithDirectory("", src)
	genFile := devContainer.
		WithMountedFile("/schema.json", t.Dagger.introspectionJSON()).
		WithWorkdir("codegen").
		WithExec([]string{
			"uv", "run", "python", "-m", "codegen",
			"generate", "-i", "/schema.json", "-o", "gen.py",
		}).
		WithExec([]string{
			"uv", "run", "ruff", "check", "--fix-only", "gen.py",
		}).
		WithExec([]string{
			"uv", "run", "ruff", "format", "gen.py",
		}).
		File("gen.py")
	genRelPath := "src/dagger/client/gen.py"
	formattedGenFile := devContainer.
		WithFile(genRelPath, genFile).
		WithExec([]string{
			"uv", "run", "ruff", "check", "--fix-only", genRelPath,
		}).
		WithExec([]string{
			"uv", "run", "ruff", "format", genRelPath,
		}).
		File(genRelPath)
	return changes(
		src,
		src.WithFile("sdk/python/"+genRelPath, formattedGenFile),
		[]string{
			"sdk/python/.uv_cache",
			"sdk/python/.venv",
			"sdk/python/__pycache__",
			"sdk/python/uv.lock",
			"sdk/python/**/__pycache__",
		},
	), nil
}

// Test the publishing process
func (t PythonSDK) CheckReleaseDryRun(ctx context.Context) error {
	return t.Publish(ctx, "HEAD", true, "", nil)
}

// Publish the Python SDK
func (t PythonSDK) Publish(
	ctx context.Context,
	tag string,

	// +optional
	dryRun bool,

	// +optional
	pypiRepo string,
	// +optional
	pypiToken *dagger.Secret,
) error {
	version := strings.TrimPrefix(tag, "sdk/python/")

	var ctr *dagger.Container
	if dryRun {
		ctr = dag.PythonSDKDev().Build()
	} else {
		opts := dagger.PythonSDKDevPublishOpts{
			Version: strings.TrimPrefix(version, "v"),
		}
		if pypiRepo == "test" {
			opts.URL = "https://test.pypi.org/legacy/"
		}
		ctr = dag.PythonSDKDev().Publish(pypiToken, opts)
	}
	_, err := ctr.Sync(ctx)
	if err != nil {
		return err
	}

	return nil
}

// Bump the Python SDK's Engine dependency
func (t PythonSDK) Bump(_ context.Context, version string) (*dagger.Changeset, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")
	engineReference := fmt.Sprintf("# Code generated by dagger. DO NOT EDIT.\n\nCLI_VERSION = %q\n", version)

	// NOTE: if you change this path, be sure to update .github/workflows/publish.yml so that
	// provision tests run whenever this file changes.
	layer := t.Dagger.Source.WithNewFile("sdk/python/src/dagger/_engine/_version.py", engineReference)
	return layer.Changes(t.Dagger.Source), nil
}
