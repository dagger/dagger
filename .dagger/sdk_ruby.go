package main

import (
	"context"
	"fmt"
	"path"
	"path/filepath"
	"strings"

	"go.opentelemetry.io/otel/codes"
	"golang.org/x/sync/errgroup"

	"github.com/dagger/dagger/.dagger/build"
	"github.com/dagger/dagger/.dagger/internal/dagger"
)

// TODO: use dev module (this is just the mage port)

const (
	rubyRuntimeSubdir    = "sdk/ruby/runtime"
	rubySdkSubdir        = "sdk/ruby"
	rubyGeneratedAPIDir  = "sdk/ruby/lib/dagger"
	rubyGeneratedAPIPath = "sdk/ruby/lib/dagger/client.gen.rb"

	rubyVersion = "3.3.6"
)

type RubySDK struct {
	Dagger *DaggerDev // +private
}

// Lint the Ruby SDK
func (r RubySDK) Lint(ctx context.Context) (rerr error) {
	eg, ctx := errgroup.WithContext(ctx)

	eg.Go(func() (rerr error) {
		ctx, span := Tracer().Start(ctx, "lint the ruby source")
		defer func() {
			if rerr != nil {
				span.SetStatus(codes.Error, rerr.Error())
			}
			span.End()
		}()
		_, err := r.rubyBase().WithWorkdir("/").WithExec([]string{"rubocop", "-l", "-c", filepath.Join(rubySdkSubdir, "rubocop.yml"), rubyGeneratedAPIPath}).Sync(ctx)
		return err
	})

	//eg.Go(func() (rerr error) {
	//	ctx, span := Tracer().Start(ctx, "lint Sorbet types")
	//	defer func() {
	//		if rerr != nil {
	//			span.SetStatus(codes.Error, rerr.Error())
	//		}
	//		span.End()
	//	}()
	//	_, err := r.
	//		rubyBase().
	//		WithExec([]string{"apk", "add", "build-base", "ruby-dev", "bash"}).
	//		WithWorkdir("/" + rubySdkSubdir).
	//		WithExec([]string{"bundle", "install"}).
	//		WithExec([]string{"bundle", "exec", "srb", "tc"}).
	//		Sync(ctx)
	//	return err
	//})

	eg.Go(func() (rerr error) {
		ctx, span := Tracer().Start(ctx, "check that the generated client library is up-to-date")
		defer func() {
			if rerr != nil {
				span.SetStatus(codes.Error, rerr.Error())
			}
			span.End()
		}()
		before := r.Dagger.Source().
			// the generated file is in the same repository than some other ruby files
			// TODO: improve to not hardcode those files
			WithoutFiles([]string{"sdk/ruby/lib/dagger/gqlclient.rb", "sdk/ruby/lib/dagger/node.rb"})
		after, err := r.Generate(ctx)
		if err != nil {
			return err
		}
		return dag.Dirdiff().AssertEqual(ctx, before, after, []string{
			rubyGeneratedAPIDir,
		})
	})

	eg.Go(func() (rerr error) {
		ctx, span := Tracer().Start(ctx, "lint the ruby runtime, which is written in Go")
		defer func() {
			if rerr != nil {
				span.SetStatus(codes.Error, rerr.Error())
			}
			span.End()
		}()
		return dag.
			Go(r.Dagger.WithModCodegen().Source()).
			Lint(ctx, dagger.GoLintOpts{Packages: []string{rubyRuntimeSubdir}})
	})

	return eg.Wait()
}

// Test the Ruby SDK
func (r RubySDK) Test(ctx context.Context) (rerr error) {
	return nil
}

// Regenerate the Ruby SDK API
func (r RubySDK) Generate(ctx context.Context) (*dagger.Directory, error) {
	installer, err := r.Dagger.installer(ctx, "sdk")
	if err != nil {
		return nil, err
	}
	build, err := build.NewBuilder(ctx, r.Dagger.Source())
	if err != nil {
		return nil, err
	}

	generated := r.rubyBase().
		With(installer).
		WithFile("/usr/local/bin/codegen", build.CodegenBinary()).
		WithExec([]string{"codegen", "--lang", "ruby", "-o", path.Dir(rubyGeneratedAPIPath)}).
		WithExec([]string{"rubocop", "-a", "-c", "rubocop.yml", rubyGeneratedAPIPath}).
		File(rubyGeneratedAPIPath)
	return dag.Directory().WithFile(rubyGeneratedAPIPath, generated), nil
}

// Test the publishing process
func (r RubySDK) TestPublish(ctx context.Context, tag string) error {
	return r.Publish(ctx, tag, true, nil, "https://github.com/dagger/dagger.git", nil)
}

// Publish the Ruby SDK
func (r RubySDK) Publish(
	ctx context.Context,
	tag string,

	// +optional
	dryRun bool,
	// +optional
	token *dagger.Secret,

	// +optional
	// +default="https://github.com/dagger/dagger.git"
	gitRepoSource string,
	// +optional
	githubToken *dagger.Secret,
) error {
	return nil
}

// Bump the Ruby SDK's Engine dependency
func (r RubySDK) Bump(ctx context.Context, version string) (*dagger.Directory, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")

	engineReference := fmt.Sprintf("// Code generated by dagger. DO NOT EDIT.\n"+
		"export const CLI_VERSION = %q\n", version)

	// NOTE: if you change this path, be sure to update .github/workflows/publish.yml so that
	// provision tests run whenever this file changes.
	return dag.Directory().WithNewFile("sdk/ruby/provisioning/default.rb", engineReference), nil
}

func (r RubySDK) rubyBase() *dagger.Container {
	// Use the LTS version by default
	return r.rubyBaseFromVersion(rubyVersion)
}

func (r RubySDK) rubyBaseFromVersion(rubyVersion string) *dagger.Container {
	appDir := "sdk/ruby"
	src := r.Dagger.Source().Directory(appDir)

	// Mirror the same dir structure from the repo because of the
	// relative paths in eslint (for docs linting).
	mountPath := fmt.Sprintf("/%s", appDir)

	rubyVersionImage := fmt.Sprintf("ruby:%s-alpine3.20", rubyVersion)

	return dag.Container().
		From(rubyVersionImage).
		WithExec([]string{"gem", "install", "rubocop"}).
		WithWorkdir(mountPath).
		WithDirectory(mountPath, src)
}
