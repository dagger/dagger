# This file was generated. See https://daggerverse.dev/mod/github.com/dagger/dagger/modules/gha
name: SDKs
"on":
    push:
        branches:
            - main
    pull_request:
        types:
            - opened
            - reopened
            - synchronize
            - ready_for_review
    workflow_dispatch: {}
permissions:
    contents: read
concurrency:
    group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
    cancel-in-progress: true
jobs:
    elixir:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: elixir
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/elixir
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    elixir-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: elixir-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/elixir
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    go:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: go
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/go
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    go-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: go-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/go
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    java:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: java
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/java
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    java-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: java-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/java
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    php:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: php
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/php
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    php-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: php-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/php
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    python:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: python
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/python
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    python-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: python-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/python
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    rust:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: rust
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/rust
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    rust-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: rust-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/rust
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    typescript:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-4c' || 'ubuntu-latest' }}
        name: typescript
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: v0.15.1
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/typescript
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
    typescript-dev:
        runs-on:
            - ${{ github.repository == 'dagger/dagger' && 'dagger-g2-v0-15-1-8c-dind' || 'ubuntu-latest' }}
        name: typescript-dev
        steps:
            - name: Checkout
              uses: actions/checkout@v4
            - name: scripts/install-dagger.sh
              id: install-dagger
              run: |
                #!/bin/bash

                set -o pipefail
                # Fallback to /usr/local for backwards compatability
                prefix_dir="${RUNNER_TEMP:-/usr/local}"

                # Ensure the dir is writable otherwise fallback to tmpdir
                if [[ ! -d "$prefix_dir" ]] || [[ ! -w "$prefix_dir" ]]; then
                    prefix_dir="$(mktemp -d)"
                fi
                printf '%s/bin' "$prefix_dir" >> $GITHUB_PATH

                # If the dagger version is 'latest', set the version back to an empty
                # string. This allows the install script to detect and install the latest
                # version itself
                if [[ "$DAGGER_VERSION" == "latest" ]]; then
                  DAGGER_VERSION=
                fi

                # The install.sh script creates path ${prefix_dir}/bin
                curl -fsS https://dl.dagger.io/dagger/install.sh | BIN_DIR=${prefix_dir}/bin sh
              env:
                DAGGER_VERSION: latest
              shell: bash
            - name: Install go
              uses: actions/setup-go@v5
              with:
                cache-dependency-path: .dagger/go.sum
                go-version: "1.23"
            - name: scripts/start-dev-dagger.sh
              id: start-dev-dagger
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                GITHUB_ENV="${GITHUB_ENV:=github.env}"
                DAGGER_SOURCE="${DAGGER_SOURCE:=.}"

                if [ ! -d "$DAGGER_SOURCE" ]; then
                    dagger core \
                        directory \
                        with-directory --path=. --directory="$DAGGER_SOURCE" \
                        export --path=dagger-source
                    DAGGER_SOURCE=./dagger-source
                fi

                echo "::group::Starting dev engine"
                if ! [[ -x "$(command -v docker)" ]]; then
                    echo "docker is not installed"
                    exit 1
                fi

                (
                    cd "$DAGGER_SOURCE"/.dagger/mage
                    go run main.go -w ../.. engine:dev
                ) \
                | sed 's/^export //' \
                | while IFS= read -r line; do
                    eval echo "$line"
                done \
                | tee "${GITHUB_ENV}"

                echo "::endgroup::"
              env:
                _EXPERIMENTAL_DAGGER_DEV_CONTAINER: dagger-engine.dev-${{ github.run_id }}-${{ github.job }}
                _EXPERIMENTAL_DAGGER_DEV_OUTPUT: ./bin/dev-${{ github.run_id }}-${{ github.job }}
                DAGGER_SOURCE: .
              shell: bash
            - name: scripts/warm-engine.sh
              id: warm-engine
              run: |
                #!/bin/bash

                # Make sure not to load any implicit module
                cd $(mktemp -d)
                # Run a simple query to "warm up" the engine
                echo '{directory{id}}' | dagger query
              shell: bash
            - name: scripts/exec.sh
              id: exec
              run: |
                #!/bin/bash --noprofile --norc -e -o pipefail

                if [[ -n "$DEBUG" && "$DEBUG" != "0" ]]; then
                    set -x
                    env
                    which dagger
                    pwd
                    ls -l
                    ps aux
                fi

                # Detect if a dev engine is available, if so: use that
                # We don't rely on PATH because the GHA runner messes with that
                if [[ -n "$_EXPERIMENTAL_DAGGER_CLI_BIN" ]]; then
                    export PATH=$(dirname "$_EXPERIMENTAL_DAGGER_CLI_BIN"):$PATH
                fi

                GITHUB_STEP_SUMMARY="${GITHUB_STEP_SUMMARY:=github-summary.md}"
                export NO_COLOR="${NO_COLOR:=1}" # Disable colors in dagger logs

                # Ensure the command is provided as an environment variable
                if [ -z "$COMMAND" ]; then
                  echo "Error: Please set the COMMAND environment variable."
                  exit 1
                fi

                tmp=$(mktemp -d)
                (
                    cd $tmp

                    # Create named pipes (FIFOs) for stdout and stderr
                    mkfifo stdout.fifo stderr.fifo

                    # Set up tee to capture and display stdout and stderr
                    tee stdout.txt < stdout.fifo &
                    tee stderr.txt < stderr.fifo >&2 &
                )

                # Run the command, capturing stdout and stderr in the FIFOs
                set +e
                eval "$COMMAND" > $tmp/stdout.fifo 2> $tmp/stderr.fifo
                EXIT_CODE=$?
                set -e
                # Wait for all background jobs to finish
                wait

                # Extra trace URL
                TRACE_URL=$(sed -En 's/^Full trace at (.*)/\1/p' < $tmp/stderr.txt)

                {
                cat <<'.'
                ## Dagger trace

                .

                if [[ "$TRACE_URL" == *"rotate dagger.cloud token for full url"* ]]; then
                    cat <<.
                Cloud token must be rotated. Please follow these steps:

                1. Go to [Dagger Cloud](https://dagger.cloud)
                2. Click on your profile icon in the bottom left corner
                3. Click on "Organization Settings"
                4. Click on "Regenerate token"
                5. Update the [\`DAGGER_CLOUD_TOKEN\` secret in your GitHub repository settings](https://github.com/${GITHUB_REPOSITORY:?Error: GITHUB_REPOSITORY is not set}/settings/secrets/actions/DAGGER_CLOUD_TOKEN)
                .
                elif [ -n "$TRACE_URL" ]; then
                    echo "[$TRACE_URL]($TRACE_URL)"
                else
                    echo "No trace available. To setup: [https://dagger.cloud/traces/setup](https://dagger.cloud/traces/setup)"
                fi

                cat <<'.'

                ## Dagger version

                ```
                .

                dagger version

                cat <<'.'
                ```

                ## Pipeline command

                ```bash
                .

                echo "DAGGER_MODULE=$DAGGER_MODULE \\"
                echo " $COMMAND"

                cat <<'.'
                ```

                ## Pipeline output

                ```
                .

                cat $tmp/stdout.txt

                cat <<'.'
                ```

                ## Pipeline logs

                ```
                .

                tail -n 1000 $tmp/stderr.txt

                cat <<'.'
                ```
                .

                } >"${GITHUB_STEP_SUMMARY}"

                exit $EXIT_CODE
              env:
                _EXPERIMENTAL_DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
                COMMAND: dagger call -q --docker-cfg=file:$HOME/.docker/config.json check --targets=sdk/typescript
                DAGGER_CLOUD_TOKEN: dag_dagger_sBIv6DsjNerWvTqt2bSFeigBUqWxp9bhh3ONSSgeFnw
              shell: bash
        timeout-minutes: 10
