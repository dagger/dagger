// Client is the Dagger Engine Client
type Client struct {
	{{- /*  The standalone client in not dev mode needs to store the dagger client for the global client to work */ -}}
	dag *dagger.Client
	query  *querybuilder.Selection
	client graphql.Client
}

// ClientOpt holds a client option
type ClientOpt = dagger.ClientOpt

// Request contains all the values required to build queries executed by the graphql.Client
type Request = dagger.Request

// Response contains data returned by the GraphQL API
type Response = dagger.Response

// WithWorkdir sets the engine workdir
var WithWorkdir = dagger.WithWorkdir

// WithLogOutput sets the progress writer
var WithLogOutput = dagger.WithLogOutput

// WithConn sets the engine connection explicitly
var WithConn = dagger.WithConn

// WithVersionOverride requests a specific schema version from the engine
var WithVersionOverride = dagger.WithVersionOverride

// WithVerbosity sets the verbosity level for the progress output
var WithVerbosity = dagger.WithVerbosity

// WithRunnerHost sets the runner host URL
var WithRunnerHost = dagger.WithRunnerHost

// WithEnvironmentVariable sets an environment variable in the CLI subprocess
var WithEnvironmentVariable = dagger.WithEnvironmentVariable


func Connect(ctx context.Context, opts ...ClientOpt) (*Client, error) {
	dag, err := dagger.Connect(ctx, opts...)
	if err != nil {
		return nil, err
	}

	c := &Client{
		query:  dag.QueryBuilder(),
		client: dag.GraphQLClient(),
		dag:    dag,
	}

	if err := serveModuleDependencies(ctx, c); err != nil {
		return nil, err
	}

	return c, nil
}

{{/*  The standalone client in not dev mode needs to expose a close method for the global client to work */ -}}
func (c *Client) Close() error {
	return c.dag.Close()
}

// GraphQLClient returns the underlying graphql.Client
func (c *Client) GraphQLClient() graphql.Client {
	return c.client
}

// QueryBuilder returns the underlying query builder
func (c *Client) QueryBuilder() *querybuilder.Selection {
	return c.query
}

// Do executes a raw GraphQL request using the client's session
func (c *Client) Do(ctx context.Context, req *Request, resp *Response) error {
	return c.dag.Do(ctx, req, resp)
}

// serveModuleDependencies services all dependencies of the module.
// Local dependencies are served by the dagger.json.
// Remote dependencies are generated by the client generator.
func serveModuleDependencies(ctx context.Context, client *Client) error {
  {{- /* Store the dependencies in a variable to avoid duplicating the code */ -}}
  {{- $dependencies := Dependencies -}}

	{{- /* Loop over the Git dependencies and serve them */ -}}
	{{- range $i, $dep := $dependencies -}}
		{{- if eq $dep.Kind "GIT_SOURCE" }}
	if err := client.ModuleSource(
		"{{ $dep.Source }}", 
		ModuleSourceOpts{RefPin: "{{ $dep.Pin }}"},
		).
		WithName("{{ $dep.Name }}").
		AsModule().
		Serve(ctx); err != nil {
		return err
	}
		{{ end -}}
	{{- end -}}

	{{/* Serve the local module if there are any local dependencies */}}
	modSrc := client.ModuleSource(".")
	configExist, err := modSrc.ConfigExists(ctx)
	if err != nil {
		return err
	}

	{{- if (HasLocalDependencies) }}
	if !configExist {
		return fmt.Errorf("dagger.json not found but is required to load local dependencies or the module itself")
	}
	{{- end }}

	if configExist {
		if err := modSrc.AsModule().Serve(ctx, ModuleServeOpts{
			IncludeDependencies: true,
		}); err != nil {
			return err
		}
	}

	return nil
}
