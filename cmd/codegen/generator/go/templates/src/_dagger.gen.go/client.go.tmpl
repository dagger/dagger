// Client is the Dagger Engine Client
type Client struct {
	{{- /*  The standalone client in not dev mode needs to store the dagger client for the global client to work */ -}}
	dag *dagger.Client
	query  *querybuilder.Selection
	client graphql.Client
}


func Connect(ctx context.Context, opts ...dagger.ClientOpt) (*Client, error) {
	dag, err := dagger.Connect(ctx, opts...)
	if err != nil {
		return nil, err
	}

	c := &Client{
		query:  dag.QueryBuilder(),
		client: dag.GraphQLClient(),
		dag:    dag,
	}

	if err := serveModuleDependencies(ctx, c); err != nil {
		return nil, err
	}

	return c, nil
}

{{/*  The standalone client in not dev mode needs to expose a close method for the global client to work */ -}}
func (c *Client) Close() error {
	return c.dag.Close()
}

// serveModuleDependencies services all dependencies of the module.
// Local dependencies are served by the dagger.json.
// Remote dependencies are generated by the client generator.
func serveModuleDependencies(ctx context.Context, client *Client) error {
  {{- /* Store the dependencies in a variable to avoid duplicating the code */ -}}
  {{- $dependencies := Dependencies -}}

	{{- /* Loop over the Git dependencies and serve them */ -}}
	{{- range $i, $dep := $dependencies -}}
		{{- if eq $dep.Kind "GIT_SOURCE" }}
	if err := client.ModuleSource(
		"{{ $dep.Source }}", 
		ModuleSourceOpts{RefPin: "{{ $dep.Pin }}"},
		).
		WithName("{{ $dep.Name }}").
		AsModule().
		Serve(ctx); err != nil {
		return err
	}
		{{ end -}}
	{{- end -}}

	{{/* Serve the local module if there are any local dependencies */}}
	modSrc := client.ModuleSource(".")
	configExist, err := modSrc.ConfigExists(ctx)
	if err != nil {
		return err
	}

	{{- if (HasLocalDependencies) }}
	if !configExist {
		return fmt.Errorf("dagger.json not found but is required to load local dependencies or the module itself")
	}
	{{- end }}

	if configExist {
		if err := modSrc.AsModule().Serve(ctx, ModuleServeOpts{
			IncludeDependencies: true,
		}); err != nil {
			return err
		}
	}

	return nil
}
