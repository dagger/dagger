// Client is the Dagger Engine Client
type Client struct {
	{{- /*  The standalone client in not dev mode needs to store the dagger client for the global client to work */ -}}
	dag *dagger.Client
	query  *querybuilder.Selection
	client graphql.Client
}

// errorWrappedClient wraps the SDK's graphql.Client to convert errors
// into this package's ExecError type instead of the SDK's ExecError type.
type errorWrappedClient struct {
	graphql.Client
}

func (c errorWrappedClient) MakeRequest(ctx context.Context, req *graphql.Request, resp *graphql.Response) error {
	err := c.Client.MakeRequest(ctx, req, resp)
	if err != nil {
		if e := getCustomError(err); e != nil {
			return e
		}
		return err
	}
	return nil
}
// ClientOpt holds a client option
type ClientOpt = dagger.ClientOpt

// Request contains all the values required to build queries executed by the graphql.Client
type Request = dagger.Request

// Response contains data returned by the GraphQL API
type Response = dagger.Response

// WithWorkdir sets the engine workdir
var WithWorkdir = dagger.WithWorkdir

// WithLogOutput sets the progress writer
var WithLogOutput = dagger.WithLogOutput

// WithConn sets the engine connection explicitly
var WithConn = dagger.WithConn

// WithVersionOverride requests a specific schema version from the engine
var WithVersionOverride = dagger.WithVersionOverride

// WithVerbosity sets the verbosity level for the progress output
var WithVerbosity = dagger.WithVerbosity

// WithRunnerHost sets the runner host URL
var WithRunnerHost = dagger.WithRunnerHost

// WithEnvironmentVariable sets an environment variable in the CLI subprocess
var WithEnvironmentVariable = dagger.WithEnvironmentVariable


func Connect(ctx context.Context, opts ...ClientOpt) (*Client, error) {
	dag, err := dagger.Connect(ctx, opts...)
	if err != nil {
		return nil, err
	}

	gqlClient := errorWrappedClient{dag.GraphQLClient()}
	c := &Client{
		query:  dag.QueryBuilder().Client(gqlClient),
		client: gqlClient,
		dag:    dag,
	}

	// Serve module dependencies on a best-effort basis. In some contexts
	// (e.g., inside a container without access to host paths or when the
	// engine can't resolve transitive git dependencies), serving may fail.
	// This should not prevent the client from connecting.
	_ = serveModuleDependencies(ctx, c)

	return c, nil
}

{{/*  The standalone client in not dev mode needs to expose a close method for the global client to work */ -}}
func (c *Client) Close() error {
	return c.dag.Close()
}

// GraphQLClient returns the underlying graphql.Client
func (c *Client) GraphQLClient() graphql.Client {
	return c.client
}

// QueryBuilder returns the underlying query builder
func (c *Client) QueryBuilder() *querybuilder.Selection {
	return c.query
}

// Do executes a raw GraphQL request using the client's session
func (c *Client) Do(ctx context.Context, req *Request, resp *Response) error {
	daggerReq := &dagger.Request{
		Query:     req.Query,
		Variables: req.Variables,
		OpName:    req.OpName,
	}
	daggerResp := &dagger.Response{
		Data:       resp.Data,
		Extensions: resp.Extensions,
		Errors:     resp.Errors,
	}

	err := c.dag.Do(ctx, daggerReq, daggerResp)

	resp.Data = daggerResp.Data
	resp.Extensions = daggerResp.Extensions
	resp.Errors = daggerResp.Errors

	if err != nil {
		if e := getCustomError(err); e != nil {
			return e
		}
	}
	return err
}

// serveModuleDependencies serves all dependencies of the module.
// Dependencies are baked in at generation time by the client generator.
func serveModuleDependencies(ctx context.Context, client *Client) error {
  {{- /* Store the dependencies in a variable to avoid duplicating the code */ -}}
  {{- $dependencies := Dependencies -}}

	{{- /* Loop over the Git dependencies and serve them */ -}}
	{{- range $i, $dep := $dependencies -}}
		{{- if eq $dep.Kind "GIT_SOURCE" }}
	if err := client.ModuleSource(
		"{{ $dep.Source }}", 
		ModuleSourceOpts{RefPin: "{{ $dep.Pin }}"},
		).
		WithName("{{ $dep.Name }}").
		AsModule().
		Serve(ctx); err != nil {
		return err
	}
		{{ end -}}
	{{- end -}}

	{{/* Serve local dependencies only if we're in a module context (dagger.json exists at ".") */}}
	modSrc := client.ModuleSource(".")
	configExist, err := modSrc.ConfigExists(ctx)
	if err != nil {
		return err
	}

	if configExist {
	{{- range $i, $dep := $dependencies -}}
		{{- if eq $dep.Kind "LOCAL_SOURCE" }}
		// Local dependencies may not be resolvable in all contexts (e.g.,
		// when running inside a container where the engine can't access
		// the host paths). Skip gracefully if they can't be served.
		_ = client.ModuleSource("{{ $dep.SourceRootSubpath }}").
			WithName("{{ $dep.Name }}").
			AsModule().
			Serve(ctx)
		{{ end -}}
	{{- end -}}
	}

	return nil
}
