{{/* The standalone client does not need to generate a dag file since it's not used for anything */}}
{{ if and (not IsModuleCode) }}
// Code generated by dagger. DO NOT EDIT.

package dag

import (
	"context"
	"os"
	"sync"
	
	dagger "{{.PackageImport}}"
)

var client *dagger.Client
var clientMu sync.Mutex

func initClient() *dagger.Client {
	clientMu.Lock()
	defer clientMu.Unlock()

	if client == nil {
		opts := []dagger.ClientOpt{
		  dagger.WithLogOutput(os.Stdout),
		}

		{{ if IsStandaloneClient }}
		opts = append(opts, dagger.WithServeCurrentModule(true))
		{{ end }}

		ctx := context.Background()

		var err error
		client, err = dagger.Connect(ctx, opts...)
		if err != nil {
			panic(err)
		}

		{{ if IsStandaloneClient }}
	  {{- range $i, $dep := Dependencies }}
		if err = client.ModuleSource("{{ $dep.Ref }}", dagger.ModuleSourceOpts{RefPin: "{{ $dep.Pin }}"}).WithName("{{ $dep.Name }}").AsModule().Serve(ctx); err != nil {
			panic(err)
		}
		{{ end }}
		{{- end }}
	}
	return client
}

// Close the engine connection
func Close() error {
	clientMu.Lock()
	defer clientMu.Unlock()

	var err error
	if client != nil {
		err = client.Close()
		client = nil
	}
	return err
}

{{ range .Types }}
{{ if eq .Kind "OBJECT" }}

{{- if eq .Name "Query" }}

{{ range $field := .Fields }}
{{ $field.Description | Comment }}
{{- if $field.IsDeprecated }}
//
{{ $field.DeprecationReason | FormatDeprecation }}
{{- end }}
{{- $supportsVoid := CheckVersionCompatibility "v0.12.0" }}
{{ FieldFunction $field true $supportsVoid "dagger" }} {
	client := initClient()
	return client.{{ .Name | FormatName }}(
		{{- if not $field.TypeRef.IsObject -}}
		ctx,
		{{- end -}}
		{{- range $arg := $field.Args -}}
		{{- if not $arg.TypeRef.IsOptional -}}
		{{ $arg.Name }},
		{{- end -}}
		{{- end -}}
		{{- if $field.Args.HasOptionals -}}
		opts...,
		{{- end -}}
	)
}

{{ end }}
{{- end }}
{{ end }}

{{ end }}
{{ end }}