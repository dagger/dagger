package core

import (
	"context"
	"fmt"
	"io"
	"io/fs"
	"os"
	"path"
	"path/filepath"
	"slices"
	"strings"
	"syscall"
	"time"

	containerdfs "github.com/containerd/continuity/fs"
	fscopy "github.com/dagger/dagger/engine/sources/local/copy"
	"github.com/dustin/go-humanize"
	bkcache "github.com/moby/buildkit/cache"
	bkclient "github.com/moby/buildkit/client"
	"github.com/moby/buildkit/client/llb"
	bkgw "github.com/moby/buildkit/frontend/gateway/client"
	"github.com/moby/buildkit/solver/pb"
	"github.com/moby/patternmatcher"
	"github.com/pkg/errors"
	fstypes "github.com/tonistiigi/fsutil/types"
	"github.com/vektah/gqlparser/v2/ast"

	"dagger.io/dagger/telemetry"
	"github.com/dagger/dagger/dagql"
	"github.com/dagger/dagger/engine/buildkit"
)

// Directory is a content-addressed directory.
type Directory struct {
	LLB    *pb.Definition
	Result bkcache.ImmutableRef // only valid when returned by dagop

	Dir      string
	Platform Platform

	// Services necessary to provision the directory.
	Services ServiceBindings
}

func (*Directory) Type() *ast.Type {
	return &ast.Type{
		NamedType: "Directory",
		NonNull:   true,
	}
}

func (*Directory) TypeDescription() string {
	return "A directory."
}

var _ HasPBDefinitions = (*Directory)(nil)

func (dir *Directory) PBDefinitions(ctx context.Context) ([]*pb.Definition, error) {
	var defs []*pb.Definition
	if dir.LLB != nil {
		defs = append(defs, dir.LLB)
	}
	for _, bnd := range dir.Services {
		ctr := bnd.Service.Self().Container
		if ctr == nil {
			continue
		}
		ctrDefs, err := ctr.PBDefinitions(ctx)
		if err != nil {
			return nil, err
		}
		defs = append(defs, ctrDefs...)
	}
	return defs, nil
}

func NewDirectory(def *pb.Definition, dir string, platform Platform, services ServiceBindings) *Directory {
	return &Directory{
		LLB:      def,
		Dir:      dir,
		Platform: platform,
		Services: services,
	}
}

func NewScratchDirectory(ctx context.Context, platform Platform) (*Directory, error) {
	return NewDirectorySt(ctx, llb.Scratch(), "/", platform, nil)
}

func NewDirectorySt(ctx context.Context, st llb.State, dir string, platform Platform, services ServiceBindings) (*Directory, error) {
	def, err := st.Marshal(ctx, llb.Platform(platform.Spec()))
	if err != nil {
		return nil, err
	}

	return NewDirectory(def.ToPB(), dir, platform, services), nil
}

// Clone returns a deep copy of the container suitable for modifying in a
// WithXXX method.
func (dir *Directory) Clone() *Directory {
	cp := *dir
	cp.Services = slices.Clone(cp.Services)
	return &cp
}

var _ dagql.OnReleaser = (*Directory)(nil)

func (dir *Directory) OnRelease(ctx context.Context) error {
	if dir.Result != nil {
		return dir.Result.Release(ctx)
	}
	return nil
}

func (dir *Directory) State() (llb.State, error) {
	if dir.LLB == nil {
		return llb.Scratch(), nil
	}

	return defToState(dir.LLB)
}

func (dir *Directory) StateWithSourcePath() (llb.State, error) {
	dirSt, err := dir.State()
	if err != nil {
		return llb.State{}, err
	}

	if dir.Dir == "/" {
		return dirSt, nil
	}

	return llb.Scratch().File(
		llb.Copy(dirSt, dir.Dir, ".", &llb.CopyInfo{
			CopyDirContentsOnly: true,
		}),
	), nil
}

func (dir *Directory) SetState(ctx context.Context, st llb.State) error {
	def, err := st.Marshal(ctx,
		llb.Platform(dir.Platform.Spec()),
		buildkit.WithTracePropagation(ctx),
		buildkit.WithPassthrough(), // these spans aren't particularly interesting
	)
	if err != nil {
		return err
	}

	dir.LLB = def.ToPB()
	return nil
}

func (dir *Directory) Evaluate(ctx context.Context) (*buildkit.Result, error) {
	if dir.LLB == nil {
		return nil, nil
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get buildkit client: %w", err)
	}

	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return nil, err
	}
	defer detach()

	return bk.Solve(ctx, bkgw.SolveRequest{
		Evaluate:   true,
		Definition: dir.LLB,
	})
}

func (dir *Directory) Digest(ctx context.Context) (string, error) {
	result, err := dir.Evaluate(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to evaluate directory: %w", err)
	}
	if result == nil {
		return "", fmt.Errorf("failed to evaluate null directory")
	}

	digest, err := result.Ref.Digest(ctx, dir.Dir)
	if err != nil {
		return "", fmt.Errorf("failed to compute digest: %w", err)
	}

	return digest.String(), nil
}

func (dir *Directory) Stat(ctx context.Context, bk *buildkit.Client, svcs *Services, src string) (*fstypes.Stat, error) {
	src = path.Join(dir.Dir, src)

	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return nil, fmt.Errorf("failed to start bindings: %w", err)
	}
	defer detach()

	res, err := bk.Solve(ctx, bkgw.SolveRequest{
		Definition: dir.LLB,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to solve: %w", err)
	}

	ref, err := res.SingleRef()
	if err != nil {
		return nil, fmt.Errorf("failed to get single ref: %w", err)
	}
	// empty directory, i.e. llb.Scratch()
	if ref == nil {
		if clean := path.Clean(src); clean == "." || clean == "/" {
			// fake out a reasonable response
			return &fstypes.Stat{
				Path: src,
				Mode: uint32(fs.ModeDir),
			}, nil
		}

		return nil, fmt.Errorf("%s: %w", src, syscall.ENOENT)
	}

	st, err := ref.StatFile(ctx, bkgw.StatRequest{
		Path: src,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to stat file %s: %w", src, err)
	}
	return st, nil
}

func (dir *Directory) Entries(ctx context.Context, src string) ([]string, error) {
	src = path.Join(dir.Dir, src)

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get buildkit client: %w", err)
	}

	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return nil, err
	}
	defer detach()

	res, err := bk.Solve(ctx, bkgw.SolveRequest{
		Definition: dir.LLB,
	})
	if err != nil {
		return nil, err
	}

	ref, err := res.SingleRef()
	if err != nil {
		return nil, err
	}
	// empty directory, i.e. llb.Scratch()
	if ref == nil {
		if clean := path.Clean(src); clean == "." || clean == "/" {
			return []string{}, nil
		}
		return nil, fmt.Errorf("%s: no such file or directory", src)
	}

	entries, err := ref.ReadDir(ctx, bkgw.ReadDirRequest{
		Path: src,
	})
	if err != nil {
		return nil, err
	}

	useSlash, err := SupportsDirSlash(ctx)
	if err != nil {
		return nil, err
	}

	paths := []string{}
	for _, entry := range entries {
		path := entry.Path
		if useSlash && os.FileMode(entry.Mode).IsDir() {
			path += "/"
		}
		paths = append(paths, path)
	}

	return paths, nil
}

// Glob returns a list of files that matches the given pattern.
func (dir *Directory) Glob(ctx context.Context, pattern string) ([]string, error) {
	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get buildkit client: %w", err)
	}

	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return nil, err
	}
	defer detach()

	res, err := bk.Solve(ctx, bkgw.SolveRequest{
		Definition: dir.LLB,
	})
	if err != nil {
		return nil, err
	}

	ref, err := res.SingleRef()
	if err != nil {
		return nil, err
	}
	// empty directory, i.e. llb.Scratch()
	if ref == nil {
		return []string{}, nil
	}

	// We use the same pattern matching function as Buildkit, since just doing
	// IncludePatterns will still include directories we don't want
	pm, err := patternmatcher.New([]string{pattern})
	if err != nil {
		return nil, err
	}

	useSlash, err := SupportsDirSlash(ctx)
	if err != nil {
		return nil, err
	}

	var paths []string
	err = ref.WalkDir(ctx, buildkit.WalkDirRequest{
		IncludePattern: pattern,
		Path:           dir.Dir,
		Callback: func(path string, info os.FileInfo) error {
			// HACK: ideally, we'd have something like MatchesExact, which
			// would skip the parent behavior that we don't really want here -
			// oh well, let's just fake it with false
			//nolint:staticcheck
			match, err := pm.MatchesUsingParentResult(filepath.Clean(path), false)
			if err != nil {
				return err
			}

			if useSlash && info.Mode().IsDir() {
				path += "/"
			}
			if match {
				paths = append(paths, path)
			}

			return nil
		},
	})
	if err != nil {
		return nil, err
	}

	return paths, nil
}

func (dir *Directory) WithNewFile(ctx context.Context, dest string, content []byte, permissions fs.FileMode, ownership *Ownership) (*Directory, error) {
	dir = dir.Clone()

	err := validateFileName(dest)
	if err != nil {
		return nil, err
	}

	if permissions == 0 {
		permissions = 0o644
	}

	// be sure to create the file under the working directory
	dest = path.Join(dir.Dir, dest)

	st, err := dir.State()
	if err != nil {
		return nil, err
	}

	parent, _ := path.Split(dest)
	if parent != "" {
		st = st.File(llb.Mkdir(parent, 0755, llb.WithParents(true)))
	}

	opts := []llb.MkfileOption{}
	if ownership != nil {
		opts = append(opts, ownership.Opt())
	}

	st = st.File(llb.Mkfile(dest, permissions, content, opts...))

	err = dir.SetState(ctx, st)
	if err != nil {
		return nil, err
	}

	return dir, nil
}

func (dir *Directory) WithNewFileDagOp(ctx context.Context, dest string, content []byte, permissions fs.FileMode, ownership *Ownership) (*Directory, error) {
	dir = dir.Clone()

	err := validateFileName(dest)
	if err != nil {
		return nil, err
	}

	if permissions == 0 {
		permissions = 0o644
	}

	parentRef, err := getRefOrEvaluate(ctx, dir.Result, dir)
	if err != nil {
		return nil, err
	}

	bkSessionGroup, ok := buildkit.CurrentBuildkitSessionGroup(ctx)
	if !ok {
		return nil, fmt.Errorf("no buildkit session group in context")
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}

	newRef, err := query.BuildkitCache().New(ctx, parentRef, bkSessionGroup, bkcache.WithRecordType(bkclient.UsageRecordTypeRegular),
		bkcache.WithDescription(fmt.Sprintf("withNewFile %s (%s)", dest, humanize.Bytes(uint64(len(content))))))
	if err != nil {
		return nil, err
	}
	err = MountRef(ctx, newRef, bkSessionGroup, func(root string) error {
		resolvedDest, err := containerdfs.RootPath(root, path.Join(dir.Dir, dest))
		if err != nil {
			return err
		}
		destPathDir, _ := filepath.Split(resolvedDest)
		err = os.MkdirAll(filepath.Dir(destPathDir), 0755)
		if err != nil {
			return err
		}
		dst, err := os.OpenFile(resolvedDest, os.O_RDWR|os.O_CREATE|os.O_TRUNC, permissions)
		if err != nil {
			return err
		}
		defer func() {
			if dst != nil {
				_ = dst.Close()
			}
		}()

		_, err = dst.Write(content)
		if err != nil {
			return err
		}

		err = dst.Close()
		if err != nil {
			return err
		}
		dst = nil

		if ownership != nil {
			err = os.Chown(resolvedDest, ownership.UID, ownership.GID)
			if err != nil {
				return fmt.Errorf("failed to set chown %s: err", resolvedDest)
			}
		}

		return nil
	})
	if err != nil {
		return nil, err
	}
	snap, err := newRef.Commit(ctx)
	if err != nil {
		return nil, err
	}
	dir.Result = snap
	return dir, nil
}

func (dir *Directory) Directory(ctx context.Context, subdir string) (*Directory, error) {
	dir = dir.Clone()

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get buildkit client: %w", err)
	}

	dir.Dir = path.Join(dir.Dir, subdir)

	// check that the directory actually exists so the user gets an error earlier
	// rather than when the dir is used
	info, err := dir.Stat(ctx, bk, svcs, ".")
	if err != nil {
		return nil, err
	}

	if !info.IsDir() {
		return nil, fmt.Errorf("path %s is a file, not a directory", subdir)
	}

	return dir, nil
}

func (dir *Directory) File(ctx context.Context, file string) (*File, error) {
	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get buildkit client: %w", err)
	}

	err = validateFileName(file)
	if err != nil {
		return nil, err
	}

	// check that the file actually exists so the user gets an error earlier
	// rather than when the file is used
	info, err := dir.Stat(ctx, bk, svcs, file)
	if err != nil {
		return nil, err
	}

	if info.IsDir() {
		return nil, fmt.Errorf("path %s is a directory, not a file", file)
	}

	return &File{
		LLB:      dir.LLB,
		Result:   dir.Result,
		File:     path.Join(dir.Dir, file),
		Platform: dir.Platform,
		Services: dir.Services,
	}, nil
}

type CopyFilter struct {
	Exclude []string `default:"[]"`
	Include []string `default:"[]"`
}

func (dir *Directory) WithDirectory(ctx context.Context, destDir string, src *Directory, filter CopyFilter, owner *Ownership) (*Directory, error) {
	dir = dir.Clone()

	destSt, err := dir.State()
	if err != nil {
		return nil, err
	}

	srcSt, err := src.State()
	if err != nil {
		return nil, err
	}

	if err := dir.SetState(ctx, mergeStates(mergeStateInput{
		Dest:            destSt,
		DestDir:         path.Join(dir.Dir, destDir),
		Src:             srcSt,
		SrcDir:          src.Dir,
		IncludePatterns: filter.Include,
		ExcludePatterns: filter.Exclude,
		Owner:           owner,
	})); err != nil {
		return nil, err
	}

	dir.Services.Merge(src.Services)

	return dir, nil
}

func copyFile(srcPath, dstPath string) (err error) {
	srcStat, err := os.Stat(srcPath)
	if err != nil {
		return err
	}
	srcPerm := srcStat.Mode().Perm()
	src, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer src.Close()

	dst, err := os.OpenFile(dstPath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, srcPerm)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			_ = os.Remove(dstPath)
		}
	}()
	defer func() {
		if dst != nil {
			dst.Close()
		}
	}()
	_, err = io.Copy(dst, src)
	if err != nil {
		return err
	}
	err = dst.Close()
	if err != nil {
		return err
	}
	dst = nil

	modTime := srcStat.ModTime()
	return os.Chtimes(dstPath, modTime, modTime)
}

func isDir(path string) (bool, error) {
	fi, err := os.Stat(path)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return false, nil
		}
		return false, err
	}
	return fi.Mode().IsDir(), nil
}

func getRefOrEvaluate(ctx context.Context, ref bkcache.ImmutableRef, t Evaluatable) (bkcache.ImmutableRef, error) {
	if ref != nil {
		return ref, nil
	}
	res, err := t.Evaluate(ctx)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, nil
	}
	cacheRef, err := res.SingleRef()
	if err != nil {
		return nil, err
	}
	if cacheRef == nil {
		return nil, nil
	}
	return cacheRef.CacheRef(ctx)
}

func (dir *Directory) WithFile(
	ctx context.Context,
	srv *dagql.Server,
	destPath string,
	src *File,
	permissions *int,
	owner *Ownership,
) (*Directory, error) {
	dir = dir.Clone()

	srcCacheRef, err := getRefOrEvaluate(ctx, src.Result, src)
	if err != nil {
		return nil, err
	}

	dirCacheRef, err := getRefOrEvaluate(ctx, dir.Result, dir)
	if err != nil {
		return nil, err
	}

	bkSessionGroup, ok := buildkit.CurrentBuildkitSessionGroup(ctx)
	if !ok {
		return nil, fmt.Errorf("no buildkit session group in context")
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}

	destPath = path.Join(dir.Dir, destPath)
	newRef, err := query.BuildkitCache().New(ctx, dirCacheRef, bkSessionGroup, bkcache.WithRecordType(bkclient.UsageRecordTypeRegular),
		bkcache.WithDescription(fmt.Sprintf("withfile %s %s", destPath, src.File)))
	if err != nil {
		return nil, err
	}
	err = MountRef(ctx, newRef, bkSessionGroup, func(dirRoot string) error {
		destPath, err := containerdfs.RootPath(dirRoot, destPath)
		if err != nil {
			return err
		}
		destIsDir, err := isDir(destPath)
		if err != nil {
			return err
		}
		if destIsDir {
			_, srcFilename := filepath.Split(src.File)
			destPath = path.Join(destPath, srcFilename)
		}
		destPathDir, _ := filepath.Split(destPath)
		err = os.MkdirAll(filepath.Dir(destPathDir), 0755)
		if err != nil {
			return err
		}
		err = MountRef(ctx, srcCacheRef, bkSessionGroup, func(srcRoot string) error {
			srcPath, err := containerdfs.RootPath(srcRoot, src.File)
			if err != nil {
				return err
			}
			return copyFile(srcPath, destPath)
		})
		if err != nil {
			return err
		}
		if permissions != nil {
			if err := os.Chmod(destPath, os.FileMode(*permissions)); err != nil {
				return fmt.Errorf("failed to set chmod %s: err", destPath)
			}
		}
		if owner != nil {
			if err := os.Chown(destPath, owner.UID, owner.GID); err != nil {
				return fmt.Errorf("failed to set chown %s: err", destPath)
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	snap, err := newRef.Commit(ctx)
	if err != nil {
		return nil, err
	}
	dir.Result = snap
	return dir, nil
}

// TODO: address https://github.com/dagger/dagger/pull/6556/files#r1482830091
func (dir *Directory) WithFiles(
	ctx context.Context,
	srv *dagql.Server,
	destDir string,
	src []*File,
	permissions *int,
	owner *Ownership,
) (*Directory, error) {
	dir = dir.Clone()

	var err error
	for _, file := range src {
		dir, err = dir.WithFile(
			ctx,
			srv,
			path.Join(destDir, path.Base(file.File)),
			file,
			permissions,
			owner,
		)
		if err != nil {
			return nil, err
		}
	}

	return dir, nil
}

type mergeStateInput struct {
	Dest         llb.State
	DestDir      string
	DestFileName string

	Src         llb.State
	SrcDir      string
	SrcFileName string

	IncludePatterns []string
	ExcludePatterns []string

	Permissions *int
	Owner       *Ownership
}

func mergeStates(input mergeStateInput) llb.State {
	input.DestDir = path.Join("/", input.DestDir)
	input.SrcDir = path.Join("/", input.SrcDir)

	copyInfo := &llb.CopyInfo{
		CreateDestPath:      true,
		CopyDirContentsOnly: true,
		IncludePatterns:     input.IncludePatterns,
		ExcludePatterns:     input.ExcludePatterns,
	}
	if input.DestFileName == "" && input.SrcFileName != "" {
		input.DestFileName = input.SrcFileName
	}
	if input.Permissions != nil {
		fm := fs.FileMode(*input.Permissions)
		copyInfo.Mode = &fm
	}
	if input.Owner != nil {
		input.Owner.Opt().SetCopyOption(copyInfo)
	}

	// MergeOp currently only supports merging the "/" of states together without any
	// modifications or filtering
	canDoDirectMerge := copyInfo.Mode == nil &&
		copyInfo.ChownOpt == nil &&
		len(copyInfo.ExcludePatterns) == 0 &&
		len(copyInfo.IncludePatterns) == 0 &&
		input.DestDir == "/" &&
		input.SrcDir == "/" &&
		// TODO:(sipsma) we could support direct merge-op with individual files if we can verify
		// there are no other files in the dir, but doing so by just calling ReadDir would result
		// in unlazying the inputs, which defeats some of the performance benefits of merge-op.
		input.DestFileName == "" &&
		input.SrcFileName == ""

	mergeStates := []llb.State{input.Dest}
	if canDoDirectMerge {
		// Directly merge the states together, which is lazy, uses hardlinks instead of
		// copies and caches inputs individually instead of invalidating the whole
		// chain following any modified input.
		mergeStates = append(mergeStates, input.Src)
	} else {
		// Even if we can't merge directly, we can still get some optimization by
		// copying to scratch and then merging that. This still results in an on-disk
		// copy but preserves the other caching benefits of MergeOp. This is the same
		// behavior as "COPY --link" in Dockerfiles.
		mergeStates = append(mergeStates, llb.Scratch().File(llb.Copy(
			input.Src, path.Join(input.SrcDir, input.SrcFileName), path.Join(input.DestDir, input.DestFileName), copyInfo,
		)))
	}
	return llb.Merge(mergeStates)
}

func (dir *Directory) WithTimestamps(ctx context.Context, unix int) (*Directory, error) {
	dir = dir.Clone()

	st, err := dir.State()
	if err != nil {
		return nil, err
	}

	t := time.Unix(int64(unix), 0)
	st = llb.Scratch().File(
		llb.Copy(st, dir.Dir, ".", &llb.CopyInfo{
			CopyDirContentsOnly: true,
			CreatedTime:         &t,
		}),
	)

	err = dir.SetState(ctx, st)
	if err != nil {
		return nil, err
	}

	dir.Dir = ""

	return dir, nil
}

func (dir *Directory) WithNewDirectory(ctx context.Context, dest string, permissions fs.FileMode) (*Directory, error) {
	dir = dir.Clone()

	dest = path.Clean(dest)
	if strings.HasPrefix(dest, "../") {
		return nil, fmt.Errorf("cannot create directory outside parent: %s", dest)
	}

	// be sure to create the file under the working directory
	dest = path.Join(dir.Dir, dest)

	if permissions == 0 {
		permissions = 0755
	}

	parentRef, err := getRefOrEvaluate(ctx, dir.Result, dir)
	if err != nil {
		return nil, err
	}

	bkSessionGroup, ok := buildkit.CurrentBuildkitSessionGroup(ctx)
	if !ok {
		return nil, fmt.Errorf("no buildkit session group in context")
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}

	newRef, err := query.BuildkitCache().New(ctx, parentRef, bkSessionGroup, bkcache.WithRecordType(bkclient.UsageRecordTypeRegular),
		bkcache.WithDescription(fmt.Sprintf("withNewDirectory %s", dest)))
	if err != nil {
		return nil, err
	}
	err = MountRef(ctx, newRef, bkSessionGroup, func(root string) error {
		resolvedDir, err := containerdfs.RootPath(root, dest)
		if err != nil {
			return err
		}
		return os.MkdirAll(resolvedDir, permissions)
	})
	if err != nil {
		return nil, err
	}
	snap, err := newRef.Commit(ctx)
	if err != nil {
		return nil, err
	}
	dir.Result = snap
	return dir, nil
}

func (dir *Directory) Diff(ctx context.Context, other *Directory) (*Directory, error) {
	dir = dir.Clone()

	thisDirPath := dir.Dir
	if thisDirPath == "" {
		thisDirPath = "/"
	}
	otherDirPath := other.Dir
	if otherDirPath == "" {
		otherDirPath = "/"
	}
	if thisDirPath != otherDirPath {
		// TODO(vito): work around with llb.Copy shenanigans?
		return nil, fmt.Errorf("cannot diff with different relative paths: %q != %q", dir.Dir, other.Dir)
	}

	lowerSt, err := dir.State()
	if err != nil {
		return nil, err
	}

	upperSt, err := other.State()
	if err != nil {
		return nil, err
	}

	err = dir.SetState(ctx, llb.Diff(lowerSt, upperSt))
	if err != nil {
		return nil, err
	}

	return dir, nil
}

func (dir *Directory) Without(ctx context.Context, srv *dagql.Server, paths ...string) (*Directory, error) {
	dir = dir.Clone()

	parentRef, err := getRefOrEvaluate(ctx, dir.Result, dir)
	if err != nil {
		return nil, err
	}

	bkSessionGroup, ok := buildkit.CurrentBuildkitSessionGroup(ctx)
	if !ok {
		return nil, fmt.Errorf("no buildkit session group in context")
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}

	newRef, err := query.BuildkitCache().New(ctx, parentRef, bkSessionGroup, bkcache.WithRecordType(bkclient.UsageRecordTypeRegular),
		bkcache.WithDescription(fmt.Sprintf("without %s", strings.Join(paths, ","))))
	if err != nil {
		return nil, err
	}
	err = MountRef(ctx, newRef, bkSessionGroup, func(root string) error {
		for _, p := range paths {
			p = path.Join(dir.Dir, p)
			var matches []string
			if strings.Contains(p, "*") {
				matches, err = fscopy.ResolveWildcards(root, p, true)
				if err != nil {
					return err
				}
			} else {
				matches = []string{p}
			}
			for _, m := range matches {
				fullPath, err := RootPathWithoutFinalSymlink(root, m)
				if err != nil {
					return err
				}
				err = os.RemoveAll(fullPath)
				if err != nil {
					return err
				}
			}
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	snap, err := newRef.Commit(ctx)
	if err != nil {
		return nil, err
	}
	dir.Result = snap
	return dir, nil
}

func (dir *Directory) Export(ctx context.Context, destPath string, merge bool) (rerr error) {
	query, err := CurrentQuery(ctx)
	if err != nil {
		return err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return fmt.Errorf("failed to get services: %w", err)
	}
	bk, err := query.Buildkit(ctx)
	if err != nil {
		return fmt.Errorf("failed to get buildkit client: %w", err)
	}

	var defPB *pb.Definition
	if dir.Dir != "" && dir.Dir != "/" {
		src, err := dir.State()
		if err != nil {
			return err
		}
		src = llb.Scratch().File(llb.Copy(src, dir.Dir, ".", &llb.CopyInfo{
			CopyDirContentsOnly: true,
		}))

		def, err := src.Marshal(ctx, llb.Platform(dir.Platform.Spec()))
		if err != nil {
			return err
		}
		defPB = def.ToPB()
	} else {
		defPB = dir.LLB
	}

	ctx, span := Tracer(ctx).Start(ctx, fmt.Sprintf("export directory %s to host %s", dir.Dir, destPath))
	defer telemetry.End(span, func() error { return rerr })

	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return err
	}
	defer detach()

	return bk.LocalDirExport(ctx, defPB, destPath, merge)
}

// Root removes any relative path from the directory.
func (dir *Directory) Root() (*Directory, error) {
	dir = dir.Clone()
	dir.Dir = "/"
	return dir, nil
}

func (dir *Directory) WithSymlink(ctx context.Context, srv *dagql.Server, target, linkName string) (*Directory, error) {
	dir = dir.Clone()

	parentRef, err := getRefOrEvaluate(ctx, dir.Result, dir)
	if err != nil {
		return nil, err
	}

	bkSessionGroup, ok := buildkit.CurrentBuildkitSessionGroup(ctx)
	if !ok {
		return nil, fmt.Errorf("no buildkit session group in context")
	}

	query, err := CurrentQuery(ctx)
	if err != nil {
		return nil, err
	}

	linkName = path.Join(dir.Dir, linkName)
	newRef, err := query.BuildkitCache().New(ctx, parentRef, bkSessionGroup, bkcache.WithRecordType(bkclient.UsageRecordTypeRegular),
		bkcache.WithDescription(fmt.Sprintf("symlink %s -> %s", linkName, target)))
	if err != nil {
		return nil, err
	}
	err = MountRef(ctx, newRef, bkSessionGroup, func(root string) error {
		linkDir, linkBasename := filepath.Split(linkName)
		resolvedLinkDir, err := containerdfs.RootPath(root, linkDir)
		if err != nil {
			return err
		}
		err = os.MkdirAll(resolvedLinkDir, 0755)
		if err != nil {
			return err
		}
		resolvedLinkName := path.Join(resolvedLinkDir, linkBasename)
		return os.Symlink(target, resolvedLinkName)
	})
	if err != nil {
		return nil, err
	}
	snap, err := newRef.Commit(ctx)
	if err != nil {
		return nil, err
	}
	dir.Result = snap
	return dir, nil
}

func (dir *Directory) Mount(ctx context.Context, f func(string) error) error {
	query, err := CurrentQuery(ctx)
	if err != nil {
		return err
	}
	svcs, err := query.Services(ctx)
	if err != nil {
		return fmt.Errorf("failed to get services: %w", err)
	}
	detach, _, err := svcs.StartBindings(ctx, dir.Services)
	if err != nil {
		return err
	}
	defer detach()

	return mountLLB(ctx, dir.LLB, func(root string) error {
		src, err := containerdfs.RootPath(root, dir.Dir)
		if err != nil {
			return err
		}
		return f(src)
	})
}

func validateFileName(file string) error {
	baseFileName := filepath.Base(file)
	if len(baseFileName) > 255 {
		return errors.Errorf("File name length exceeds the maximum supported 255 characters")
	}
	return nil
}

func SupportsDirSlash(ctx context.Context) (bool, error) {
	return Supports(ctx, "v0.17.0")
}
