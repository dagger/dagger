// Code generated by capnpc-go. DO NOT EDIT.

package idproto

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
	math "math"
	strconv "strconv"
)

type ID capnp.Struct

// ID_TypeID is the unique identifier for the type ID.
const ID_TypeID = 0xfc87b5dc97bbd695

func NewID(s *capnp.Segment) (ID, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ID(st), err
}

func NewRootID(s *capnp.Segment) (ID, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return ID(st), err
}

func ReadRootID(msg *capnp.Message) (ID, error) {
	root, err := msg.Root()
	return ID(root.Struct()), err
}

func (s ID) String() string {
	str, _ := text.Marshal(0xfc87b5dc97bbd695, capnp.Struct(s))
	return str
}

func (s ID) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (ID) DecodeFromPtr(p capnp.Ptr) ID {
	return ID(capnp.Struct{}.DecodeFromPtr(p))
}

func (s ID) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s ID) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s ID) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s ID) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s ID) TypeName() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s ID) HasTypeName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s ID) TypeNameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s ID) SetTypeName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s ID) Constructor() (Selector_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Selector_List(p.List()), err
}

func (s ID) HasConstructor() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s ID) SetConstructor(v Selector_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewConstructor sets the constructor field to a newly
// allocated Selector_List, preferring placement in s's segment.
func (s ID) NewConstructor(n int32) (Selector_List, error) {
	l, err := NewSelector_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Selector_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// ID_List is a list of ID.
type ID_List = capnp.StructList[ID]

// NewID creates a new list of ID.
func NewID_List(s *capnp.Segment, sz int32) (ID_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[ID](l), err
}

// ID_Future is a wrapper for a ID promised by a client call.
type ID_Future struct{ *capnp.Future }

func (f ID_Future) Struct() (ID, error) {
	p, err := f.Future.Ptr()
	return ID(p.Struct()), err
}

type Selector capnp.Struct

// Selector_TypeID is the unique identifier for the type Selector.
const Selector_TypeID = 0x801dbcdaecfe49ad

func NewSelector(s *capnp.Segment) (Selector, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Selector(st), err
}

func NewRootSelector(s *capnp.Segment) (Selector, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Selector(st), err
}

func ReadRootSelector(msg *capnp.Message) (Selector, error) {
	root, err := msg.Root()
	return Selector(root.Struct()), err
}

func (s Selector) String() string {
	str, _ := text.Marshal(0x801dbcdaecfe49ad, capnp.Struct(s))
	return str
}

func (s Selector) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Selector) DecodeFromPtr(p capnp.Ptr) Selector {
	return Selector(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Selector) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Selector) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Selector) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Selector) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Selector) Field() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Selector) HasField() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Selector) FieldBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Selector) SetField(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Selector) Args() (Argument_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Argument_List(p.List()), err
}

func (s Selector) HasArgs() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Selector) SetArgs(v Argument_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewArgs sets the args field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Selector) NewArgs(n int32) (Argument_List, error) {
	l, err := NewArgument_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s Selector) Tainted() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Selector) SetTainted(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

func (s Selector) Meta() bool {
	return capnp.Struct(s).Bit(1)
}

func (s Selector) SetMeta(v bool) {
	capnp.Struct(s).SetBit(1, v)
}

// Selector_List is a list of Selector.
type Selector_List = capnp.StructList[Selector]

// NewSelector creates a new list of Selector.
func NewSelector_List(s *capnp.Segment, sz int32) (Selector_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Selector](l), err
}

// Selector_Future is a wrapper for a Selector promised by a client call.
type Selector_Future struct{ *capnp.Future }

func (f Selector_Future) Struct() (Selector, error) {
	p, err := f.Future.Ptr()
	return Selector(p.Struct()), err
}

type Argument capnp.Struct

// Argument_TypeID is the unique identifier for the type Argument.
const Argument_TypeID = 0xa8c3245d5eb77903

func NewArgument(s *capnp.Segment) (Argument, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Argument(st), err
}

func NewRootArgument(s *capnp.Segment) (Argument, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Argument(st), err
}

func ReadRootArgument(msg *capnp.Message) (Argument, error) {
	root, err := msg.Root()
	return Argument(root.Struct()), err
}

func (s Argument) String() string {
	str, _ := text.Marshal(0xa8c3245d5eb77903, capnp.Struct(s))
	return str
}

func (s Argument) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Argument) DecodeFromPtr(p capnp.Ptr) Argument {
	return Argument(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Argument) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Argument) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Argument) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Argument) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Argument) Name() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Argument) HasName() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Argument) NameBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Argument) SetName(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Argument) Value() (Literal, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return Literal(p.Struct()), err
}

func (s Argument) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Argument) SetValue(v Literal) error {
	return capnp.Struct(s).SetPtr(1, capnp.Struct(v).ToPtr())
}

// NewValue sets the value field to a newly
// allocated Literal struct, preferring placement in s's segment.
func (s Argument) NewValue() (Literal, error) {
	ss, err := NewLiteral(capnp.Struct(s).Segment())
	if err != nil {
		return Literal{}, err
	}
	err = capnp.Struct(s).SetPtr(1, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Argument_List is a list of Argument.
type Argument_List = capnp.StructList[Argument]

// NewArgument creates a new list of Argument.
func NewArgument_List(s *capnp.Segment, sz int32) (Argument_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Argument](l), err
}

// Argument_Future is a wrapper for a Argument promised by a client call.
type Argument_Future struct{ *capnp.Future }

func (f Argument_Future) Struct() (Argument, error) {
	p, err := f.Future.Ptr()
	return Argument(p.Struct()), err
}
func (p Argument_Future) Value() Literal_Future {
	return Literal_Future{Future: p.Future.Field(1, nil)}
}

type Literal capnp.Struct
type Literal_Which uint16

const (
	Literal_Which_id     Literal_Which = 0
	Literal_Which_null   Literal_Which = 1
	Literal_Which_bool   Literal_Which = 2
	Literal_Which_enum   Literal_Which = 3
	Literal_Which_int    Literal_Which = 4
	Literal_Which_float  Literal_Which = 5
	Literal_Which_string Literal_Which = 6
	Literal_Which_list   Literal_Which = 7
	Literal_Which_object Literal_Which = 8
)

func (w Literal_Which) String() string {
	const s = "idnullboolenumintfloatstringlistobject"
	switch w {
	case Literal_Which_id:
		return s[0:2]
	case Literal_Which_null:
		return s[2:6]
	case Literal_Which_bool:
		return s[6:10]
	case Literal_Which_enum:
		return s[10:14]
	case Literal_Which_int:
		return s[14:17]
	case Literal_Which_float:
		return s[17:22]
	case Literal_Which_string:
		return s[22:28]
	case Literal_Which_list:
		return s[28:32]
	case Literal_Which_object:
		return s[32:38]

	}
	return "Literal_Which(" + strconv.FormatUint(uint64(w), 10) + ")"
}

// Literal_TypeID is the unique identifier for the type Literal.
const Literal_TypeID = 0xc0d90883df065347

func NewLiteral(s *capnp.Segment) (Literal, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Literal(st), err
}

func NewRootLiteral(s *capnp.Segment) (Literal, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1})
	return Literal(st), err
}

func ReadRootLiteral(msg *capnp.Message) (Literal, error) {
	root, err := msg.Root()
	return Literal(root.Struct()), err
}

func (s Literal) String() string {
	str, _ := text.Marshal(0xc0d90883df065347, capnp.Struct(s))
	return str
}

func (s Literal) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Literal) DecodeFromPtr(p capnp.Ptr) Literal {
	return Literal(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Literal) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}

func (s Literal) Which() Literal_Which {
	return Literal_Which(capnp.Struct(s).Uint16(0))
}
func (s Literal) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Literal) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Literal) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Literal) Id() (ID, error) {
	if capnp.Struct(s).Uint16(0) != 0 {
		panic("Which() != id")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return ID(p.Struct()), err
}

func (s Literal) HasId() bool {
	if capnp.Struct(s).Uint16(0) != 0 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Literal) SetId(v ID) error {
	capnp.Struct(s).SetUint16(0, 0)
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewId sets the id field to a newly
// allocated ID struct, preferring placement in s's segment.
func (s Literal) NewId() (ID, error) {
	capnp.Struct(s).SetUint16(0, 0)
	ss, err := NewID(capnp.Struct(s).Segment())
	if err != nil {
		return ID{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s Literal) SetNull() {
	capnp.Struct(s).SetUint16(0, 1)

}

func (s Literal) Bool() bool {
	if capnp.Struct(s).Uint16(0) != 2 {
		panic("Which() != bool")
	}
	return capnp.Struct(s).Bit(16)
}

func (s Literal) SetBool(v bool) {
	capnp.Struct(s).SetUint16(0, 2)
	capnp.Struct(s).SetBit(16, v)
}

func (s Literal) Enum() (string, error) {
	if capnp.Struct(s).Uint16(0) != 3 {
		panic("Which() != enum")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Literal) HasEnum() bool {
	if capnp.Struct(s).Uint16(0) != 3 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Literal) EnumBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Literal) SetEnum(v string) error {
	capnp.Struct(s).SetUint16(0, 3)
	return capnp.Struct(s).SetText(0, v)
}

func (s Literal) Int() int64 {
	if capnp.Struct(s).Uint16(0) != 4 {
		panic("Which() != int")
	}
	return int64(capnp.Struct(s).Uint64(8))
}

func (s Literal) SetInt(v int64) {
	capnp.Struct(s).SetUint16(0, 4)
	capnp.Struct(s).SetUint64(8, uint64(v))
}

func (s Literal) Float() float64 {
	if capnp.Struct(s).Uint16(0) != 5 {
		panic("Which() != float")
	}
	return math.Float64frombits(capnp.Struct(s).Uint64(8))
}

func (s Literal) SetFloat(v float64) {
	capnp.Struct(s).SetUint16(0, 5)
	capnp.Struct(s).SetUint64(8, math.Float64bits(v))
}

func (s Literal) String() (string, error) {
	if capnp.Struct(s).Uint16(0) != 6 {
		panic("Which() != string")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Literal) HasString() bool {
	if capnp.Struct(s).Uint16(0) != 6 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Literal) StringBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Literal) SetString(v string) error {
	capnp.Struct(s).SetUint16(0, 6)
	return capnp.Struct(s).SetText(0, v)
}

func (s Literal) List() (Literal_List, error) {
	if capnp.Struct(s).Uint16(0) != 7 {
		panic("Which() != list")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Literal_List(p.List()), err
}

func (s Literal) HasList() bool {
	if capnp.Struct(s).Uint16(0) != 7 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Literal) SetList(v Literal_List) error {
	capnp.Struct(s).SetUint16(0, 7)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewList sets the list field to a newly
// allocated Literal_List, preferring placement in s's segment.
func (s Literal) NewList(n int32) (Literal_List, error) {
	capnp.Struct(s).SetUint16(0, 7)
	l, err := NewLiteral_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Literal_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Literal) Object() (Argument_List, error) {
	if capnp.Struct(s).Uint16(0) != 8 {
		panic("Which() != object")
	}
	p, err := capnp.Struct(s).Ptr(0)
	return Argument_List(p.List()), err
}

func (s Literal) HasObject() bool {
	if capnp.Struct(s).Uint16(0) != 8 {
		return false
	}
	return capnp.Struct(s).HasPtr(0)
}

func (s Literal) SetObject(v Argument_List) error {
	capnp.Struct(s).SetUint16(0, 8)
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewObject sets the object field to a newly
// allocated Argument_List, preferring placement in s's segment.
func (s Literal) NewObject(n int32) (Argument_List, error) {
	capnp.Struct(s).SetUint16(0, 8)
	l, err := NewArgument_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Argument_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Literal_List is a list of Literal.
type Literal_List = capnp.StructList[Literal]

// NewLiteral creates a new list of Literal.
func NewLiteral_List(s *capnp.Segment, sz int32) (Literal_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 16, PointerCount: 1}, sz)
	return capnp.StructList[Literal](l), err
}

// Literal_Future is a wrapper for a Literal promised by a client call.
type Literal_Future struct{ *capnp.Future }

func (f Literal_Future) Struct() (Literal, error) {
	p, err := f.Future.Ptr()
	return Literal(p.Struct()), err
}
func (p Literal_Future) Id() ID_Future {
	return ID_Future{Future: p.Future.Field(0, nil)}
}

const schema_93d909241605aeda = "x\xdatS\xcfkSY\x18=\xe7\xde\xf7\xf2\x83&" +
	"M\xc2\x0b\xc30\x10Z\x86,f\x0a\x1d\xda\x99\xceb" +
	"\xba\xe9\xcc0\x83T\xaa\xf46[\x15_\x92\xd7\xfa\xe4" +
	"\xe5\xa5$/\xd6\x82bQApg\xa5\x88\xff\x81\x1b" +
	"\xdd\x15\x11]\x08.\xfc\x0f\x84\x16\xc1\xa5.*(T" +
	"l5\xed\x95\xdb\x90\xa4\xfe\xda}\xef|\xdf\xbb\xe7\xdc" +
	"s\xbe;v\x99\x7f[\xe3\xe9\xa7\x02B\x0d\xdb1}" +
	"wz\x7fk\xf3Qa\x05*I\xea\xcd{\xf6\x0f\xc5" +
	"\xe4\xc6M\xd8\"\x0e8\xd3\\u\x14Mu\x8c/A" +
	"-\x97\xef\x9f:Y|r\x07\xb9\xe4W\xb3\xe3b\xd5" +
	"\xf9\xeb\xa0\xfaS,\x81\xfaH)\xf6\xe2Jb\xe3\xb1" +
	"9X\xf4\x87\xffg<\x0987\xc4u\xe7\xb6\x99\xfe" +
	"cMh\x82z\xed\xd9\xc3[\xcf\xd7\xaf\xb5\xbfu\xf4" +
	"\xbaUv\x1eX\x9dj\x09\xa3\xda\xaf\xfeVq\x17\xc3" +
	"EN\x96\xbc\xc0\xabDu6fI\x95\x95\x16`\x11" +
	"\xc8\xb9\xbf\x03\xea\x84\xa4:#\x98#\xf34\xa07\x02" +
	"\xa8\xd3\x92\xea\x82 E\x9e\x02\xc8-\xff\x0b\xa8HR" +
	"\xad\x08\xe6$\xf3\x94@\xee\xa2\x19</\xa9\xae\x0a\x0e" +
	"\xcd\xfb^Pe\x0a\x82)0\xe36\x16\x9a\x1c\x04g" +
	"%\x99\xed\xdb\x01\x1a\xf0R\xe4\xfaa\xe4UI\x08\x12" +
	"\xcc\xd4\xbc\xc8\xed~\x1c\x12\xfdOc\xa1U\xf3BF" +
	"Ft\xa2'\xfaWC[\x94Tc\x87D\x8f\x9a\x9b" +
	"\xfc\"\xa9&\x043\xa1[\xf3\xbaR\x86\xce\xb9A\xcb" +
	"c\xb6\xef3\xc8\xecg<3~\xe45\xdc\x000<" +
	"Ei\xa5\xb4> z\xfd\x13\xa0^I\xaam\xc14" +
	"\xf7u\x87\xe9\xad\xa1\xdf\x92T;\x82\x05\xb1\xa7\xb3\x1d" +
	"\x87\xde\x19\xf8\x8d\xa4j\x0b\xa6e[w,\xda5\xe8" +
	"\xb6\xe4\x1c\x05\x0b\xd6G\xcd<- \xb7\xf73\xa0v" +
	"$K\x96\xc1\xed\x0f\x06\xb7\x01\x874\xd7hK\x96\x12" +
	"\x14L\xc7vu\x9e1\xc0\xb19\x09\xccQ\xb2\x942" +
	"x|G\xe7\x0f\xb6-\xc9\x11\xa0d\x99\xc6\xb0i$" +
	"\xde\xeb<\x13\x80S0?\x94~4\x8d\x09\x0aJ\xbf" +
	"\xcal\x7fu:\x0ed\xc2V\x10 \x96)\xd7\xebA" +
	"/\x0a/l\xd5\xba\xd6\xc5\xfd0\xa2\x0dA\x1b\x1c\x9a" +
	"\x0f\xean\xc4\x01\x08\x0e\x80S\xcd\xa8\xe1\x87\x0b\xbd\xb8" +
	"\x03\xbf\x19\xf5\xe3>\xec\xf4 8U/\x9f\xf5*\xd1" +
	"w\xd7\xa1\x97\x04\xe2\x93\xd3\xff}\x91\xf5\xd1~\xac\xbd" +
	"\xac\xc7\xcb\x80\x1a\x93T3\x82:Z^\xf4\x8e\xbb5" +
	"\x0f@W\x8e\xae\xd4\xc3f\xd4hU\x10\x8f\xea\x8d>" +
	"o\xef\x09wx?\x05\x00\x00\xff\xff\xa1S\xd8t"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_93d909241605aeda,
		Nodes: []uint64{
			0x801dbcdaecfe49ad,
			0xa8c3245d5eb77903,
			0xc0d90883df065347,
			0xfc87b5dc97bbd695,
		},
		Compressed: true,
	})
}
