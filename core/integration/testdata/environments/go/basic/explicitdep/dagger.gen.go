// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	goast "go/ast"
	"go/parser"
	"go/token"
	"net"
	"net/http"
	"os"
	"reflect"
	"runtime"
	"strconv"
	"strings"

	"dagger.io/dagger/querybuilder"
	"github.com/Khan/genqlient/graphql"
	"github.com/iancoleman/strcase"
)

var (
	errorT      = reflect.TypeOf((*error)(nil)).Elem()
	stringT     = reflect.TypeOf((*string)(nil)).Elem()
	marshallerT = reflect.TypeOf((*querybuilder.GraphQLMarshaller)(nil)).Elem()
	contextT    = reflect.TypeOf((*context.Context)(nil)).Elem()
)

var resolvers = map[string]*goFunc{}

var getEnv bool

func getClientParams() (graphql.Client, *querybuilder.Selection) {
	portStr, ok := os.LookupEnv("DAGGER_SESSION_PORT")
	if !ok {
		panic("DAGGER_SESSION_PORT is not set")
	}
	port, err := strconv.Atoi(portStr)
	if err != nil {
		panic(fmt.Errorf("DAGGER_SESSION_PORT %q is invalid: %w", portStr, err))
	}

	sessionToken := os.Getenv("DAGGER_SESSION_TOKEN")
	if sessionToken == "" {
		panic("DAGGER_SESSION_TOKEN is not set")
	}

	host := fmt.Sprintf("127.0.0.1:%d", port)

	dialTransport := &http.Transport{
		DialContext: func(_ context.Context, _, _ string) (net.Conn, error) {
			return net.Dial("tcp", host)
		},
	}
	httpClient := &http.Client{
		Transport: roundTripperFunc(func(r *http.Request) (*http.Response, error) {
			r.SetBasicAuth(sessionToken, "")
			return dialTransport.RoundTrip(r)
		}),
	}
	gqlClient := graphql.NewClient(fmt.Sprintf("http://%s/query", host), httpClient)

	return gqlClient, querybuilder.Query()
}

func Serve(r *Environment) {
	ctx := context.Background()
	if getEnv {
		id, err := r.ID(ctx)
		if err != nil {
			writeErrorf(err)
		}
		err = os.WriteFile("/env/id", []byte(id), 0644)
		if err != nil {
			writeErrorf(err)
		}
		return
	}

	inputBytes, err := os.ReadFile("/inputs/dagger.json")
	if err != nil {
		writeErrorf(fmt.Errorf("unable to open request file: %w", err))
	}
	var input struct {
		Resolver string
		Parent   map[string]any
		Args     map[string]any
	}
	if err := json.Unmarshal(inputBytes, &input); err != nil {
		writeErrorf(fmt.Errorf("unable to parse request file: %w", err))
	}

	if input.Resolver == "" {
		writeErrorf(fmt.Errorf("missing resolver"))
	}
	fieldName := input.Resolver
	fn := resolvers[fieldName]

	var result any
	if fn == nil {
		// trivial resolver
		if input.Parent != nil {
			result = input.Parent[fieldName]
		}
	} else {
		res, err := fn.call(ctx, input.Parent, input.Args)
		if err != nil {
			writeErrorf(err)
		}
		result = res
	}
	if result == nil {
		result = make(map[string]any)
	}

	output, err := json.Marshal(result)
	if err != nil {
		writeErrorf(fmt.Errorf("unable to marshal response: %v", err))
	}
	if err := os.WriteFile("/outputs/dagger.json", output, 0600); err != nil {
		writeErrorf(fmt.Errorf("unable to write response file: %v", err))
	}
}

func WithCheck(r *Environment, in any) *Environment {
	if _, ok := in.(*Check); ok {
		// just let the codegen sdk caller handle this
		return nil
	}
	flag.Parse()

	typ := reflect.TypeOf(in)
	if typ.Kind() != reflect.Func {
		writeErrorf(fmt.Errorf("expected func, got %v", typ))
	}
	val := reflect.ValueOf(in)
	name := runtime.FuncForPC(val.Pointer()).Name()
	if name == "" {
		writeErrorf(fmt.Errorf("anonymous functions are not supported"))
	}
	fn := &goFunc{
		name: name,
		typ:  typ,
		val:  val,
	}
	for i := 0; i < fn.typ.NumIn(); i++ {
		inputParam := fn.typ.In(i)
		fn.args = append(fn.args, &goParam{
			typ: inputParam,
		})
	}

	for i := 0; i < fn.typ.NumOut(); i++ {
		outputParam := fn.typ.Out(i)
		fn.returns = append(fn.returns, &goParam{
			typ: outputParam,
		})
	}
	if len(fn.returns) == 0 || len(fn.returns) > 2 {
		writeErrorf(fmt.Errorf("expected 1 or 2 return values, got %d", len(fn.returns)))
	}

	// handle sugar for different return value types
	fn.resultWrapper = func(returns []reflect.Value) (any, error) {
		if len(returns) == 1 {
			rtVal := returns[0]
			switch rtVal.Type() {
			case stringT:
				// only returned a string, so assume success because we didn't panic
				// and return a check result with the string as output
				rtStr, ok := rtVal.Interface().(string)
				if !ok {
					return nil, fmt.Errorf("expected string, got %T", rtVal.Interface())
				}
				return dag.StaticCheckResult(true, StaticCheckResultOpts{
					Output: rtStr,
				}), nil
			case errorT:
				if rtVal.IsNil() {
					// only returned a nil error, so assume success, no output
					return dag.StaticCheckResult(true), nil
				} else {
					// only returned a non-nil error, so assume failure and return
					// a check result with the output set to the error value
					rtErr, ok := rtVal.Interface().(error)
					if !ok {
						return nil, fmt.Errorf("expected error, got %T", rtVal.Interface())
					}
					return dag.StaticCheckResult(false, StaticCheckResultOpts{
						Output: rtErr.Error(),
					}), nil
				}
			default:
				return rtVal.Interface(), nil
			}
		}

		var rt any
		switch returns[0].Type() {
		case stringT:
			rt = returns[0].Interface()
		default:
			if !returns[0].IsNil() {
				rt = returns[0].Interface()
			}
		}

		var rtErr error
		if !returns[1].IsNil() {
			var ok bool
			rtErr, ok = returns[1].Interface().(error)
			if !ok {
				return nil, fmt.Errorf("expected error, got %T", returns[1].Interface())
			}
		}

		switch rt := rt.(type) {
		case string:
			// returned (string, error), so assume success if error is nil, set output
			// from the string and, if err is non-nil, append it to the output
			output := rt
			success := rtErr == nil
			if !success {
				output += "\nError: " + rtErr.Error()
			}
			return dag.StaticCheckResult(success, StaticCheckResultOpts{
				Output: output,
			}), nil
		default:
			return rt, rtErr
		}
	}

	filePath, lineNum := fn.srcPathAndLine()
	// TODO: cache parsed files
	fileSet := token.NewFileSet()
	parsed, err := parser.ParseFile(fileSet, filePath, nil, parser.ParseComments)
	if err != nil {
		writeErrorf(fmt.Errorf("parse file: %w", err))
	}
	goast.Inspect(parsed, func(n goast.Node) bool {
		if n == nil {
			return false
		}
		switch decl := n.(type) {
		case *goast.FuncDecl:
			astStart := fileSet.PositionFor(decl.Pos(), false)
			astEnd := fileSet.PositionFor(decl.End(), false)
			// lineNum can be inside the function body due to optimizations that set it to
			// the location of the return statement
			if lineNum < astStart.Line || lineNum > astEnd.Line {
				return true
			}

			fn.name = decl.Name.Name
			fn.doc = strings.TrimSpace(decl.Doc.Text())

			fnArgs := fn.args
			if decl.Recv != nil {
				// ignore the object receiver for now
				fnArgs = fnArgs[1:]
				fn.hasReceiver = true
			}
			astParamList := decl.Type.Params.List
			argIndex := 0
			for _, param := range astParamList {
				// if the signature is like func(a, b string), then a and b are in the same Names slice
				for _, name := range param.Names {
					fnArgs[argIndex].name = name.Name
					argIndex++
				}
			}
			return false

		case *goast.GenDecl:
		default:
		}
		return true
	})

	resolvers[lowerCamelCase(fn.name)] = fn

	if !getEnv {
		return r
	}

	return r.WithCheck(dag.Check().
		WithName(strcase.ToLowerCamel(fn.name)).
		WithDescription(fn.doc))
}

type goTypes struct {
	Structs map[string]*goStruct
	Funcs   map[string]*goFunc
}

type goStruct struct {
	name    string
	typ     reflect.Type
	fields  []*goField
	methods []*goFunc
	doc     string
	// should this become a field of the Query type?
	topLevel bool
	// should this become a graphql Input type instead of an Object type?
	usedAsInput bool
}

type goField struct {
	name string
	typ  reflect.Type
}

type goFunc struct {
	name string
	// args are args to the function, except for the receiver
	// (if it's a method) and for the Context arg.
	args          []*goParam
	returns       []*goParam
	typ           reflect.Type
	val           reflect.Value
	hasReceiver   bool
	doc           string
	resultWrapper func([]reflect.Value) (any, error)
}

type goParam struct {
	name     string
	doc      string
	typ      reflect.Type
	optional bool
}

func (fn *goFunc) srcPathAndLine() (string, int) {
	pc := fn.val.Pointer()
	fun := runtime.FuncForPC(pc)
	return fun.FileLine(pc)
}

func (fn *goFunc) call(ctx context.Context, rawParent, rawArgs map[string]any) (any, error) {
	var callArgs []reflect.Value
	if fn.hasReceiver {
		callArgs = append(callArgs, reflect.New(fn.args[0].typ).Elem())
	}

	for _, arg := range fn.args[len(callArgs):] {
		if arg.typ.Implements(contextT) {
			callArgs = append(callArgs, reflect.ValueOf(ctx))
			continue
		}

		rawArg, argValuePresent := rawArgs[arg.name]

		// support FooOpts structs
		if arg.typ.Kind() == reflect.Struct {
			opts := reflect.New(arg.typ)
			for i := 0; i < arg.typ.NumField(); i++ {
				field := arg.typ.Field(i)
				rawArg, optPresent := rawArgs[strcase.ToLowerCamel(field.Name)]
				if optPresent {
					optVal, err := convertInput(rawArg, field.Type)
					if err != nil {
						return nil, fmt.Errorf("unable to convert arg %s: %w", arg.name, err)
					}
					opts.Elem().Field(i).Set(reflect.ValueOf(optVal))
				}
			}
			callArgs = append(callArgs, opts.Elem())
			continue
		}

		switch {
		case argValuePresent:
			argVal, err := convertInput(rawArg, arg.typ)
			if err != nil {
				return nil, fmt.Errorf("unable to convert arg %s: %w", arg.name, err)
			}
			callArgs = append(callArgs, reflect.ValueOf(argVal))
		case !arg.optional:
			return nil, fmt.Errorf("missing required argument %s", arg.name)
		default:
			callArgs = append(callArgs, reflect.New(arg.typ).Elem())
		}
	}

	reflectOutputs := fn.val.Call(callArgs)
	return fn.resultWrapper(reflectOutputs)
}

func init() {
	// TODO:(sipsma) silly+unmaintainable, is there a pre-made list of these somewhere?
	// Or can we have a rule that "ALLCAPS" becomes "allcaps" instead of aLLCAPS?
	strcase.ConfigureAcronym("URL", "url")
	strcase.ConfigureAcronym("CI", "ci")
	strcase.ConfigureAcronym("SDK", "sdk")
}

func lowerCamelCase(s string) string {
	return strcase.ToLowerCamel(s)
}

func inputName(name string) string {
	return name + "Input"
}

// TODO: doc, basically inverse of convertResult
func convertInput(input any, desiredType reflect.Type) (any, error) {
	// check if desiredType implements querybuilder.GraphQLMarshaller, in which case it's a core type e.g. Container
	if desiredType.Implements(marshallerT) {
		// ID-able dagger objects are serialized as their ID string across the wire
		// between the session and project container.
		id, ok := input.(string)
		if !ok {
			return nil, fmt.Errorf("expected id to be a string, got %T(%+v)", input, input)
		}
		if desiredType.Kind() != reflect.Ptr {
			// just assuming it's always a pointer for now, not actually important
			return nil, fmt.Errorf("expected desiredType to be a pointer, got %s", desiredType.Kind())
		}
		desiredType = desiredType.Elem()

		// TODO: Add a .XXX_GraphQLObject(id) method to the generated SDK code to make this simpler + more maintainable
		graphqlType := reflect.New(desiredType).Interface().(querybuilder.GraphQLMarshaller).XXX_GraphQLType()
		switch graphqlType {
		case "Container":
			return dag.Container(ContainerOpts{
				ID: ContainerID(id),
			}), nil
		case "Directory":
			return dag.Directory(DirectoryOpts{
				ID: DirectoryID(id),
			}), nil
		case "Socket":
			return dag.Socket(SocketOpts{
				ID: SocketID(id),
			}), nil
		case "File":
			return dag.File(FileID(id)), nil
		case "Secret":
			return dag.Secret(SecretID(id)), nil
		case "Cache":
			cacheID := CacheID(id)
			return CacheVolume{
				q:  dag.q,
				c:  dag.c,
				id: &cacheID,
			}, nil
		default:
			return nil, fmt.Errorf("unhandled GraphQL marshaller type %s", graphqlType)
		}
	}

	// recurse
	inputObj := reflect.ValueOf(input)
	switch desiredType.Kind() {
	case reflect.Pointer:
		x, err := convertInput(inputObj.Interface(), desiredType.Elem())
		if err != nil {
			return nil, err
		}
		ptr := reflect.New(desiredType.Elem())
		ptr.Elem().Set(reflect.ValueOf(x))
		return ptr.Interface(), nil
	case reflect.Slice:
		returnObj := reflect.MakeSlice(desiredType, inputObj.Len(), inputObj.Len())
		for i := 0; i < inputObj.Len(); i++ {
			value := inputObj.Index(i).Interface()
			convertedValue, err := convertInput(value, desiredType.Elem())
			if err != nil {
				return nil, err
			}
			returnObj.Index(i).Set(reflect.ValueOf(convertedValue))
		}
		return returnObj.Interface(), nil
	case reflect.Struct:
		returnObj := reflect.New(desiredType).Elem()
		for i := 0; i < desiredType.NumField(); i++ {
			inputMap, ok := input.(map[string]any)
			if !ok {
				return nil, fmt.Errorf("expected input to be a map[string]any, got %T", input)
			}
			value := inputMap[lowerCamelCase(desiredType.Field(i).Name)]
			desiredValueType := desiredType.Field(i).Type
			convertedField, err := convertInput(value, desiredValueType)
			if err != nil {
				return nil, err
			}
			returnObj.Field(i).Set(reflect.ValueOf(convertedField))
		}
		return returnObj.Interface(), nil
	case reflect.Map:
		returnObj := reflect.MakeMap(desiredType)
		for _, key := range inputObj.MapKeys() {
			value := inputObj.MapIndex(key).Interface()
			convertedValue, err := convertInput(value, desiredType.Elem())
			if err != nil {
				return nil, err
			}
			inputObj.SetMapIndex(key, reflect.ValueOf(convertedValue))
		}
		return returnObj.Interface(), nil
	default:
		return input, nil
	}
}

func writeErrorf(err error) {
	fmt.Println(err.Error())
	os.Exit(1)
}

// TODO: pollutes namespace, move to non internal package in dagger.io/dagger
type roundTripperFunc func(*http.Request) (*http.Response, error)

func (fn roundTripperFunc) RoundTrip(req *http.Request) (*http.Response, error) {
	return fn(req)
}

type DAG struct {
	c graphql.Client
	q *querybuilder.Selection
}

var dag *DAG

func init() {
	flag.BoolVar(&getEnv, "env", false, "build and return the environment definition rather than executing an entrypoint")

	gqlClient, q := getClientParams()
	dag = &DAG{
		c: gqlClient,
		q: q,
	}
}

func (r *Environment) Serve() {
	Serve(r)
}

// A global cache volume identifier.
type CacheID string

// A unique environment check identifier.
type CheckID string

// A unique environment check result identifier.
type CheckResultID string

// A unique container identifier. Null designates an empty container (scratch).
type ContainerID string

// A content-addressed directory identifier.
type DirectoryID string

// A unique environment identifier.
type EnvironmentID string

// A file identifier.
type FileID string

// The platform config OS and architecture in a Container.
//
// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
type Platform string

// A unique identifier for a secret.
type SecretID string

// A content-addressed socket identifier.
type SocketID string

// Key value object that represents a build argument.
type BuildArg struct {
	// The build argument name.
	Name string `json:"name"`

	// The build argument value.
	Value string `json:"value"`
}

// Key value object that represents a Pipeline label.
type PipelineLabel struct {
	// Label name.
	Name string `json:"name"`

	// Label value.
	Value string `json:"value"`
}

// A directory whose contents persist across runs.
type CacheVolume struct {
	q *querybuilder.Selection
	c graphql.Client

	id *CacheID
}

func (r *CacheVolume) ID(ctx context.Context) (CacheID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response CacheID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *CacheVolume) XXX_GraphQLType() string {
	return "CacheVolume"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *CacheVolume) XXX_GraphQLIDType() string {
	return "CacheID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *CacheVolume) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *CacheVolume) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// An entrypoint for tests, lints or anything that can pass/fail.
type Check struct {
	q *querybuilder.Selection
	c graphql.Client

	description *string
	id          *CheckID
	name        *string
}
type WithCheckFunc func(r *Check) *Check

// With calls the provided function with current Check.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Check) With(f WithCheckFunc) *Check {
	return f(r)
}

// Documentation for this check.
func (r *Check) Description(ctx context.Context) (string, error) {

	if r.description != nil {
		return *r.description, nil
	}
	q := r.q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A unique identifier for this check.
func (r *Check) ID(ctx context.Context) (CheckID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response CheckID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Check) XXX_GraphQLType() string {
	return "Check"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Check) XXX_GraphQLIDType() string {
	return "CheckID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Check) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Check) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// The name of the check.
func (r *Check) Name(ctx context.Context) (string, error) {

	if r.name != nil {
		return *r.name, nil
	}
	q := r.q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The result of evaluating this check.
func (r *Check) Result() *CheckResult {

	q := r.q.Select("result")

	return &CheckResult{
		q: q,
		c: r.c,
	}
}

// The subchecks of this check.
func (r *Check) Subchecks(ctx context.Context) ([]Check, error) {

	q := r.q.Select("subchecks")

	q = q.Select("id")

	type subchecks struct {
		Id CheckID
	}

	convert := func(fields []subchecks) []Check {
		out := []Check{}

		for i := range fields {
			out = append(out, Check{id: &fields[i].Id})
		}

		return out
	}
	var response []subchecks

	q = q.Bind(&response)

	err := q.Execute(ctx, r.c)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// This check with the given container used to determine the check's result.
// If set, the container will be executed and the check success will be true
// if the container exits with a zero exit code, false otherwise.
func (r *Check) WithContainer(id *Container) *Check {

	q := r.q.Select("withContainer")
	q = q.Arg("id", id)

	return &Check{
		q: q,
		c: r.c,
	}
}

// This check with the given description
func (r *Check) WithDescription(description string) *Check {

	q := r.q.Select("withDescription")
	q = q.Arg("description", description)

	return &Check{
		q: q,
		c: r.c,
	}
}

// This check with the given name
func (r *Check) WithName(name string) *Check {

	q := r.q.Select("withName")
	q = q.Arg("name", name)

	return &Check{
		q: q,
		c: r.c,
	}
}

// This check with the given subcheck
func (r *Check) WithSubcheck(id *Check) *Check {

	q := r.q.Select("withSubcheck")
	q = q.Arg("id", id)

	return &Check{
		q: q,
		c: r.c,
	}
}

type CheckResult struct {
	q *querybuilder.Selection
	c graphql.Client

	id      *CheckResultID
	output  *string
	success *bool
}

// A unique identifier for this check result.
func (r *CheckResult) ID(ctx context.Context) (CheckResultID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response CheckResultID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *CheckResult) XXX_GraphQLType() string {
	return "CheckResult"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *CheckResult) XXX_GraphQLIDType() string {
	return "CheckResultID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *CheckResult) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *CheckResult) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// Any output obtained from evaluating the check's success.
func (r *CheckResult) Output(ctx context.Context) (string, error) {

	if r.output != nil {
		return *r.output, nil
	}
	q := r.q.Select("output")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Whether the check was successful.
func (r *CheckResult) Success(ctx context.Context) (bool, error) {

	if r.success != nil {
		return *r.success, nil
	}
	q := r.q.Select("success")

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// An OCI-compatible container, also known as a docker container.
type Container struct {
	q *querybuilder.Selection
	c graphql.Client

	endpoint    *string
	envVariable *string
	export      *bool
	hostname    *string
	id          *ContainerID
	imageRef    *string
	label       *string
	platform    *Platform
	publish     *string
	stderr      *string
	stdout      *string
	sync        *ContainerID
	user        *string
	workdir     *string
}
type WithContainerFunc func(r *Container) *Container

// With calls the provided function with current Container.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Container) With(f WithContainerFunc) *Container {
	return f(r)
}

// ContainerBuildOpts contains options for Container.Build
type ContainerBuildOpts struct {
	// Path to the Dockerfile to use.
	//
	// Default: './Dockerfile'.
	Dockerfile string
	// Additional build arguments.
	BuildArgs []BuildArg
	// Target build stage to build.
	Target string
	// Secrets to pass to the build.
	//
	// They will be mounted at /run/secrets/[secret-name] in the build container
	//
	// They can be accessed in the Dockerfile using the "secret" mount type
	// and mount path /run/secrets/[secret-name]
	// e.g. RUN --mount=type=secret,id=my-secret curl url?token=$(cat /run/secrets/my-secret)"
	Secrets []*Secret
}

// Initializes this container from a Dockerfile build.
func (r *Container) Build(context *Directory, opts ...ContainerBuildOpts) *Container {

	q := r.q.Select("build")
	for i := len(opts) - 1; i >= 0; i-- {
		// `dockerfile` optional argument
		if !querybuilder.IsZeroValue(opts[i].Dockerfile) {
			q = q.Arg("dockerfile", opts[i].Dockerfile)
		}
		// `buildArgs` optional argument
		if !querybuilder.IsZeroValue(opts[i].BuildArgs) {
			q = q.Arg("buildArgs", opts[i].BuildArgs)
		}
		// `target` optional argument
		if !querybuilder.IsZeroValue(opts[i].Target) {
			q = q.Arg("target", opts[i].Target)
		}
		// `secrets` optional argument
		if !querybuilder.IsZeroValue(opts[i].Secrets) {
			q = q.Arg("secrets", opts[i].Secrets)
		}
	}
	q = q.Arg("context", context)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves default arguments for future commands.
func (r *Container) DefaultArgs(ctx context.Context) ([]string, error) {

	q := r.q.Select("defaultArgs")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves a directory at the given path.
//
// Mounts are included.
func (r *Container) Directory(path string) *Directory {

	q := r.q.Select("directory")
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// ContainerEndpointOpts contains options for Container.Endpoint
type ContainerEndpointOpts struct {
	// The exposed port number for the endpoint
	Port int
	// Return a URL with the given scheme, eg. http for http://
	Scheme string
}

// Retrieves an endpoint that clients can use to reach this container.
//
// If no port is specified, the first exposed port is used. If none exist an error is returned.
//
// If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) Endpoint(ctx context.Context, opts ...ContainerEndpointOpts) (string, error) {

	if r.endpoint != nil {
		return *r.endpoint, nil
	}
	q := r.q.Select("endpoint")
	for i := len(opts) - 1; i >= 0; i-- {
		// `port` optional argument
		if !querybuilder.IsZeroValue(opts[i].Port) {
			q = q.Arg("port", opts[i].Port)
		}
		// `scheme` optional argument
		if !querybuilder.IsZeroValue(opts[i].Scheme) {
			q = q.Arg("scheme", opts[i].Scheme)
		}
	}

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves entrypoint to be prepended to the arguments of all commands.
func (r *Container) Entrypoint(ctx context.Context) ([]string, error) {

	q := r.q.Select("entrypoint")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves the value of the specified environment variable.
func (r *Container) EnvVariable(ctx context.Context, name string) (string, error) {

	if r.envVariable != nil {
		return *r.envVariable, nil
	}
	q := r.q.Select("envVariable")
	q = q.Arg("name", name)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves the list of environment variables passed to commands.
func (r *Container) EnvVariables(ctx context.Context) ([]EnvVariable, error) {

	q := r.q.Select("envVariables")

	q = q.Select("name value")

	type envVariables struct {
		Name  string
		Value string
	}

	convert := func(fields []envVariables) []EnvVariable {
		out := []EnvVariable{}

		for i := range fields {
			out = append(out, EnvVariable{name: &fields[i].Name, value: &fields[i].Value})
		}

		return out
	}
	var response []envVariables

	q = q.Bind(&response)

	err := q.Execute(ctx, r.c)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// ContainerExportOpts contains options for Container.Export
type ContainerExportOpts struct {
	// Identifiers for other platform specific containers.
	// Used for multi-platform image.
	PlatformVariants []*Container
	// Force each layer of the exported image to use the specified compression algorithm.
	// If this is unset, then if a layer already has a compressed blob in the engine's
	// cache, that will be used (this can result in a mix of compression algorithms for
	// different layers). If this is unset and a layer has no compressed blob in the
	// engine's cache, then it will be compressed using Gzip.
	ForcedCompression ImageLayerCompression
	// Use the specified media types for the exported image's layers. Defaults to OCI, which
	// is largely compatible with most recent container runtimes, but Docker may be needed
	// for older runtimes without OCI support.
	MediaTypes ImageMediaTypes
}

// Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.
//
// Return true on success.
// It can also publishes platform variants.
func (r *Container) Export(ctx context.Context, path string, opts ...ContainerExportOpts) (bool, error) {

	if r.export != nil {
		return *r.export, nil
	}
	q := r.q.Select("export")
	for i := len(opts) - 1; i >= 0; i-- {
		// `platformVariants` optional argument
		if !querybuilder.IsZeroValue(opts[i].PlatformVariants) {
			q = q.Arg("platformVariants", opts[i].PlatformVariants)
		}
		// `forcedCompression` optional argument
		if !querybuilder.IsZeroValue(opts[i].ForcedCompression) {
			q = q.Arg("forcedCompression", opts[i].ForcedCompression)
		}
		// `mediaTypes` optional argument
		if !querybuilder.IsZeroValue(opts[i].MediaTypes) {
			q = q.Arg("mediaTypes", opts[i].MediaTypes)
		}
	}
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves the list of exposed ports.
//
// This includes ports already exposed by the image, even if not
// explicitly added with dagger.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) ExposedPorts(ctx context.Context) ([]Port, error) {

	q := r.q.Select("exposedPorts")

	q = q.Select("description port protocol")

	type exposedPorts struct {
		Description string
		Port        int
		Protocol    NetworkProtocol
	}

	convert := func(fields []exposedPorts) []Port {
		out := []Port{}

		for i := range fields {
			out = append(out, Port{description: &fields[i].Description, port: &fields[i].Port, protocol: &fields[i].Protocol})
		}

		return out
	}
	var response []exposedPorts

	q = q.Bind(&response)

	err := q.Execute(ctx, r.c)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// Retrieves a file at the given path.
//
// Mounts are included.
func (r *Container) File(path string) *File {

	q := r.q.Select("file")
	q = q.Arg("path", path)

	return &File{
		q: q,
		c: r.c,
	}
}

// Initializes this container from a pulled base image.
func (r *Container) From(address string) *Container {

	q := r.q.Select("from")
	q = q.Arg("address", address)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves a hostname which can be used by clients to reach this container.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) Hostname(ctx context.Context) (string, error) {

	if r.hostname != nil {
		return *r.hostname, nil
	}
	q := r.q.Select("hostname")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A unique identifier for this container.
func (r *Container) ID(ctx context.Context) (ContainerID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response ContainerID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Container) XXX_GraphQLType() string {
	return "Container"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Container) XXX_GraphQLIDType() string {
	return "ContainerID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Container) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Container) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// The unique image reference which can only be retrieved immediately after the 'Container.From' call.
func (r *Container) ImageRef(ctx context.Context) (string, error) {

	if r.imageRef != nil {
		return *r.imageRef, nil
	}
	q := r.q.Select("imageRef")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// ContainerImportOpts contains options for Container.Import
type ContainerImportOpts struct {
	// Identifies the tag to import from the archive, if the archive bundles
	// multiple tags.
	Tag string
}

// Reads the container from an OCI tarball.
//
// NOTE: this involves unpacking the tarball to an OCI store on the host at
// $XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.
func (r *Container) Import(source *File, opts ...ContainerImportOpts) *Container {

	q := r.q.Select("import")
	for i := len(opts) - 1; i >= 0; i-- {
		// `tag` optional argument
		if !querybuilder.IsZeroValue(opts[i].Tag) {
			q = q.Arg("tag", opts[i].Tag)
		}
	}
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves the value of the specified label.
func (r *Container) Label(ctx context.Context, name string) (string, error) {

	if r.label != nil {
		return *r.label, nil
	}
	q := r.q.Select("label")
	q = q.Arg("name", name)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves the list of labels passed to container.
func (r *Container) Labels(ctx context.Context) ([]Label, error) {

	q := r.q.Select("labels")

	q = q.Select("name value")

	type labels struct {
		Name  string
		Value string
	}

	convert := func(fields []labels) []Label {
		out := []Label{}

		for i := range fields {
			out = append(out, Label{name: &fields[i].Name, value: &fields[i].Value})
		}

		return out
	}
	var response []labels

	q = q.Bind(&response)

	err := q.Execute(ctx, r.c)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// Retrieves the list of paths where a directory is mounted.
func (r *Container) Mounts(ctx context.Context) ([]string, error) {

	q := r.q.Select("mounts")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// ContainerPipelineOpts contains options for Container.Pipeline
type ContainerPipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline
func (r *Container) Pipeline(name string, opts ...ContainerPipelineOpts) *Container {

	q := r.q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &Container{
		q: q,
		c: r.c,
	}
}

// The platform this container executes and publishes as.
func (r *Container) Platform(ctx context.Context) (Platform, error) {

	if r.platform != nil {
		return *r.platform, nil
	}
	q := r.q.Select("platform")

	var response Platform

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// ContainerPublishOpts contains options for Container.Publish
type ContainerPublishOpts struct {
	// Identifiers for other platform specific containers.
	// Used for multi-platform image.
	PlatformVariants []*Container
	// Force each layer of the published image to use the specified compression algorithm.
	// If this is unset, then if a layer already has a compressed blob in the engine's
	// cache, that will be used (this can result in a mix of compression algorithms for
	// different layers). If this is unset and a layer has no compressed blob in the
	// engine's cache, then it will be compressed using Gzip.
	ForcedCompression ImageLayerCompression
	// Use the specified media types for the published image's layers. Defaults to OCI, which
	// is largely compatible with most recent registries, but Docker may be needed for older
	// registries without OCI support.
	MediaTypes ImageMediaTypes
}

// Publishes this container as a new image to the specified address.
//
// Publish returns a fully qualified ref.
// It can also publish platform variants.
func (r *Container) Publish(ctx context.Context, address string, opts ...ContainerPublishOpts) (string, error) {

	if r.publish != nil {
		return *r.publish, nil
	}
	q := r.q.Select("publish")
	for i := len(opts) - 1; i >= 0; i-- {
		// `platformVariants` optional argument
		if !querybuilder.IsZeroValue(opts[i].PlatformVariants) {
			q = q.Arg("platformVariants", opts[i].PlatformVariants)
		}
		// `forcedCompression` optional argument
		if !querybuilder.IsZeroValue(opts[i].ForcedCompression) {
			q = q.Arg("forcedCompression", opts[i].ForcedCompression)
		}
		// `mediaTypes` optional argument
		if !querybuilder.IsZeroValue(opts[i].MediaTypes) {
			q = q.Arg("mediaTypes", opts[i].MediaTypes)
		}
	}
	q = q.Arg("address", address)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves this container's root filesystem. Mounts are not included.
func (r *Container) Rootfs() *Directory {

	q := r.q.Select("rootfs")

	return &Directory{
		q: q,
		c: r.c,
	}
}

// The error stream of the last executed command.
//
// Will execute default command if none is set, or error if there's no default.
func (r *Container) Stderr(ctx context.Context) (string, error) {

	if r.stderr != nil {
		return *r.stderr, nil
	}
	q := r.q.Select("stderr")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The output stream of the last executed command.
//
// Will execute default command if none is set, or error if there's no default.
func (r *Container) Stdout(ctx context.Context) (string, error) {

	if r.stdout != nil {
		return *r.stdout, nil
	}
	q := r.q.Select("stdout")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Forces evaluation of the pipeline in the engine.
//
// It doesn't run the default command if no exec has been set.
func (r *Container) Sync(ctx context.Context) (*Container, error) {

	q := r.q.Select("sync")

	return r, q.Execute(ctx, r.c)
}

// Retrieves the user to be set for all commands.
func (r *Container) User(ctx context.Context) (string, error) {

	if r.user != nil {
		return *r.user, nil
	}
	q := r.q.Select("user")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// ContainerWithDefaultArgsOpts contains options for Container.WithDefaultArgs
type ContainerWithDefaultArgsOpts struct {
	// Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
	Args []string
}

// Configures default arguments for future commands.
func (r *Container) WithDefaultArgs(opts ...ContainerWithDefaultArgsOpts) *Container {

	q := r.q.Select("withDefaultArgs")
	for i := len(opts) - 1; i >= 0; i-- {
		// `args` optional argument
		if !querybuilder.IsZeroValue(opts[i].Args) {
			q = q.Arg("args", opts[i].Args)
		}
	}

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithDirectoryOpts contains options for Container.WithDirectory
type ContainerWithDirectoryOpts struct {
	// Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
	Exclude []string
	// Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
	Include []string
	// A user:group to set for the directory and its contents.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a directory written at the given path.
func (r *Container) WithDirectory(path string, directory *Directory, opts ...ContainerWithDirectoryOpts) *Container {

	q := r.q.Select("withDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("directory", directory)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container but with a different command entrypoint.
func (r *Container) WithEntrypoint(args []string) *Container {

	q := r.q.Select("withEntrypoint")
	q = q.Arg("args", args)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithEnvVariableOpts contains options for Container.WithEnvVariable
type ContainerWithEnvVariableOpts struct {
	// Replace ${VAR} or $VAR in the value according to the current environment
	// variables defined in the container (e.g., "/opt/bin:$PATH").
	Expand bool
}

// Retrieves this container plus the given environment variable.
func (r *Container) WithEnvVariable(name string, value string, opts ...ContainerWithEnvVariableOpts) *Container {

	q := r.q.Select("withEnvVariable")
	for i := len(opts) - 1; i >= 0; i-- {
		// `expand` optional argument
		if !querybuilder.IsZeroValue(opts[i].Expand) {
			q = q.Arg("expand", opts[i].Expand)
		}
	}
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithExecOpts contains options for Container.WithExec
type ContainerWithExecOpts struct {
	// If the container has an entrypoint, ignore it for args rather than using it to wrap them.
	SkipEntrypoint bool
	// Content to write to the command's standard input before closing (e.g., "Hello world").
	Stdin string
	// Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
	RedirectStdout string
	// Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
	RedirectStderr string
	// Provides dagger access to the executed command.
	//
	// Do not use this option unless you trust the command being executed.
	// The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
	ExperimentalPrivilegedNesting bool
	// Execute the command with all root capabilities. This is similar to running a command
	// with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
	// does not provide any security guarantees when using this option. It should only be used
	// when absolutely necessary and only with trusted commands.
	InsecureRootCapabilities bool
}

// Retrieves this container after executing the specified command inside it.
func (r *Container) WithExec(args []string, opts ...ContainerWithExecOpts) *Container {

	q := r.q.Select("withExec")
	for i := len(opts) - 1; i >= 0; i-- {
		// `skipEntrypoint` optional argument
		if !querybuilder.IsZeroValue(opts[i].SkipEntrypoint) {
			q = q.Arg("skipEntrypoint", opts[i].SkipEntrypoint)
		}
		// `stdin` optional argument
		if !querybuilder.IsZeroValue(opts[i].Stdin) {
			q = q.Arg("stdin", opts[i].Stdin)
		}
		// `redirectStdout` optional argument
		if !querybuilder.IsZeroValue(opts[i].RedirectStdout) {
			q = q.Arg("redirectStdout", opts[i].RedirectStdout)
		}
		// `redirectStderr` optional argument
		if !querybuilder.IsZeroValue(opts[i].RedirectStderr) {
			q = q.Arg("redirectStderr", opts[i].RedirectStderr)
		}
		// `experimentalPrivilegedNesting` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalPrivilegedNesting) {
			q = q.Arg("experimentalPrivilegedNesting", opts[i].ExperimentalPrivilegedNesting)
		}
		// `insecureRootCapabilities` optional argument
		if !querybuilder.IsZeroValue(opts[i].InsecureRootCapabilities) {
			q = q.Arg("insecureRootCapabilities", opts[i].InsecureRootCapabilities)
		}
	}
	q = q.Arg("args", args)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithExposedPortOpts contains options for Container.WithExposedPort
type ContainerWithExposedPortOpts struct {
	// Transport layer network protocol
	Protocol NetworkProtocol
	// Optional port description
	Description string
}

// Expose a network port.
//
// Exposed ports serve two purposes:
//   - For health checks and introspection, when running services
//   - For setting the EXPOSE OCI field when publishing the container
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithExposedPort(port int, opts ...ContainerWithExposedPortOpts) *Container {

	q := r.q.Select("withExposedPort")
	for i := len(opts) - 1; i >= 0; i-- {
		// `protocol` optional argument
		if !querybuilder.IsZeroValue(opts[i].Protocol) {
			q = q.Arg("protocol", opts[i].Protocol)
		}
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("port", port)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithFileOpts contains options for Container.WithFile
type ContainerWithFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
	// A user:group to set for the file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus the contents of the given file copied to the given path.
func (r *Container) WithFile(path string, source *File, opts ...ContainerWithFileOpts) *Container {

	q := r.q.Select("withFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Indicate that subsequent operations should be featured more prominently in
// the UI.
func (r *Container) WithFocus() *Container {

	q := r.q.Select("withFocus")

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container plus the given label.
func (r *Container) WithLabel(name string, value string) *Container {

	q := r.q.Select("withLabel")
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithMountedCacheOpts contains options for Container.WithMountedCache
type ContainerWithMountedCacheOpts struct {
	// Identifier of the directory to use as the cache volume's root.
	Source *Directory
	// Sharing mode of the cache volume.
	Sharing CacheSharingMode
	// A user:group to set for the mounted cache directory.
	//
	// Note that this changes the ownership of the specified mount along with the
	// initial filesystem provided by source (if any). It does not have any effect
	// if/when the cache has already been created.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a cache volume mounted at the given path.
func (r *Container) WithMountedCache(path string, cache *CacheVolume, opts ...ContainerWithMountedCacheOpts) *Container {

	q := r.q.Select("withMountedCache")
	for i := len(opts) - 1; i >= 0; i-- {
		// `source` optional argument
		if !querybuilder.IsZeroValue(opts[i].Source) {
			q = q.Arg("source", opts[i].Source)
		}
		// `sharing` optional argument
		if !querybuilder.IsZeroValue(opts[i].Sharing) {
			q = q.Arg("sharing", opts[i].Sharing)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("cache", cache)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithMountedDirectoryOpts contains options for Container.WithMountedDirectory
type ContainerWithMountedDirectoryOpts struct {
	// A user:group to set for the mounted directory and its contents.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a directory mounted at the given path.
func (r *Container) WithMountedDirectory(path string, source *Directory, opts ...ContainerWithMountedDirectoryOpts) *Container {

	q := r.q.Select("withMountedDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithMountedFileOpts contains options for Container.WithMountedFile
type ContainerWithMountedFileOpts struct {
	// A user or user:group to set for the mounted file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a file mounted at the given path.
func (r *Container) WithMountedFile(path string, source *File, opts ...ContainerWithMountedFileOpts) *Container {

	q := r.q.Select("withMountedFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithMountedSecretOpts contains options for Container.WithMountedSecret
type ContainerWithMountedSecretOpts struct {
	// A user:group to set for the mounted secret.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a secret mounted into a file at the given path.
func (r *Container) WithMountedSecret(path string, source *Secret, opts ...ContainerWithMountedSecretOpts) *Container {

	q := r.q.Select("withMountedSecret")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container plus a temporary directory mounted at the given path.
func (r *Container) WithMountedTemp(path string) *Container {

	q := r.q.Select("withMountedTemp")
	q = q.Arg("path", path)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithNewFileOpts contains options for Container.WithNewFile
type ContainerWithNewFileOpts struct {
	// Content of the file to write (e.g., "Hello world!").
	Contents string
	// Permission given to the written file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
	// A user:group to set for the file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a new file written at the given path.
func (r *Container) WithNewFile(path string, opts ...ContainerWithNewFileOpts) *Container {

	q := r.q.Select("withNewFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `contents` optional argument
		if !querybuilder.IsZeroValue(opts[i].Contents) {
			q = q.Arg("contents", opts[i].Contents)
		}
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container with a registry authentication for a given address.
func (r *Container) WithRegistryAuth(address string, username string, secret *Secret) *Container {

	q := r.q.Select("withRegistryAuth")
	q = q.Arg("address", address)
	q = q.Arg("username", username)
	q = q.Arg("secret", secret)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Initializes this container from this DirectoryID.
func (r *Container) WithRootfs(directory *Directory) *Container {

	q := r.q.Select("withRootfs")
	q = q.Arg("directory", directory)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container plus an env variable containing the given secret.
func (r *Container) WithSecretVariable(name string, secret *Secret) *Container {

	q := r.q.Select("withSecretVariable")
	q = q.Arg("name", name)
	q = q.Arg("secret", secret)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Establish a runtime dependency on a service.
//
// The service will be started automatically when needed and detached when it is
// no longer needed, executing the default command if none is set.
//
// The service will be reachable from the container via the provided hostname alias.
//
// The service dependency will also convey to any files or directories produced by the container.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithServiceBinding(alias string, service *Container) *Container {

	q := r.q.Select("withServiceBinding")
	q = q.Arg("alias", alias)
	q = q.Arg("service", service)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithUnixSocketOpts contains options for Container.WithUnixSocket
type ContainerWithUnixSocketOpts struct {
	// A user:group to set for the mounted socket.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a socket forwarded to the given Unix socket path.
func (r *Container) WithUnixSocket(path string, source *Socket, opts ...ContainerWithUnixSocketOpts) *Container {

	q := r.q.Select("withUnixSocket")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container with a different command user.
func (r *Container) WithUser(name string) *Container {

	q := r.q.Select("withUser")
	q = q.Arg("name", name)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container with a different working directory.
func (r *Container) WithWorkdir(path string) *Container {

	q := r.q.Select("withWorkdir")
	q = q.Arg("path", path)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container minus the given environment variable.
func (r *Container) WithoutEnvVariable(name string) *Container {

	q := r.q.Select("withoutEnvVariable")
	q = q.Arg("name", name)

	return &Container{
		q: q,
		c: r.c,
	}
}

// ContainerWithoutExposedPortOpts contains options for Container.WithoutExposedPort
type ContainerWithoutExposedPortOpts struct {
	// Port protocol to unexpose
	Protocol NetworkProtocol
}

// Unexpose a previously exposed port.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithoutExposedPort(port int, opts ...ContainerWithoutExposedPortOpts) *Container {

	q := r.q.Select("withoutExposedPort")
	for i := len(opts) - 1; i >= 0; i-- {
		// `protocol` optional argument
		if !querybuilder.IsZeroValue(opts[i].Protocol) {
			q = q.Arg("protocol", opts[i].Protocol)
		}
	}
	q = q.Arg("port", port)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Indicate that subsequent operations should not be featured more prominently
// in the UI.
//
// This is the initial state of all containers.
func (r *Container) WithoutFocus() *Container {

	q := r.q.Select("withoutFocus")

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container minus the given environment label.
func (r *Container) WithoutLabel(name string) *Container {

	q := r.q.Select("withoutLabel")
	q = q.Arg("name", name)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container after unmounting everything at the given path.
func (r *Container) WithoutMount(path string) *Container {

	q := r.q.Select("withoutMount")
	q = q.Arg("path", path)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container without the registry authentication of a given address.
func (r *Container) WithoutRegistryAuth(address string) *Container {

	q := r.q.Select("withoutRegistryAuth")
	q = q.Arg("address", address)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves this container with a previously added Unix socket removed.
func (r *Container) WithoutUnixSocket(path string) *Container {

	q := r.q.Select("withoutUnixSocket")
	q = q.Arg("path", path)

	return &Container{
		q: q,
		c: r.c,
	}
}

// Retrieves the working directory for all commands.
func (r *Container) Workdir(ctx context.Context) (string, error) {

	if r.workdir != nil {
		return *r.workdir, nil
	}
	q := r.q.Select("workdir")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A directory.
type Directory struct {
	q *querybuilder.Selection
	c graphql.Client

	export *bool
	id     *DirectoryID
	sync   *DirectoryID
}
type WithDirectoryFunc func(r *Directory) *Directory

// With calls the provided function with current Directory.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Directory) With(f WithDirectoryFunc) *Directory {
	return f(r)
}

// Gets the difference between this directory and an another directory.
func (r *Directory) Diff(other *Directory) *Directory {

	q := r.q.Select("diff")
	q = q.Arg("other", other)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Retrieves a directory at the given path.
func (r *Directory) Directory(path string) *Directory {

	q := r.q.Select("directory")
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// DirectoryDockerBuildOpts contains options for Directory.DockerBuild
type DirectoryDockerBuildOpts struct {
	// Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
	//
	// Defaults: './Dockerfile'.
	Dockerfile string
	// The platform to build.
	Platform Platform
	// Build arguments to use in the build.
	BuildArgs []BuildArg
	// Target build stage to build.
	Target string
	// Secrets to pass to the build.
	//
	// They will be mounted at /run/secrets/[secret-name].
	Secrets []*Secret
}

// Builds a new Docker container from this directory.
func (r *Directory) DockerBuild(opts ...DirectoryDockerBuildOpts) *Container {

	q := r.q.Select("dockerBuild")
	for i := len(opts) - 1; i >= 0; i-- {
		// `dockerfile` optional argument
		if !querybuilder.IsZeroValue(opts[i].Dockerfile) {
			q = q.Arg("dockerfile", opts[i].Dockerfile)
		}
		// `platform` optional argument
		if !querybuilder.IsZeroValue(opts[i].Platform) {
			q = q.Arg("platform", opts[i].Platform)
		}
		// `buildArgs` optional argument
		if !querybuilder.IsZeroValue(opts[i].BuildArgs) {
			q = q.Arg("buildArgs", opts[i].BuildArgs)
		}
		// `target` optional argument
		if !querybuilder.IsZeroValue(opts[i].Target) {
			q = q.Arg("target", opts[i].Target)
		}
		// `secrets` optional argument
		if !querybuilder.IsZeroValue(opts[i].Secrets) {
			q = q.Arg("secrets", opts[i].Secrets)
		}
	}

	return &Container{
		q: q,
		c: r.c,
	}
}

// DirectoryEntriesOpts contains options for Directory.Entries
type DirectoryEntriesOpts struct {
	// Location of the directory to look at (e.g., "/src").
	Path string
}

// Returns a list of files and directories at the given path.
func (r *Directory) Entries(ctx context.Context, opts ...DirectoryEntriesOpts) ([]string, error) {

	q := r.q.Select("entries")
	for i := len(opts) - 1; i >= 0; i-- {
		// `path` optional argument
		if !querybuilder.IsZeroValue(opts[i].Path) {
			q = q.Arg("path", opts[i].Path)
		}
	}

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Writes the contents of the directory to a path on the host.
func (r *Directory) Export(ctx context.Context, path string) (bool, error) {

	if r.export != nil {
		return *r.export, nil
	}
	q := r.q.Select("export")
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves a file at the given path.
func (r *Directory) File(path string) *File {

	q := r.q.Select("file")
	q = q.Arg("path", path)

	return &File{
		q: q,
		c: r.c,
	}
}

// The content-addressed identifier of the directory.
func (r *Directory) ID(ctx context.Context) (DirectoryID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response DirectoryID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Directory) XXX_GraphQLType() string {
	return "Directory"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Directory) XXX_GraphQLIDType() string {
	return "DirectoryID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Directory) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Directory) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// DirectoryPipelineOpts contains options for Directory.Pipeline
type DirectoryPipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline
func (r *Directory) Pipeline(name string, opts ...DirectoryPipelineOpts) *Directory {

	q := r.q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Force evaluation in the engine.
func (r *Directory) Sync(ctx context.Context) (*Directory, error) {

	q := r.q.Select("sync")

	return r, q.Execute(ctx, r.c)
}

// DirectoryWithDirectoryOpts contains options for Directory.WithDirectory
type DirectoryWithDirectoryOpts struct {
	// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
	Exclude []string
	// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
	Include []string
}

// Retrieves this directory plus a directory written at the given path.
func (r *Directory) WithDirectory(path string, directory *Directory, opts ...DirectoryWithDirectoryOpts) *Directory {

	q := r.q.Select("withDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("directory", directory)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// DirectoryWithFileOpts contains options for Directory.WithFile
type DirectoryWithFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
}

// Retrieves this directory plus the contents of the given file copied to the given path.
func (r *Directory) WithFile(path string, source *File, opts ...DirectoryWithFileOpts) *Directory {

	q := r.q.Select("withFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// DirectoryWithNewDirectoryOpts contains options for Directory.WithNewDirectory
type DirectoryWithNewDirectoryOpts struct {
	// Permission granted to the created directory (e.g., 0777).
	//
	// Default: 0755.
	Permissions int
}

// Retrieves this directory plus a new directory created at the given path.
func (r *Directory) WithNewDirectory(path string, opts ...DirectoryWithNewDirectoryOpts) *Directory {

	q := r.q.Select("withNewDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// DirectoryWithNewFileOpts contains options for Directory.WithNewFile
type DirectoryWithNewFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
}

// Retrieves this directory plus a new file written at the given path.
func (r *Directory) WithNewFile(path string, contents string, opts ...DirectoryWithNewFileOpts) *Directory {

	q := r.q.Select("withNewFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("contents", contents)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Retrieves this directory with all file/dir timestamps set to the given time.
func (r *Directory) WithTimestamps(timestamp int) *Directory {

	q := r.q.Select("withTimestamps")
	q = q.Arg("timestamp", timestamp)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Retrieves this directory with the directory at the given path removed.
func (r *Directory) WithoutDirectory(path string) *Directory {

	q := r.q.Select("withoutDirectory")
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Retrieves this directory with the file at the given path removed.
func (r *Directory) WithoutFile(path string) *Directory {

	q := r.q.Select("withoutFile")
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// A simple key value object that represents an environment variable.
type EnvVariable struct {
	q *querybuilder.Selection
	c graphql.Client

	name  *string
	value *string
}

// The environment variable name.
func (r *EnvVariable) Name(ctx context.Context) (string, error) {

	if r.name != nil {
		return *r.name, nil
	}
	q := r.q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The environment variable value.
func (r *EnvVariable) Value(ctx context.Context) (string, error) {

	if r.value != nil {
		return *r.value, nil
	}
	q := r.q.Select("value")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A group of Dagger entrypoints that can be queried and/or invoked.
type Environment struct {
	q *querybuilder.Selection
	c graphql.Client

	id      *EnvironmentID
	name    *string
	workdir *DirectoryID
}
type WithEnvironmentFunc func(r *Environment) *Environment

// With calls the provided function with current Environment.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Environment) With(f WithEnvironmentFunc) *Environment {
	return f(r)
}

// The check in this environment with the given name, if any
func (r *Environment) Check(name string) *Check {

	q := r.q.Select("check")
	q = q.Arg("name", name)

	return &Check{
		q: q,
		c: r.c,
	}
}

// The list of checks in this environment
func (r *Environment) Checks(ctx context.Context) ([]Check, error) {

	q := r.q.Select("checks")

	q = q.Select("id")

	type checks struct {
		Id CheckID
	}

	convert := func(fields []checks) []Check {
		out := []Check{}

		for i := range fields {
			out = append(out, Check{id: &fields[i].Id})
		}

		return out
	}
	var response []checks

	q = q.Bind(&response)

	err := q.Execute(ctx, r.c)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// A unique identifier for this environment.
func (r *Environment) ID(ctx context.Context) (EnvironmentID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response EnvironmentID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Environment) XXX_GraphQLType() string {
	return "Environment"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Environment) XXX_GraphQLIDType() string {
	return "EnvironmentID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Environment) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Environment) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// Initialize this environment from its source. The full context needed to execute
// the environment is provided as environmentDirectory, with the environment's configuration
// file located at configPath.
func (r *Environment) Load(environmentDirectory *Directory, configPath string) *Environment {

	q := r.q.Select("load")
	q = q.Arg("environmentDirectory", environmentDirectory)
	q = q.Arg("configPath", configPath)

	return &Environment{
		q: q,
		c: r.c,
	}
}

// Name of the environment
func (r *Environment) Name(ctx context.Context) (string, error) {

	if r.name != nil {
		return *r.name, nil
	}
	q := r.q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// This environment plus the given check
func (r *Environment) WithCheck(id any) *Environment {
	res := WithCheck(r, id)
	if res != nil {
		return res
	}

	q := r.q.Select("withCheck")
	q = q.Arg("id", id)

	return &Environment{
		q: q,
		c: r.c,
	}
}

// This environment with the given workdir
func (r *Environment) WithWorkdir(workdir *Directory) *Environment {

	q := r.q.Select("withWorkdir")
	q = q.Arg("workdir", workdir)

	return &Environment{
		q: q,
		c: r.c,
	}
}

// The directory the environment code will execute in as its current working directory.
func (r *Environment) Workdir(ctx context.Context) (DirectoryID, error) {

	if r.workdir != nil {
		return *r.workdir, nil
	}
	q := r.q.Select("workdir")

	var response DirectoryID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A file.
type File struct {
	q *querybuilder.Selection
	c graphql.Client

	contents *string
	export   *bool
	id       *FileID
	size     *int
	sync     *FileID
}
type WithFileFunc func(r *File) *File

// With calls the provided function with current File.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *File) With(f WithFileFunc) *File {
	return f(r)
}

// Retrieves the contents of the file.
func (r *File) Contents(ctx context.Context) (string, error) {

	if r.contents != nil {
		return *r.contents, nil
	}
	q := r.q.Select("contents")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// FileExportOpts contains options for File.Export
type FileExportOpts struct {
	// If allowParentDirPath is true, the path argument can be a directory path, in which case
	// the file will be created in that directory.
	AllowParentDirPath bool
}

// Writes the file to a file path on the host.
func (r *File) Export(ctx context.Context, path string, opts ...FileExportOpts) (bool, error) {

	if r.export != nil {
		return *r.export, nil
	}
	q := r.q.Select("export")
	for i := len(opts) - 1; i >= 0; i-- {
		// `allowParentDirPath` optional argument
		if !querybuilder.IsZeroValue(opts[i].AllowParentDirPath) {
			q = q.Arg("allowParentDirPath", opts[i].AllowParentDirPath)
		}
	}
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Retrieves the content-addressed identifier of the file.
func (r *File) ID(ctx context.Context) (FileID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response FileID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *File) XXX_GraphQLType() string {
	return "File"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *File) XXX_GraphQLIDType() string {
	return "FileID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *File) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *File) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// Gets the size of the file, in bytes.
func (r *File) Size(ctx context.Context) (int, error) {

	if r.size != nil {
		return *r.size, nil
	}
	q := r.q.Select("size")

	var response int

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// Force evaluation in the engine.
func (r *File) Sync(ctx context.Context) (*File, error) {

	q := r.q.Select("sync")

	return r, q.Execute(ctx, r.c)
}

// Retrieves this file with its created/modified timestamps set to the given time.
func (r *File) WithTimestamps(timestamp int) *File {

	q := r.q.Select("withTimestamps")
	q = q.Arg("timestamp", timestamp)

	return &File{
		q: q,
		c: r.c,
	}
}

// A git ref (tag, branch or commit).
type GitRef struct {
	q *querybuilder.Selection
	c graphql.Client
}

// GitRefTreeOpts contains options for GitRef.Tree
type GitRefTreeOpts struct {
	SSHKnownHosts string

	SSHAuthSocket *Socket
}

// The filesystem tree at this ref.
func (r *GitRef) Tree(opts ...GitRefTreeOpts) *Directory {

	q := r.q.Select("tree")
	for i := len(opts) - 1; i >= 0; i-- {
		// `sshKnownHosts` optional argument
		if !querybuilder.IsZeroValue(opts[i].SSHKnownHosts) {
			q = q.Arg("sshKnownHosts", opts[i].SSHKnownHosts)
		}
		// `sshAuthSocket` optional argument
		if !querybuilder.IsZeroValue(opts[i].SSHAuthSocket) {
			q = q.Arg("sshAuthSocket", opts[i].SSHAuthSocket)
		}
	}

	return &Directory{
		q: q,
		c: r.c,
	}
}

// A git repository.
type GitRepository struct {
	q *querybuilder.Selection
	c graphql.Client
}

// Returns details on one branch.
func (r *GitRepository) Branch(name string) *GitRef {

	q := r.q.Select("branch")
	q = q.Arg("name", name)

	return &GitRef{
		q: q,
		c: r.c,
	}
}

// Returns details on one commit.
func (r *GitRepository) Commit(id string) *GitRef {

	q := r.q.Select("commit")
	q = q.Arg("id", id)

	return &GitRef{
		q: q,
		c: r.c,
	}
}

// Returns details on one tag.
func (r *GitRepository) Tag(name string) *GitRef {

	q := r.q.Select("tag")
	q = q.Arg("name", name)

	return &GitRef{
		q: q,
		c: r.c,
	}
}

// Information about the host execution environment.
type Host struct {
	q *querybuilder.Selection
	c graphql.Client
}

// HostDirectoryOpts contains options for Host.Directory
type HostDirectoryOpts struct {
	// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
	Exclude []string
	// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
	Include []string
}

// Accesses a directory on the host.
func (r *Host) Directory(path string, opts ...HostDirectoryOpts) *Directory {

	q := r.q.Select("directory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
	}
	q = q.Arg("path", path)

	return &Directory{
		q: q,
		c: r.c,
	}
}

// Accesses a file on the host.
func (r *Host) File(path string) *File {

	q := r.q.Select("file")
	q = q.Arg("path", path)

	return &File{
		q: q,
		c: r.c,
	}
}

// Sets a secret given a user-defined name and the file path on the host, and returns the secret.
// The file is limited to a size of 512000 bytes.
func (r *Host) SetSecretFile(name string, path string) *Secret {

	q := r.q.Select("setSecretFile")
	q = q.Arg("name", name)
	q = q.Arg("path", path)

	return &Secret{
		q: q,
		c: r.c,
	}
}

// Accesses a Unix socket on the host.
func (r *Host) UnixSocket(path string) *Socket {

	q := r.q.Select("unixSocket")
	q = q.Arg("path", path)

	return &Socket{
		q: q,
		c: r.c,
	}
}

// A simple key value object that represents a label.
type Label struct {
	q *querybuilder.Selection
	c graphql.Client

	name  *string
	value *string
}

// The label name.
func (r *Label) Name(ctx context.Context) (string, error) {

	if r.name != nil {
		return *r.name, nil
	}
	q := r.q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The label value.
func (r *Label) Value(ctx context.Context) (string, error) {

	if r.value != nil {
		return *r.value, nil
	}
	q := r.q.Select("value")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// A port exposed by a container.
type Port struct {
	q *querybuilder.Selection
	c graphql.Client

	description *string
	port        *int
	protocol    *NetworkProtocol
}

// The port description.
func (r *Port) Description(ctx context.Context) (string, error) {

	if r.description != nil {
		return *r.description, nil
	}
	q := r.q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The port number.
func (r *Port) Port(ctx context.Context) (int, error) {

	if r.port != nil {
		return *r.port, nil
	}
	q := r.q.Select("port")

	var response int

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// The transport layer network protocol.
func (r *Port) Protocol(ctx context.Context) (NetworkProtocol, error) {

	if r.protocol != nil {
		return *r.protocol, nil
	}
	q := r.q.Select("protocol")

	var response NetworkProtocol

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

type WithDAGFunc func(r *DAG) *DAG

// With calls the provided function with current DAG.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *DAG) With(f WithDAGFunc) *DAG {
	return f(r)
}

// Constructs a cache volume for a given cache key.
func (r *DAG) CacheVolume(key string) *CacheVolume {

	q := r.q.Select("cacheVolume")
	q = q.Arg("key", key)

	return &CacheVolume{
		q: q,
		c: r.c,
	}
}

// CheckOpts contains options for DAG.Check
type CheckOpts struct {
	ID CheckID
}

// Load a environment check from ID.
func (r *DAG) Check(opts ...CheckOpts) *Check {

	q := r.q.Select("check")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Check{
		q: q,
		c: r.c,
	}
}

// CheckResultOpts contains options for DAG.CheckResult
type CheckResultOpts struct {
	ID CheckResultID
}

// Load a environment check result from ID.
func (r *DAG) CheckResult(opts ...CheckResultOpts) *CheckResult {

	q := r.q.Select("checkResult")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &CheckResult{
		q: q,
		c: r.c,
	}
}

// Checks if the current Dagger Engine is compatible with an SDK's required version.
func (r *DAG) CheckVersionCompatibility(ctx context.Context, version string) (bool, error) {

	q := r.q.Select("checkVersionCompatibility")
	q = q.Arg("version", version)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// ContainerOpts contains options for DAG.Container
type ContainerOpts struct {
	ID ContainerID

	Platform Platform
}

// Loads a container from ID.
//
// Null ID returns an empty container (scratch).
// Optional platform argument initializes new containers to execute and publish as that platform.
// Platform defaults to that of the builder's host.
func (r *DAG) Container(opts ...ContainerOpts) *Container {

	q := r.q.Select("container")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
		// `platform` optional argument
		if !querybuilder.IsZeroValue(opts[i].Platform) {
			q = q.Arg("platform", opts[i].Platform)
		}
	}

	return &Container{
		q: q,
		c: r.c,
	}
}

// Return the current environment being executed in.
func (r *DAG) CurrentEnvironment() *Environment {

	q := r.q.Select("currentEnvironment")

	return &Environment{
		q: q,
		c: r.c,
	}
}

// The default platform of the builder.
func (r *DAG) DefaultPlatform(ctx context.Context) (Platform, error) {

	q := r.q.Select("defaultPlatform")

	var response Platform

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// DirectoryOpts contains options for DAG.Directory
type DirectoryOpts struct {
	ID DirectoryID
}

// Load a directory by ID. No argument produces an empty directory.
func (r *DAG) Directory(opts ...DirectoryOpts) *Directory {

	q := r.q.Select("directory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Directory{
		q: q,
		c: r.c,
	}
}

// EnvironmentOpts contains options for DAG.Environment
type EnvironmentOpts struct {
	ID EnvironmentID
}

// Load a environment from ID.
func (r *DAG) Environment(opts ...EnvironmentOpts) *Environment {

	q := r.q.Select("environment")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Environment{
		q: q,
		c: r.c,
	}
}

// Loads a file by ID.
func (r *DAG) File(id FileID) *File {

	q := r.q.Select("file")
	q = q.Arg("id", id)

	return &File{
		q: q,
		c: r.c,
	}
}

// GitOpts contains options for DAG.Git
type GitOpts struct {
	// Set to true to keep .git directory.
	KeepGitDir bool
	// A service which must be started before the repo is fetched.
	ExperimentalServiceHost *Container
}

// Queries a git repository.
func (r *DAG) Git(url string, opts ...GitOpts) *GitRepository {

	q := r.q.Select("git")
	for i := len(opts) - 1; i >= 0; i-- {
		// `keepGitDir` optional argument
		if !querybuilder.IsZeroValue(opts[i].KeepGitDir) {
			q = q.Arg("keepGitDir", opts[i].KeepGitDir)
		}
		// `experimentalServiceHost` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalServiceHost) {
			q = q.Arg("experimentalServiceHost", opts[i].ExperimentalServiceHost)
		}
	}
	q = q.Arg("url", url)

	return &GitRepository{
		q: q,
		c: r.c,
	}
}

// Queries the host environment.
func (r *DAG) Host() *Host {

	q := r.q.Select("host")

	return &Host{
		q: q,
		c: r.c,
	}
}

// HTTPOpts contains options for DAG.HTTP
type HTTPOpts struct {
	// A service which must be started before the URL is fetched.
	ExperimentalServiceHost *Container
}

// Returns a file containing an http remote url content.
func (r *DAG) HTTP(url string, opts ...HTTPOpts) *File {

	q := r.q.Select("http")
	for i := len(opts) - 1; i >= 0; i-- {
		// `experimentalServiceHost` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalServiceHost) {
			q = q.Arg("experimentalServiceHost", opts[i].ExperimentalServiceHost)
		}
	}
	q = q.Arg("url", url)

	return &File{
		q: q,
		c: r.c,
	}
}

// PipelineOpts contains options for DAG.Pipeline
type PipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline.
func (r *DAG) Pipeline(name string, opts ...PipelineOpts) *DAG {

	q := r.q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &DAG{
		q: q,
		c: r.c,
	}
}

// Loads a secret from its ID.
func (r *DAG) Secret(id SecretID) *Secret {

	q := r.q.Select("secret")
	q = q.Arg("id", id)

	return &Secret{
		q: q,
		c: r.c,
	}
}

// Sets a secret given a user defined name to its plaintext and returns the secret.
// The plaintext value is limited to a size of 128000 bytes.
func (r *DAG) SetSecret(name string, plaintext string) *Secret {

	q := r.q.Select("setSecret")
	q = q.Arg("name", name)
	q = q.Arg("plaintext", plaintext)

	return &Secret{
		q: q,
		c: r.c,
	}
}

// SocketOpts contains options for DAG.Socket
type SocketOpts struct {
	ID SocketID
}

// Loads a socket by its ID.
func (r *DAG) Socket(opts ...SocketOpts) *Socket {

	q := r.q.Select("socket")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Socket{
		q: q,
		c: r.c,
	}
}

// StaticCheckResultOpts contains options for DAG.StaticCheckResult
type StaticCheckResultOpts struct {
	Output string
}

// Create a check result with the given success and output.
func (r *DAG) StaticCheckResult(success bool, opts ...StaticCheckResultOpts) *CheckResult {

	q := r.q.Select("staticCheckResult")
	for i := len(opts) - 1; i >= 0; i-- {
		// `output` optional argument
		if !querybuilder.IsZeroValue(opts[i].Output) {
			q = q.Arg("output", opts[i].Output)
		}
	}
	q = q.Arg("success", success)

	return &CheckResult{
		q: q,
		c: r.c,
	}
}

// A reference to a secret value, which can be handled more safely than the value itself.
type Secret struct {
	q *querybuilder.Selection
	c graphql.Client

	id        *SecretID
	plaintext *string
}

// The identifier for this secret.
func (r *Secret) ID(ctx context.Context) (SecretID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response SecretID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Secret) XXX_GraphQLType() string {
	return "Secret"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Secret) XXX_GraphQLIDType() string {
	return "SecretID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Secret) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Secret) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

// The value of this secret.
func (r *Secret) Plaintext(ctx context.Context) (string, error) {

	if r.plaintext != nil {
		return *r.plaintext, nil
	}
	q := r.q.Select("plaintext")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

type Socket struct {
	q *querybuilder.Selection
	c graphql.Client

	id *SocketID
}

// The content-addressed identifier of the socket.
func (r *Socket) ID(ctx context.Context) (SocketID, error) {

	if r.id != nil {
		return *r.id, nil
	}
	q := r.q.Select("id")

	var response SocketID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.c)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Socket) XXX_GraphQLType() string {
	return "Socket"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Socket) XXX_GraphQLIDType() string {
	return "SocketID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Socket) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *Socket) MarshalJSON() ([]byte, error) {
	id, err := r.ID(context.Background())
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

type CacheSharingMode string

const (
	Locked  CacheSharingMode = "LOCKED"
	Private CacheSharingMode = "PRIVATE"
	Shared  CacheSharingMode = "SHARED"
)

type ImageLayerCompression string

const (
	Estargz      ImageLayerCompression = "EStarGZ"
	Gzip         ImageLayerCompression = "Gzip"
	Uncompressed ImageLayerCompression = "Uncompressed"
	Zstd         ImageLayerCompression = "Zstd"
)

type ImageMediaTypes string

const (
	Dockermediatypes ImageMediaTypes = "DockerMediaTypes"
	Ocimediatypes    ImageMediaTypes = "OCIMediaTypes"
)

type NetworkProtocol string

const (
	Tcp NetworkProtocol = "TCP"
	Udp NetworkProtocol = "UDP"
)
