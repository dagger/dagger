// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/main/internal/dagger"
	"dagger/main/internal/querybuilder"
	"dagger/main/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Test) MarshalJSON() ([]byte, error) {
	var concrete struct {
		IfaceField          any
		Dep                 *dagger.Dep
		IfaceFieldNeverSet  any
		IfacePrivateField   any
		IfaceListField      any
		OtherIfaceListField any
	}
	concrete.IfaceField = r.IfaceField
	concrete.Dep = r.Dep
	concrete.IfaceFieldNeverSet = r.IfaceFieldNeverSet
	concrete.IfacePrivateField = r.IfacePrivateField
	concrete.IfaceListField = r.IfaceListField
	concrete.OtherIfaceListField = r.OtherIfaceListField
	return json.Marshal(&concrete)
}

func (r *Test) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		IfaceField          *customIfaceImpl
		Dep                 *dagger.Dep
		IfaceFieldNeverSet  *customIfaceImpl
		IfacePrivateField   *customIfaceImpl
		IfaceListField      []*customIfaceImpl
		OtherIfaceListField []*otherIfaceImpl
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.IfaceField = concrete.IfaceField.toIface()
	r.Dep = concrete.Dep
	r.IfaceFieldNeverSet = concrete.IfaceFieldNeverSet.toIface()
	r.IfacePrivateField = concrete.IfacePrivateField.toIface()
	r.IfaceListField = convertSlice(concrete.IfaceListField, (*customIfaceImpl).toIface)
	r.OtherIfaceListField = convertSlice(concrete.OtherIfaceListField, (*otherIfaceImpl).toIface)
	return nil
}

type customIfaceImpl struct {
	query *querybuilder.Selection
	id    *CustomIfaceID
	str   *string
	int   *int
	bool  *bool
}

type CustomIfaceID string

func LoadCustomIfaceFromID(r *dagger.Client, id CustomIfaceID) CustomIface {
	q := querybuilder.Query().Client(r.GraphQLClient())
	q = q.Select("loadTestCustomIfaceFromID")
	q = q.Arg("id", id)
	return &customIfaceImpl{query: q}
}

func (r *customIfaceImpl) WithGraphQLQuery(q *querybuilder.Selection) CustomIface {
	return &customIfaceImpl{query: q}
}

func (r *customIfaceImpl) XXX_GraphQLType() string {
	return "CustomIface"
}

func (r *customIfaceImpl) XXX_GraphQLIDType() string {
	return "CustomIfaceID"
}

func (r *customIfaceImpl) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *customIfaceImpl) MarshalJSON() ([]byte, error) {
	if r == nil {
		return []byte("\"\""), nil
	}
	id, err := r.ID(marshalCtx)
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

func (r *customIfaceImpl) UnmarshalJSON(bs []byte) error {
	var id CustomIfaceID
	err := json.Unmarshal(bs, &id)
	if err != nil {
		return err
	}
	*r = *LoadCustomIfaceFromID(dag, id).(*customIfaceImpl)
	return nil
}

func (r *customIfaceImpl) toIface() CustomIface {
	if r == nil {
		return nil
	}
	return r
}

func (r *customIfaceImpl) ID(ctx context.Context) (CustomIfaceID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.query.Select("id")
	var response CustomIfaceID
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) Void(ctx context.Context) error {
	q := r.query.Select("void")
	var response dagger.Void
	q = q.Bind(&response)
	return q.Execute(ctx)
}

func (r *customIfaceImpl) Str(ctx context.Context) (string, error) {
	if r.str != nil {
		return *r.str, nil
	}
	q := r.query.Select("str")
	var response string
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithStr(ctx context.Context, strArg string) CustomIface {
	q := r.query.Select("withStr")
	q = q.Arg("strArg", strArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) WithOptionalPragmaStr(ctx context.Context, strArg string) CustomIface {
	q := r.query.Select("withOptionalPragmaStr")
	q = q.Arg("strArg", strArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) StrList(ctx context.Context) ([]string, error) {
	q := r.query.Select("strList")
	var response []string
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithStrList(ctx context.Context, strListArg []string) CustomIface {
	q := r.query.Select("withStrList")
	q = q.Arg("strListArg", strListArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) Int(ctx context.Context) (int, error) {
	if r.int != nil {
		return *r.int, nil
	}
	q := r.query.Select("int")
	var response int
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithInt(ctx context.Context, intArg int) CustomIface {
	q := r.query.Select("withInt")
	q = q.Arg("intArg", intArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) IntList(ctx context.Context) ([]int, error) {
	q := r.query.Select("intList")
	var response []int
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithIntList(ctx context.Context, intListArg []int) CustomIface {
	q := r.query.Select("withIntList")
	q = q.Arg("intListArg", intListArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) Bool(ctx context.Context) (bool, error) {
	if r.bool != nil {
		return *r.bool, nil
	}
	q := r.query.Select("bool")
	var response bool
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithBool(ctx context.Context, boolArg bool) CustomIface {
	q := r.query.Select("withBool")
	q = q.Arg("boolArg", boolArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) BoolList(ctx context.Context) ([]bool, error) {
	q := r.query.Select("boolList")
	var response []bool
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *customIfaceImpl) WithBoolList(ctx context.Context, boolListArg []bool) CustomIface {
	q := r.query.Select("withBoolList")
	q = q.Arg("boolListArg", boolListArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) Obj() *dagger.Directory {
	q := r.query.Select("obj")
	return (&dagger.Directory{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) WithObj(objArg *dagger.Directory) CustomIface {
	q := r.query.Select("withObj")
	q = q.Arg("objArg", objArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) WithOptionalPragmaObj(objArg *dagger.Directory) CustomIface {
	q := r.query.Select("withOptionalPragmaObj")
	q = q.Arg("objArg", objArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) ObjList(ctx context.Context) ([]*dagger.Directory, error) {
	q := r.query.Select("objList")
	q = q.Select("id")
	var idResults []struct {
		Id dagger.DirectoryID
	}
	q = q.Bind(&idResults)
	err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	var results []*dagger.Directory
	for _, idResult := range idResults {
		id := idResult.Id
		results = append(results, (&dagger.Directory{}).WithGraphQLQuery(r.query.Root().Select("loadDirectoryFromID").Arg("id", id)))
	}
	return results, nil
}

func (r *customIfaceImpl) WithObjList(ctx context.Context, objListArg []*dagger.Directory) CustomIface {
	q := r.query.Select("withObjList")
	q = q.Arg("objListArg", objListArg)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) SelfIface() CustomIface {
	q := r.query.Select("selfIface")
	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) SelfIfaceList(ctx context.Context) ([]CustomIface, error) {
	q := r.query.Select("selfIfaceList")
	q = q.Select("id")
	var idResults []struct {
		Id CustomIfaceID
	}
	q = q.Bind(&idResults)
	err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	var results []CustomIface
	for _, idResult := range idResults {
		id := idResult.Id
		results = append(results, (&customIfaceImpl{}).WithGraphQLQuery(r.query.Root().Select("loadTestCustomIfaceFromID").Arg("id", id)))
	}
	return results, nil
}

func (r *customIfaceImpl) OtherIface() OtherIface {
	q := r.query.Select("otherIface")
	return (&otherIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) StaticOtherIfaceList(ctx context.Context) ([]OtherIface, error) {
	q := r.query.Select("staticOtherIfaceList")
	q = q.Select("id")
	var idResults []struct {
		Id OtherIfaceID
	}
	q = q.Bind(&idResults)
	err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	var results []OtherIface
	for _, idResult := range idResults {
		id := idResult.Id
		results = append(results, (&otherIfaceImpl{}).WithGraphQLQuery(r.query.Root().Select("loadTestOtherIfaceFromID").Arg("id", id)))
	}
	return results, nil
}

func (r *customIfaceImpl) WithOtherIface(other OtherIface) CustomIface {
	q := r.query.Select("withOtherIface")
	q = q.Arg("other", other)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) DynamicOtherIfaceList(ctx context.Context) ([]OtherIface, error) {
	q := r.query.Select("dynamicOtherIfaceList")
	q = q.Select("id")
	var idResults []struct {
		Id OtherIfaceID
	}
	q = q.Bind(&idResults)
	err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	var results []OtherIface
	for _, idResult := range idResults {
		id := idResult.Id
		results = append(results, (&otherIfaceImpl{}).WithGraphQLQuery(r.query.Root().Select("loadTestOtherIfaceFromID").Arg("id", id)))
	}
	return results, nil
}

func (r *customIfaceImpl) WithOtherIfaceByIface(other OtherIface) CustomIface {
	q := r.query.Select("withOtherIfaceByIface")
	q = q.Arg("other", other)

	return (&customIfaceImpl{}).WithGraphQLQuery(q)
}

func (r *customIfaceImpl) DynamicOtherIfaceByIfaceList(ctx context.Context) ([]OtherIface, error) {
	q := r.query.Select("dynamicOtherIfaceByIfaceList")
	q = q.Select("id")
	var idResults []struct {
		Id OtherIfaceID
	}
	q = q.Bind(&idResults)
	err := q.Execute(ctx)
	if err != nil {
		return nil, err
	}
	var results []OtherIface
	for _, idResult := range idResults {
		id := idResult.Id
		results = append(results, (&otherIfaceImpl{}).WithGraphQLQuery(r.query.Root().Select("loadTestOtherIfaceFromID").Arg("id", id)))
	}
	return results, nil
}

type otherIfaceImpl struct {
	query *querybuilder.Selection
	id    *OtherIfaceID
	foo   *string
}

type OtherIfaceID string

func LoadOtherIfaceFromID(r *dagger.Client, id OtherIfaceID) OtherIface {
	q := querybuilder.Query().Client(r.GraphQLClient())
	q = q.Select("loadTestOtherIfaceFromID")
	q = q.Arg("id", id)
	return &otherIfaceImpl{query: q}
}

func (r *otherIfaceImpl) WithGraphQLQuery(q *querybuilder.Selection) OtherIface {
	return &otherIfaceImpl{query: q}
}

func (r *otherIfaceImpl) XXX_GraphQLType() string {
	return "OtherIface"
}

func (r *otherIfaceImpl) XXX_GraphQLIDType() string {
	return "OtherIfaceID"
}

func (r *otherIfaceImpl) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *otherIfaceImpl) MarshalJSON() ([]byte, error) {
	if r == nil {
		return []byte("\"\""), nil
	}
	id, err := r.ID(marshalCtx)
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

func (r *otherIfaceImpl) UnmarshalJSON(bs []byte) error {
	var id OtherIfaceID
	err := json.Unmarshal(bs, &id)
	if err != nil {
		return err
	}
	*r = *LoadOtherIfaceFromID(dag, id).(*otherIfaceImpl)
	return nil
}

func (r *otherIfaceImpl) toIface() OtherIface {
	if r == nil {
		return nil
	}
	return r
}

func (r *otherIfaceImpl) ID(ctx context.Context) (OtherIfaceID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.query.Select("id")
	var response OtherIfaceID
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *otherIfaceImpl) Foo(ctx context.Context) (string, error) {
	if r.foo != nil {
		return *r.foo, nil
	}
	q := r.query.Select("foo")
	var response string
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r CustomObj) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Iface        any
		IfaceList    any
		Other        OtherCustomObj
		OtherPtr     *OtherCustomObj
		OtherList    []OtherCustomObj
		OtherPtrList []*OtherCustomObj
	}
	concrete.Iface = r.Iface
	concrete.IfaceList = r.IfaceList
	concrete.Other = r.Other
	concrete.OtherPtr = r.OtherPtr
	concrete.OtherList = r.OtherList
	concrete.OtherPtrList = r.OtherPtrList
	return json.Marshal(&concrete)
}

func (r *CustomObj) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Iface        *customIfaceImpl
		IfaceList    []*customIfaceImpl
		Other        OtherCustomObj
		OtherPtr     *OtherCustomObj
		OtherList    []OtherCustomObj
		OtherPtrList []*OtherCustomObj
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Iface = concrete.Iface.toIface()
	r.IfaceList = convertSlice(concrete.IfaceList, (*customIfaceImpl).toIface)
	r.Other = concrete.Other
	r.OtherPtr = concrete.OtherPtr
	r.OtherList = concrete.OtherList
	r.OtherPtrList = concrete.OtherPtrList
	return nil
}

func (r OtherCustomObj) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Iface     any
		IfaceList any
	}
	concrete.Iface = r.Iface
	concrete.IfaceList = r.IfaceList
	return json.Marshal(&concrete)
}

func (r *OtherCustomObj) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Iface     *customIfaceImpl
		IfaceList []*customIfaceImpl
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Iface = concrete.Iface.toIface()
	r.IfaceList = convertSlice(concrete.IfaceList, (*customIfaceImpl).toIface)
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Test":
		switch fnName {
		case "Bool":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).Bool(&parent, ctx, ifaceArg.toIface())
		case "BoolList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).BoolList(&parent, ctx, ifaceArg.toIface())
		case "DepIfaceStr":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Test).DepIfaceStr(&parent, ctx)
		case "DepWithIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var iface *customIfaceImpl
			if inputArgs["iface"] != nil {
				err = json.Unmarshal([]byte(inputArgs["iface"]), &iface)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg iface", err))
				}
			}
			return (*Test).DepWithIface(&parent, ctx, iface.toIface())
		case "DynamicOtherIfaceByIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).DynamicOtherIfaceByIfaceList(&parent, ctx, ifaceArg.toIface())
		case "DynamicOtherIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).DynamicOtherIfaceList(&parent, ctx, ifaceArg.toIface())
		case "IfaceListArgs":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaces []*customIfaceImpl
			if inputArgs["ifaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaces"]), &ifaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaces", err))
				}
			}
			var otherIfaces []*otherIfaceImpl
			if inputArgs["otherIfaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["otherIfaces"]), &otherIfaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg otherIfaces", err))
				}
			}
			return (*Test).IfaceListArgs(&parent, ctx, convertSlice(ifaces, (*customIfaceImpl).toIface), convertSlice(otherIfaces, (*otherIfaceImpl).toIface))
		case "Int":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).Int(&parent, ctx, ifaceArg.toIface())
		case "IntList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).IntList(&parent, ctx, ifaceArg.toIface())
		case "Obj":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).Obj(&parent, ifaceArg.toIface()), nil
		case "ObjList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).ObjList(&parent, ctx, ifaceArg.toIface())
		case "OtherIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).OtherIface(&parent, ifaceArg.toIface()), nil
		case "ParentIfaceFields":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Test).ParentIfaceFields(&parent, ctx)
		case "ReturnCustomObj":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaces []*customIfaceImpl
			if inputArgs["ifaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaces"]), &ifaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaces", err))
				}
			}
			var otherIfaces []*otherIfaceImpl
			if inputArgs["otherIfaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["otherIfaces"]), &otherIfaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg otherIfaces", err))
				}
			}
			return (*Test).ReturnCustomObj(&parent, convertSlice(ifaces, (*customIfaceImpl).toIface), convertSlice(otherIfaces, (*otherIfaceImpl).toIface)), nil
		case "SelfIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).SelfIface(&parent, ifaceArg.toIface()), nil
		case "SelfIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).SelfIfaceList(&parent, ctx, ifaceArg.toIface())
		case "StaticOtherIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).StaticOtherIfaceList(&parent, ctx, ifaceArg.toIface())
		case "Str":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).Str(&parent, ctx, ifaceArg.toIface())
		case "StrList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return (*Test).StrList(&parent, ctx, ifaceArg.toIface())
		case "Void":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			return nil, (*Test).Void(&parent, ctx, ifaceArg.toIface())
		case "WithBool":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var boolArg bool
			if inputArgs["boolArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["boolArg"]), &boolArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg boolArg", err))
				}
			}
			return (*Test).WithBool(&parent, ctx, ifaceArg.toIface(), boolArg), nil
		case "WithBoolList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var boolList []bool
			if inputArgs["boolList"] != nil {
				err = json.Unmarshal([]byte(inputArgs["boolList"]), &boolList)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg boolList", err))
				}
			}
			return (*Test).WithBoolList(&parent, ctx, ifaceArg.toIface(), boolList), nil
		case "WithIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var iface *customIfaceImpl
			if inputArgs["iface"] != nil {
				err = json.Unmarshal([]byte(inputArgs["iface"]), &iface)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg iface", err))
				}
			}
			return (*Test).WithIface(&parent, iface.toIface()), nil
		case "WithIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaces []*customIfaceImpl
			if inputArgs["ifaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaces"]), &ifaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaces", err))
				}
			}
			return (*Test).WithIfaceList(&parent, convertSlice(ifaces, (*customIfaceImpl).toIface)), nil
		case "WithInt":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var intArg int
			if inputArgs["intArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["intArg"]), &intArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg intArg", err))
				}
			}
			return (*Test).WithInt(&parent, ctx, ifaceArg.toIface(), intArg), nil
		case "WithIntList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var intList []int
			if inputArgs["intList"] != nil {
				err = json.Unmarshal([]byte(inputArgs["intList"]), &intList)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg intList", err))
				}
			}
			return (*Test).WithIntList(&parent, ctx, ifaceArg.toIface(), intList), nil
		case "WithObj":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var objArg *dagger.Directory
			if inputArgs["objArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["objArg"]), &objArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg objArg", err))
				}
			}
			return (*Test).WithObj(&parent, ifaceArg.toIface(), objArg), nil
		case "WithObjList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var objList []*dagger.Directory
			if inputArgs["objList"] != nil {
				err = json.Unmarshal([]byte(inputArgs["objList"]), &objList)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg objList", err))
				}
			}
			return (*Test).WithObjList(&parent, ctx, ifaceArg.toIface(), objList), nil
		case "WithOptionalPragmaIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var iface *customIfaceImpl
			if inputArgs["iface"] != nil {
				err = json.Unmarshal([]byte(inputArgs["iface"]), &iface)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg iface", err))
				}
			}
			return (*Test).WithOptionalPragmaIface(&parent, iface.toIface()), nil
		case "WithOptionalPragmaObj":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var objArg *dagger.Directory
			if inputArgs["objArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["objArg"]), &objArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg objArg", err))
				}
			}
			return (*Test).WithOptionalPragmaObj(&parent, ifaceArg.toIface(), objArg), nil
		case "WithOptionalPragmaStr":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var strArg string
			if inputArgs["strArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["strArg"]), &strArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg strArg", err))
				}
			}
			return (*Test).WithOptionalPragmaStr(&parent, ctx, ifaceArg.toIface(), strArg), nil
		case "WithOtherIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var other *otherIfaceImpl
			if inputArgs["other"] != nil {
				err = json.Unmarshal([]byte(inputArgs["other"]), &other)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg other", err))
				}
			}
			return (*Test).WithOtherIface(&parent, ctx, ifaceArg.toIface(), other.toIface()), nil
		case "WithOtherIfaceByIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var other *otherIfaceImpl
			if inputArgs["other"] != nil {
				err = json.Unmarshal([]byte(inputArgs["other"]), &other)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg other", err))
				}
			}
			return (*Test).WithOtherIfaceByIface(&parent, ctx, ifaceArg.toIface(), other.toIface()), nil
		case "WithOtherIfaceList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaces []*otherIfaceImpl
			if inputArgs["ifaces"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaces"]), &ifaces)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaces", err))
				}
			}
			return (*Test).WithOtherIfaceList(&parent, convertSlice(ifaces, (*otherIfaceImpl).toIface)), nil
		case "WithPrivateIface":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var iface *customIfaceImpl
			if inputArgs["iface"] != nil {
				err = json.Unmarshal([]byte(inputArgs["iface"]), &iface)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg iface", err))
				}
			}
			return (*Test).WithPrivateIface(&parent, iface.toIface()), nil
		case "WithStr":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var strArg string
			if inputArgs["strArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["strArg"]), &strArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg strArg", err))
				}
			}
			return (*Test).WithStr(&parent, ctx, ifaceArg.toIface(), strArg), nil
		case "WithStrList":
			var parent Test
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var ifaceArg *customIfaceImpl
			if inputArgs["ifaceArg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["ifaceArg"]), &ifaceArg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg ifaceArg", err))
				}
			}
			var strList []string
			if inputArgs["strList"] != nil {
				err = json.Unmarshal([]byte(inputArgs["strList"]), &strList)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg strList", err))
				}
			}
			return (*Test).WithStrList(&parent, ctx, ifaceArg.toIface(), strList), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
