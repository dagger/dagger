package core

import (
	"sync"

	"github.com/dagger/cloak/dagger"
	"github.com/moby/buildkit/client/llb"
)

//
//
//
//
// TODO: actually autogenerate core too from CUE, just handwritten still for now
//
//
//
//

type Image struct {
	Ref string
}

type ImageOutput interface {
	FS() FSOutput
}

var _ ImageOutput = &Image{}

type imageOutput struct {
	FS FSOutput
	// TODO: Config ImageConfig
}

func (i *Image) FS() FSOutput {
	return i.output().FS
}

/* TODO:
func (i *Image) Config() ImageConfig {}
*/

type GitRepo struct {
	Remote string
	Ref    string
}

type GitRepoOutput interface {
	FS() FSOutput
}

var _ GitRepoOutput = &GitRepo{}

type gitRepoOutput struct {
	FS FSOutput
}

func (g *GitRepo) FS() FSOutput {
	return g.output().FS
}

type Exec struct {
	Base   FSOutput
	Dir    string
	Args   []string
	Mounts []Mount
	once   sync.Once
	memo   *execOutput
}

type Mount struct {
	FS   FSOutput
	Path string
}

type ExecOutput interface {
	FS() FSOutput
}

var _ ExecOutput = &Exec{}

type execOutput struct {
	FS     FSOutput
	Mounts map[string]FSOutput
}

func (e *Exec) FS() FSOutput {
	return e.outputOnce().FS
}

func (e *Exec) GetMount(path string) FSOutput {
	return e.outputOnce().Mounts[path]
}

func (e *Exec) outputOnce() *execOutput {
	e.once.Do(func() {
		e.memo = e.output()
	})
	return e.memo
}

//
//
//
//
// AUTOGENERATED STOP
//
//
//
//

// temporarily just an alias for llb.State, in long term probably need more thorough wrapping type to
// fully hide llb from users
type FS llb.State

type FSOutput interface {
	fs() llb.State

	// Evaluate synchronously instantiates the filesystem, blocking until it is created
	// TODO: maybe more args to support caching config like "always" and maybe remote imports
	Evaluate(ctx *dagger.Context) error
}

func (fs FS) fs() llb.State {
	return llb.State(fs)
}

func (fs FS) Evaluate(ctx *dagger.Context) error {
	panic("TODO")
}

// TODO: FS.ReadFile and similar

func (i *Image) output() *imageOutput {
	return &imageOutput{FS: FS(llb.Image(i.Ref))}
}

func (g *GitRepo) output() *gitRepoOutput {
	return &gitRepoOutput{FS: FS(llb.Git(g.Remote, g.Ref))}
}

func (e *Exec) output() *execOutput {
	exec := llb.State(e.Base.fs()).Run(
		llb.Dir(e.Dir),
		llb.Args(e.Args),
	)
	out := make(map[string]FSOutput)
	out["/"] = FS(exec.Root())
	for _, m := range e.Mounts {
		out[m.Path] = FS(exec.AddMount(m.Path, llb.State(m.FS.fs())))
	}
	return &execOutput{FS: FS(exec.Root()), Mounts: out}
}
