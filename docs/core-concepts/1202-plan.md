---
slug: /1202/plan
displayed_sidebar: europa
---

# It all starts with a plan

## Plan structure

Every Dagger configuration starts with a plan, specifically `dagger.#Plan`

Within this plan we can:

- interact with the `client` (read / write files, env vars, run commands, etc.)
- declare `actions` that will be executed as containers

This is our **Getting Started** todoapp plan structure:

```cue file=../tests/core-concepts/plan/structure.cue.fragment
```

This plan returns the following output when it gets executed via `dagger do build`

```shell
[✔] client.filesystem.".".read                               0.0s
[✔] actions.deps                                             1.1s
[✔] actions.test.script                                      0.0s
[✔] actions.test                                             0.0s
[✔] actions.build.run.script                                 0.0s
[✔] actions.build.run                                        0.0s
[✔] actions.build.contents                                   0.0s
[✔] client.filesystem."./_build".write                       0.1s
```

While the names used for the actions above - `deps`, `test` & `build` - are short and descriptive,
any other names would have worked. Put differently, action naming does not affect plan execution.

Notice that even if the `deploy` action is defined in this plan, we did not run it.
Similar to Makefile targets, we run specific actions from a `dagger.#Plan` via `dagger do`

In the example above, we executed the `dagger do build` command, which only runs the `build` action, and all its dependent actions.
This Dagger property enables us to keep the entire CI/CD config in a single file, while keeping CI execution separate from CD.
Separating these concerns becomes essential as our pipelines grow in complexity, and we learn about operational & security constraints specific to our systems.

:::tip
Now that we understand the structure of a Dagger plan, we are ready to learn more about how to interact with the client environment.
This enables us to read env vars (including secrets), run commands, use local sockets, etc.
:::

## Packages & imports

In order to understand the correlation between actions, definitions and packages, let us focus on the following fragment from our **Getting Started** todoapp config:

```cue
package todoapp

import (
  "dagger.io/dagger"
  "universe.dagger.io/netlify"
)

dagger.#Plan & {
  // ...
  actions: {
    // ...
    deploy: netlify.#Deploy & {
      // ...
    }
  // ...
  }
}
```

We start by declaring the package name: `package todoapp`

Next, we import the packages that we use in our plan.

The first import is needed for the `dagger.#Plan` definition to be available.

The second import is for `netlify.#Deploy` to work.

:::note
Which other imports we are missing?
Look at all the actions in the plan structure at the top of this page.
Now check all the available packages in [universe.dagger.io](https://github.com/dagger/dagger/tree/v0.2.4/pkg/universe.dagger.io).
:::

`deploy: netlify.#Deploy` reads as _the deploy action is the deploy definition from the netlify package_

Each definition has default values that can be modified via curly brackets. This is what that looks like in practice for our deploy action:

```cue
// ...
deploy: netlify.#Deploy & {
  contents: build.contents.output
  site:     client.env.APP_NAME
  token:    client.env.NETLIFY_TOKEN
  team:     client.env.NETLIFY_TEAM
}
// ...
```

We can build complex pipelines efficiently by referencing any definition, from any package in our actions.
This is one of the fundamental concepts that makes Dagger a powerful language for building CI/CD pipelines.

If you want to learn more packages in the context of CUE, the config language used by Dagger configs, check out the [Packages](1215-what-is-cue.md#packages) section on the **What is CUE?** page.

