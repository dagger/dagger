---
slug: /api/basics
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Basic Usage

Dagger Functions are packaged, shared and reused using Dagger modules. Dagger modules can contain one or more Dagger Functions. Dagger lets you add dependencies to your Dagger modules, so that you can import, reuse and build on Dagger modules created by others.

The simplest and most common way to call Dagger Functions is with the Dagger Command-Line Interface (CLI).

## Initialize a Dagger module

A new Dagger module is initialized by calling `dagger init`. This creates a new `dagger.json` configuration file in the current working directory, together with sample Dagger Function source code. The configuration file will default the name of the module to the current directory name, unless an alternative is specified with the `--name` argument.

Once a module is initialized, `dagger develop --sdk=...` sets up or updates all the resources needed to develop the module locally. By default, the module source code will be stored in the current working directory, unless an alternative is specified with the `--source` argument.

Here is an example of initializing a Dagger module:

<Tabs groupId="language">
<TabItem value="Go">
```shell
dagger init --name=my-module
dagger develop --sdk=go
```
</TabItem>
<TabItem value="Python">
```shell
dagger init --name=my-module
dagger develop --sdk=python
```
</TabItem>
<TabItem value="TypeScript">
```shell
dagger init --name=my-module
dagger develop --sdk=typescript
```
</TabItem>
</Tabs>

:::info
At any point, running `dagger develop` regenerates the module's code based on dependencies and the current state of the module.
:::

## Understand the default layout

The default template from `dagger develop` creates the following structure:

<Tabs groupId="language">
<TabItem value="Go">

```
.
├── LICENSE
├── dagger
│   ├── dagger.gen.go
│   ├── go.mod
│   ├── go.sum
│   ├── internal
│   │   ├── dagger
│   │   ├── querybuilder
│   │   └── telemetry
│   └── main.go
└── dagger.json
```

In this structure:

- `dagger.json` is the Dagger module configuration file.
- `go.mod`/`go.sum` manage the Go module and its dependencies.
- `main.go` is where your Dagger module code goes. It contains sample code to help you get started.
- `internal` contains automatically-generated types and helpers needed to configure and run the module:
    - `dagger` contains definitions for the Dagger API that's tied to the currently running Dagger Engine container.
    - `querybuilder` has utilities for building GraphQL queries (used internally by the `dagger` package).
    - `telemetry` has utilities for sending Dagger Engine telemetry.

</TabItem>
<TabItem value="Python">

```
.
├── LICENSE
├── dagger
│   ├── pyproject.toml
│   ├── requirements.lock
│   ├── sdk
│   └── src
│       └── main
│           └── __init__.py
└── dagger.json
```

In this structure:

- `dagger.json` is the Dagger module configuration file.
- `pyproject.toml` manages the Python project configuration.
- `requirements.lock` manages the module dependencies.
- `src/main/` is where your Dagger module code goes. It contains sample code to help you get started.
- `sdk/` contains the Python SDK.

This structure hosts a `main` package inside a `src` directory. This follows a [Python convention](https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/) that requires a project to be installed in order to run its code. This prevents accidental usage of development code since the Python interpreter includes the current working directory as the first item on the import path (more information is available in this [blog post on Python packaging](https://blog.ionelmc.ro/2014/05/25/python-packaging/)).

</TabItem>
<TabItem value="TypeScript">

```
.
├── LICENSE
├── dagger
│   ├── package.json
│   ├── sdk
│   ├── src
│   │   └── index.ts
│   └── tsconfig.json
└── dagger.json
```

In this structure:

- `dagger.json` is the Dagger module configuration file.
- `package.json` manages the module dependencies.
- `src/` is where your Dagger module code goes. It contains sample code to help you get started.
- `sdk/` contains the TypeScript SDK.

</TabItem>
</Tabs>

:::note
While you can use the utilities defined in the automatically-generated code above, you *cannot* edit these files. Even if you edit them locally, any changes will not be persisted when you run the module.
:::

## List Dagger Functions

The Dagger Functions available in a Dagger module are listed with `dagger functions`.

The default template generated by `dagger init` includes some sample functions. To list them, using the following command:

```shell
dagger functions
```

Here's what you should see:

```shell
Name             Description
container-echo   Returns a container that echoes whatever string argument is provided
grep-dir         Returns lines that match a pattern in the files of the provided Directory
```

Modules don't need to be installed locally. Dagger lets you consume modules from GitHub repositories as well. You can call Dagger Functions from external modules in exactly the same way as you would call them locally.

Here is an example of listing Dagger Functions in an external module:

```shell
dagger -m github.com/jpadams/daggerverse/trivy@v0.5.0 functions
```

Here's what you should see:

```shell
Name             Description
base             Return a Container from the official trivy image.
scan-container   Scan a Dagger Container.
scan-image       Scan an image ref.
```

## List available arguments for a Dagger Function

To list all the arguments accepted by a function, add the `--help` suffix at any point in the `dagger call` command to obtain context-sensitive help.

Here is an example of listing available arguments for a Dagger Function in an external module:

```shell
dagger -m github.com/jpadams/daggerverse/trivy@v0.5.0 call scan-image --help
```

Here's what you should see:

```
Scan an image ref.

USAGE
  dagger call scan-image [arguments]

ARGUMENTS
      --image-ref string         [required]
      --exit-code int
      --format string             (default "table")
      --severity string           (default "UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL")
      --trivy-image-tag string    (default "latest")
```

## Call a Dagger Function

A Dagger Function is invoked with `dagger call`. Here is an example of calling one of the sample Dagger Functions in the default module template:

```shell
dagger call container-echo --string-arg="Welcome to Dagger!" stdout
```

Here's what you should see:

```shell
Welcome to Dagger!
```

:::tip
When using `dagger call`, all names (functions, arguments, struct fields, etc) are converted into a shell-friendly "kebab-case" style.
:::

## Call a Dagger Function from an external module

Here is an example of calling a Dagger Function hosted in a remote Git repository. This Dagger Function scans container images for vulnerabilities.

```shell
dagger -m github.com/jpadams/daggerverse/trivy@v0.5.0 call scan-image --image-ref=ubuntu:latest
```

Here's what you should see:

```shell
ubuntu:latest (ubuntu 24.04)
============================
Total: 10 (UNKNOWN: 0, LOW: 8, MEDIUM: 2, HIGH: 0, CRITICAL: 0)
...
```

In this example, the Dagger CLI is first loading the Dagger module directly from its GitHub repository and then executing the named Dagger Function from that module.

## Create a Dagger Function

Here's an example of a Dagger Function which calls a remote API method and returns the result:

<Tabs groupId="language">
<TabItem value="Go">
```go file=./snippets/functions/functions-complex/go/main.go
```

This Dagger Function includes the context as input and error as return in its signature.
</TabItem>
<TabItem value="Python">
```python file=./snippets/functions/functions-complex/python/main.py
```

Dagger Functions are implemented as [@dagger.function][@function] decorated
methods, of a [@dagger.object_type][@object_type] decorated class.

It's possible for a module to implement multiple classes (*object types*), but
**the first one needs to have a name that matches the module's name**, in
*PascalCase*. This object is sometimes referred to as the *main object*.

For example, for a module initialized with `dagger init --name=my-module`,
the main object needs to be named `MyModule`.
</TabItem>
<TabItem value="TypeScript">
```typescript file=./snippets/functions/functions-complex/typescript/index.ts
```
</TabItem>
</Tabs>

:::caution
You can try this Dagger Function by copying it into the default template generated by `dagger init`, but remember that you must update the module name in the code samples above to match the name used when your module was first initialized.
:::

In simple terms, here is what this Dagger Function does:

- It initializes a new container from an `alpine` base image.
- It executes the `apk add ...`   command in the container to add the `curl` and `jq` utilities.
- It uses the `curl` utility to send an HTTP request to the URL `https://randomuser.me/api/` and parses the response using `jq`.
- It retrieves and returns the output stream of the last executed command as a string.

Here is an example call for this Dagger Function:

```shell
dagger call get-user
```

Here's what you should see:

```shell
{
  "title": "Mrs",
  "first": "Beatrice",
  "last": "Lavigne"
}
```
