---
slug: /api
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dagger API

The Dagger API is a unified interface for programming Dagger. It provides a set of powerful core types for creating and managing application delivery pipelines, including types for containers, artifacts, network services, and secrets. The Dagger API uses GraphQL as its low-level language-agnostic framework.

## Dagger Functions

The recommended, and most common way, to interact with the Dagger API is through Dagger Functions. Dagger Functions are just regular code, written in your usual language using a type-safe Dagger SDK.

Here's an example of a Dagger Function which calls a remote API method and returns the result:

<Tabs groupId="language">
<TabItem value="Go">
```go file=./snippets/functions/functions-complex/go/main.go
```
</TabItem>
<TabItem value="Python">
```python file=./snippets/functions/functions-complex/python/main.py
```
</TabItem>
<TabItem value="TypeScript">
```typescript file=./snippets/functions/functions-complex/typescript/index.ts
```
</TabItem>
</Tabs>

In simple terms, this Dagger Function:

- initializes a new container from an `alpine` base image.
- executes the `apk add ...` command in the container to add the `curl` and `jq` utilities.
- uses the `curl` utility to send an HTTP request to the URL `https://randomuser.me/api/` and parses the response using `jq`.
- retrieves and returns the output stream of the last executed command as a string.

All Dagger Functions can be called from the Dagger CLI. The CLI can call any Dagger Function, either from your local filesystem or from a Git repository. It can be used interactively, from a shell script, or from a CI configuration. Apart from the Dagger CLI, no other infrastructure or tooling is required to call Dagger Functions.

Here is an example of using the Dagger CLI to call this Dagger Function:

```shell
dagger call get-user
```

Here's what you should see:

```shell
{
  "title": "Mrs",
  "first": "Beatrice",
  "last": "Lavigne"
}
```

## Dagger API Types

Dagger Functions can return basic types (string, boolean, integer, arrays...), but they can also return powerful [core types](./return-values.mdx). These include `Directory`, `Container`, `Service`, `Secret`, and many more. Each of these types define various fields for interacting with their respective objects.

:::note
The types listed in this section are indicative and not exhaustive. For a complete list of supported types and their fields, refer to the [Dagger API reference](https://docs.dagger.io/api/reference).
:::

The following table lists some common types and what they represent:

| Type | Description |
|------|-------------|
| `CacheVolume` | A directory whose contents persist across runs |
| `Container` | An OCI-compatible container |
| `CurrentModule` | The current Dagger module and its context |
| `DaggerEngine` | The Dagger Engine configuration and state |
| `Directory` | A directory (local path or Git reference) |
| `EnvVariable` | An environment variable name and value |
| `File` | A file |
| `GitRepository` | A Git repository |
| `GitRef` | A Git reference (tag, branch, or commit) |
| `Host` | The Dagger host environment |
| `Module` | A Dagger module |
| `Port` | A port exposed by a container |
| `Secret` | A secret credential like a password, access token or key) |
| `Service` | A content-addressed service providing TCP connectivity |
| `Socket` | A Unix or TCP/IP socket that can be mounted into a container |
| `Terminal` | An interactive terminal session |

## Calling the Dagger API

You can call the Dagger API in multiple ways.

- From the Dagger CLI
  - [`dagger core` for core API functions](./clients-cli.mdx#dagger-api)
  - [`dagger call` for Dagger modules](./clients-cli.mdx#dagger-functions)
  - [`dagger query` for raw GraphQL queries](./clients-http.mdx#dagger-cli)
- From a [Dagger Function](./clients-sdk.mdx#dagger-functions)
- From a custom application created with a Dagger SDK
  - [`dagger run` for command execution with live progress](./clients-sdk.mdx#custom-applications)
- From a [language-native GraphQL client](./clients-http.mdx#language-native-http-clients)
- From a [command-line HTTP client like `curl`](./clients-http.mdx#command-line-http-clients)

## Chaining

When calling a Dagger Function that returns a core type, the Dagger API lets you follow up by calling one of that type's functions, which itself can return another type, and so on. This is called "function chaining", and is a core feature of Dagger.

For example, if a Dagger Function returns a `Directory`, the caller can continue the chain by calling a function from the `Directory` type to export it to the local filesystem, modify it, mount it into a container, and so on.

### Dagger CLI

To illustrate, try the following example:

```shell
dagger -m github.com/kpenfound/dagger-modules/golang@v0.2.0 call build --source=https://github.com/golang/example#master:/hello --args=. terminal
```

This example chains two function calls:
- the first call (`build`) builds a Go application from a remote GitHub repository and returns a just-in-time directory with the compiled binary;
- the second call (`terminal`) opens an interactive terminal session in the just-in-time directory.

You can use the interactive terminal to validate the compiled binary:

```shell
dagger /src $ ls
hello
dagger /src $ ./hello
Hello, world!
```

### Dagger Functions

Just as you can chain Dagger Functions with the Dagger CLI, you can also chain Dagger Functions (including Dagger Functions created by others) using the programming language you're most comfortable with.

Here's the Dagger Function equivalent of the previous example. It is a Dagger Function that utilizes a module from the Daggerverse to build a Go project, then chains a Dagger API method to open an interactive terminal session in the build directory.

First, install the module:

```shell
dagger install github.com/kpenfound/dagger-modules/golang@v0.2.0
```

Next, create a new Dagger Function:

<Tabs groupId="language">
<TabItem value="Go">
```go file=./snippets/chaining/using/go/main.go
```
</TabItem>
<TabItem value="Python">
```python file=./snippets/chaining/using/python/main.py
```
</TabItem>
<TabItem value="TypeScript">
```typescript file=./snippets/chaining/using/typescript/index.ts
```
</TabItem>
</Tabs>

This Dagger Function accepts two arguments - the source directory and a list of build arguments - and does the following:

- It invokes the Golang module via the `dag` Dagger client.
- It calls a Dagger Function from the module to build the source code and return a just-in-time directory with the compiled binary.
- It chains a core Dagger API method to open an interactive terminal session in the returned directory.

Here is an example call for this Dagger Function:

```shell
dagger call example --build-src=https://github.com/golang/example#master:/hello --build-args=.
```

As before, you can use the interactive terminal to validate the compiled binary:

```shell
dagger /src $ ls
hello
dagger /src $ ./hello
Hello, world!
```

### Examples

The following sections demonstrate some examples of function chaining with the Dagger CLI.

#### Execute commands in containers

The Dagger CLI can add follow-up processing to a just-in-time container, essentially enabling you to continue the pipeline directly from the command-line. `Container` objects expose a `withExec()` API method, which lets you execute a command in the corresponding container.

Here is an example of chaining a `Container.withExec()` call to a container returned by a Wolfi container builder Dagger Function, to execute a command that displays the contents of the `/etc/` directory:

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-exec --args="ls","/etc/" stdout
```

Here is an example of chaining a `Container.withExec()` function call to a container returned by a Wolfi container builder Dagger Function, to execute a command that displays the contents of the `/etc/os-release` file:

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-exec --args="cat","/etc/os-release" stdout
```

Here is an example of chaining a `Container.withExec()` function call to do the reverse: modify a container returned by a Wolfi container builder Dagger Function, by removing the `/etc/os-release` file from the container filesysytem:

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-exec --args="rm","/etc/os-release" with-exec --args="ls","/etc" stdout
```

Here is another example which chains multiple `Container.withExec()` calls to install the `curl` package in a Wolfi container, send an HTTP request, and return the output:

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-exec --args="apk,add,curl" with-exec --args="curl,-L,dagger.io" stdout
```

#### Live-debug container builds

`Container` objects expose a `terminal()` API method, which lets you starting an ephemeral interactive terminal session in the corresponding container. This feature is very useful for debugging and experimenting since it allows you to inspect containers directly and at any stage of your Dagger Function execution.

Here is an example of chaining a `Container.terminal()` function call to start an interactive terminal in the container returned by a Wolfi container builder Dagger Function:

```shell
dagger call -m github.com/shykes/daggerverse/wolfi@v0.1.4 container --packages=cowsay terminal
```

By default, the terminal is started with the `sh` shell, although this can be overridden by adding the `--cmd` argument. To start the same terminal with the `zsh` shell, use:

```shell
dagger call -m github.com/shykes/daggerverse/wolfi@v0.1.4 container --packages=cowsay,zsh terminal --cmd=zsh
```

#### Export directories, files and containers

Just-in-time artifacts such as containers, directories and files can be exported to the host filesystem from the Dagger Function that produced them. The destination path on the host is specified using the `--path` argument.

Here is an example of exporting the directory returned by a Go builder Dagger Function to the `./my-build` directory on the host:

```shell
dagger -m github.com/kpenfound/dagger-modules/golang@v0.2.0 call build --source=https://github.com/dagger/dagger --args=./cmd/dagger export --path=./my-build
```

By default, the `Directory.export()` method exports the files that exist in the returned directory to the host, but it does not modify or delete any files that already exist at that host path. To replace the contents of the target host directory, such that it exactly matches the directory being exported, add the `--wipe` argument.

Here is an example of exporting the build directory returned by the same Dagger Function above, deleting and replacing files as needed in the `./my-build` directory on the host:

```shell
dagger -m github.com/kpenfound/dagger-modules/golang@v0.2.0 call build --source=https://github.com/dagger/dagger --args=./cmd/dagger export --path=./my-build --wipe
```

Instead of exporting an entire directory, you can also export a file. Here is an example of exporting a single file from the directory returned by the same Go builder Dagger Function, as `./my-binary-file` on the host:

```shell
dagger -m github.com/kpenfound/dagger-modules/golang@v0.2.0 call build --source=https://github.com/dagger/dagger --args=./cmd/dagger file --path=dagger export --path=./my-binary-file
```

Here is another example, this time exporting the results of a `ruff` linter Dagger Function as `/tmp/report.json` on the host:

```shell
dagger call -m github.com/dagger/dagger/dev/ruff@a29dadbb5d9968784847a15fccc5629daf2985ae lint --source https://github.com/dagger/dagger report export --path=/tmp/report.json
```

Here is an example of exporting a container returned by a Wolfi container builder Dagger Function as an OCI tarball named `/tmp/tarball.tar.gz` on the host:

```shell
dagger call -m github.com/shykes/daggerverse/wolfi@v0.1.4 container export --path=./tarball.tar.gz
```

Here is an example of listing the contents of a directory returned by a Dagger Function, by chaining a call to the `Directory.entries()` method:

```shell
git clone https://github.com/golang/example
dagger -m github.com/kpenfound/dagger-modules/golang@v0.2.0 call build --source=./example/hello --args=. directory --path=. entries
```

#### Publish containers

Every `Container` object exposes a `Container.publish()` API method, which publishes the container as a new image to a specified container registry. The registry address is passed to the function using the `--address` argument, and the return value is a string referencing the container image address in the registry.

Here is an example of publishing the container returned by a Wolfi container builder Dagger Function to the `ttl.sh` registry, by chaining a `Container.publish()` call:

```shell
dagger call -m github.com/shykes/daggerverse/wolfi@v0.1.4 container publish --address=ttl.sh/my-wolfi
```

#### Start containers as services

Every `Container` object exposes a `Container.asService()` API method, which turns the container into a `Service`. These services can then be spun up for use by other Dagger Functions or by clients on the Dagger host by forwarding their ports. This is akin to a "programmable docker-compose".

To start a `Service` returned by a Dagger Function and have it forward traffic to a specified address via the host, chain a call to the `Service.up()` API method.

Here is an example of starting an NGINX service on host port 80 by chaining calls to `Container.asService()` and `Service.up()`:

```shell
dagger -m github.com/kpenfound/dagger-modules/nginx@v0.1.0 call container as-service up
```

By default, each port maps to the same port on the host. To specify a different mapping, use the additional `--ports` argument with a list of host/service port mappings. To bind ports randomly, use the `--random` argument.

To start the same service and map NGINX port 80 to host port 8080, use:

```shell
dagger -m github.com/kpenfound/dagger-modules/nginx@v0.1.0 call container as-service up --ports=8080:80
```

The service can now be accessed on the specified port. For example, in another terminal, execute the following command to receive the default NGINX welcome page:

```shell
curl localhost:8080
```

To start the same service and map NGINX port 80 to a random port on the host, use:

```shell
dagger -m github.com/kpenfound/dagger-modules/nginx@v0.1.0 call container as-service up --random
```

#### Modify container filesystems

Here is an example of modifying a container by adding the current directory from the host to the container filesysytem at `/src`, by chaining a call to the `Container.withDirectory()` method:

:::warning
The example below uploads the entire current directory to the container filesystem. This can take a significant amount of time with large directories. To reduce the time spent on upload, run this example from a directory containing only a few small files.
:::

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-directory --path=/src --directory=. with-exec --args="ls","/src" stdout
```

Here is an example of passing a host file to a container builder Dagger Function by chaining a call to the `Container.withFile()` function:

```shell
dagger -m github.com/shykes/daggerverse/wolfi@v0.1.4 call container with-file --path=/README.md --source=./README.md with-exec --args="cat","/README.md" stdout
```

## Extending the Dagger API

The Dagger API also provides functionality for loading Dagger modules. Dagger modules contain one or more Dagger Functions. When a Dagger module is loaded into the session, the Dagger API is [dynamically extended](./internals.mdx#api-extension-with-dagger-functions) with new Dagger Functions served by that module. So, after loading a Dagger module, an API client can now call all of the original core APIs _plus_ the new Dagger Functions provided by that module.

You are encouraged to write your own Dagger modules and share them with others. Dagger also lets you import and reuse modules developed by your team, your organization or the broader Dagger community. The [Daggerverse](https://daggerverse.dev) is a free service run by Dagger, which indexes all publicly available Dagger modules and Dagger Functions, and lets you easily search and consume them.
