---
slug: /api
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Dagger API

The Dagger API is an unified interface for dynamically composing Dagger pipelines. It provides a set of core functions and core types for creating and managing application delivery pipelines, including types for containers, artifacts, network services, and secrets.

## Functions

Creating a pipeline with the Dagger API involves calling its functions. Typically, you will call multiple functions in sequence, chaining them together such that their operations form a pipeline. Here's an example:

```shell
dagger core container \
  from --address=alpine \
  file --path=/etc/os-release \
  contents
```

This example calls various functions from the Dagger API to create an `alpine` container and return the contents of the `/etc/os-release` file to the caller.

## Types

Like regular functions, Dagger functions can accept arguments. You can see this in the previous example: the `from` function accepts a container image address (`--address`) as argument, the file function accepts a filesystem location (`--path`) as argument, and so on.

In addition to supporting basic types (string, boolean, integer, array...), the Dagger API also provides [powerful core types](./types.mdx) for working with pipelines, such as `Container`, `GitRepository`, `Directory`, `Service`, `Secret`, and many more, and lets you use these as arguments to Dagger Functions.

Here's an example:

```shell
dagger core container \
  with-directory --path=/src --directory=https://github.com/dagger/dagger \
  directory --path=/src \
  entries
```

This example creates a scratch container, adds Dagger's GitHub repository to it, and returns the directory contents. In this case, the address of the GitHub repository is passed to the function as a `Directory` argument. The `Directory` loaded in this manner is not merely a string, but it is the actual filesystem state of the repository, managed by the Dagger Engine and handled in code just like any another variable.

## Chaining

Dagger's core types can be used as both function [arguments](./arguments.mdx) and [return values](./return-values.mdx). Each core type comes with functions of its own, which can be used to interact with the corresponding object.

When calling a Dagger function that returns a core type, the Dagger API lets you follow up by calling one of that type's functions, which itself can return another type, and so on. This is called "function chaining", and is a core feature of Dagger.

For example, if a Dagger function returns a `Directory`, the caller can continue the chain by calling a function from the `Directory` type to export it to the local filesystem, modify it, mount it into a container, and so on.

Although you may not have realized it, you've already seen function chaining in action in both the previous examples. Here is one more example to illustrate the concept:

```shell
dagger core container from --address="golang:latest" \
  with-directory --path="/src" --directory="https://github.com/dagger/dagger#main" \
  with-workdir --path="/src/cmd/dagger" \
  with-exec --args="go","build","-o","dagger","." \
  file --path="./dagger" \
  export --path="./dagger.bin"
```

This example chains multiple function calls:
- `from` returns a `golang` container image as a `Container` type
- `with-directory` adds the Dagger open source repository to the container image filesystem
- `with-workdir` sets the working directory to the Dagger repository
- `with-exec` compiles the Dagger CLI
- `file` returns the built binary as a `File` type
- `export` exports the binary artifact to the Dagger host as `./dagger.bin`

[See more examples of functions chaining](./chaining.mdx).

## Calling the Dagger API

You can call the Dagger API in multiple ways. In recommended order, they are:

- From the Dagger CLI
  - [`dagger core`](./clients-cli.mdx#dagger-api) for core functions
  - [`dagger call`](./clients-cli.mdx#dagger-functions) for [custom functions](./functions.mdx)
- From a custom application created with a Dagger SDK
  - [`dagger run`](./clients-sdk.mdx#custom-applications)
- From a [language-native GraphQL client](./clients-http.mdx#language-native-http-clients)
- From a command-line HTTP or GraphQL client
  - [`curl`](./clients-http.mdx#command-line-http-clients)
  - [`dagger query`](./clients-http.mdx#dagger-cli)

The easiest and most common way to call Dagger functions is with the Dagger CLI. The CLI can call any Dagger function, either from your local filesystem or from a remote Git repository. It can be used interactively, from a shell script, or from a CI configuration. Apart from the Dagger CLI, no other infrastructure or tooling is required to call Dagger functions.

:::note
The Dagger API is an HTTP API that uses GraphQL as its low-level language-agnostic framework. However, in practice, calling the API using HTTP or GraphQL is optional. Typically, you will call the API using a custom Dagger function created with a type-safe Dagger SDK, or using the Dagger CLI.
:::

## Extending the Dagger API

The Dagger API can be [extended with custom functions and custom types](./functions.mdx), which are loaded via  Dagger modules. When a Dagger module is loaded into the session, the Dagger API is [dynamically extended](./internals.mdx#api-extension-with-dagger-functions) with new Dagger functions served by that module. So, after loading a Dagger module, an API client can now call all of the original core APIs _plus_ the new Dagger functions provided by that module.

You are encouraged to write your own Dagger modules and share them with others. Dagger also lets you import and reuse modules developed by your team, your organization or the broader Dagger community. The [Daggerverse](https://daggerverse.dev) is a free service run by Dagger, which indexes all publicly available Dagger modules and Dagger Functions, and lets you easily search and consume them.
