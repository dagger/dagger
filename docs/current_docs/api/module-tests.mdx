---
slug: /api/module-tests
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import DaggerModuleInit from '../partials/_dagger_module_init.mdx';

# Module Tests

Like any other piece of software, Dagger Functions and modules should be thoroughly tested. This section documents proven patterns and best practices for effectively testing reusable modules.

## Test module

Well-written tests often provide the best documentation for your software, and this holds true for Dagger modules as well. It's considered a best practice to keep your tests close to the module's code so they can serve as both verification and reference. Additionally, tests that rely on the module's public API act as functional examples, clearly illustrating how to use the module.

Following these principles leads to writing tests for your Dagger modules using Dagger modules themselves. In practice, this means creating a test module in the same directory as your main module and writing your tests as Dagger Functions, as shown below:

```shell
mkdir tests
cd tests
dagger init --name tests --sdk go --source .
```

TODO: insert language specific examples

:::tip
`tests` is a logical name to use for the test module, but this is not mandatory. Some people call it `dev` to indicate it contains other, development related functions, not just tests.
:::

TODO: insert tests from the example repo

## Test function signature

In the previous example, the test function returned a string.

Since test functions are ordinary Dagger functions, you can return any value that's allowed. While this approach works fine when running a test with `dagger call`, there are scenarios where a single return value isn't sufficient. For example, you might need to handle multiple output objects, wait for asynchronous operations, manage errors, or (in some languages) provide additional context.

Another challenge arises when you have multiple test functions with parameters, as you must remember to call each test function with the correct arguments.

In such cases, it can be helpful to standardize your test function signature. Consider generating inputs from within the function, synchronizing any asynchronous tasks there, and returning a single value or an error. This approach keeps your tests consistent and easier to maintain.

TODO: insert language specific test function examples

In some situations, you may need to provide specific values to your test modules, such as when authenticating against an external service. In these cases, you can rely on [module constructors](./constructors.mdx) to inject any required inputs.

## Testable examples

In the Daggerverse, [example modules](https://docs.dagger.io/api/daggerverse#examples) are special modules designed to showcase your own modules, offering better demonstrations than the automatically generated ones.

You can combine example modules with the test module pattern to turn those examples into executable tests. Often, this approach provides enough coverage to eliminate the need for a separate test module. However, if you require more in-depth testing, you can still create a dedicated test module, as shown below:

```shell
mkdir -p examples/go
cd examples/go
dagger init --name examples/go --sdk go --source .
```

TODO: insert language-specific examples
TODO: insert examples from the examples repo

## "All" function pattern

Regardless of whether you employ the test or the example module pattern, you probably want the ability to run all tests at once (for example, in CI or just to verify everything works locally), while reserving the capability to run individual tests for debugging purposes.

This is where the `all` function comes into the picture. It's basically a single function that executes all your tests or examples.

Depending on the SDK you use, this may be as simple as calling each test function after the other:

TODO: insert all function with manual function calls

Alternatively, if the SDK/language you use supports this, you can run tests in parallel:

TODO: insert all function with parallel calls

You can now run all tests for the module using `dagger call -m tests all`.

:::tip
Adopting a standard test function signature greatly simplifies both kinds of `all` functions.
:::
