---
title: "Cookbook"
slug: /cookbook
description: "Learn how to use Dagger to build, test, and deploy your applications with practical examples."
sidebar_label: "Overview"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import DocCardList from "@theme/DocCardList";

<DocCardList />

## Optimizations

### Cache application dependencies

The following Dagger Function uses a cache volume for application dependencies. This enables Dagger to reuse the contents of the cache across Dagger Function runs and reduce execution time.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/cache-dependencies/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

:::note
The default location for the cache directory depends on the package manager (`~/.cache/pip` for `pip` or `~/.cache/pypoetry` for `poetry`).
:::

```python file=./snippets/cache-dependencies/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/cache-dependencies/typescript/index.ts
```

</TabItem>
<TabItem value="php" label="PHP">

```php file=./snippets/cache-dependencies/php/src/MyModule.php
```

</TabItem>
</Tabs>

### Example

Build an application using cached dependencies:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'build .'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    build .
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call build --source=.
    ```
    </TabItem>
    </Tabs>

### Set environment variables in a container

The following Dagger Function demonstrates how to set a single environment variable in a container.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/set-env-var/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=./snippets/set-env-var/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/set-env-var/typescript/index.ts
```

</TabItem>
<TabItem value="php" label="PHP">

```php file=./snippets/set-env-var/php/src/MyModule.php
```

</TabItem>
</Tabs>

The following Dagger Function demonstrates how to set multiple environment variables in a container.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/set-env-vars/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=./snippets/set-env-vars/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/set-env-vars/typescript/index.ts
```

</TabItem>
</Tabs>

### Example

- Set a single environment variable in a container:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c set-env-var
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    set-env-var
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call set-env-var
    ```
    </TabItem>
    </Tabs>

- Set multiple environment variables in a container:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c set-env-vars
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    set-env-vars
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call set-env-vars
    ```
    </TabItem>
    </Tabs>

### Persist service state across runs

The following Dagger Function uses a cache volume to persist a Redis service's data across Dagger Function runs.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=../extending/snippets/services/persist-service-state/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=../extending/snippets/services/persist-service-state/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=../extending/snippets/services/persist-service-state/typescript/index.ts
```

</TabItem>
</Tabs>

### Example

- Save data to a Redis service which uses a cache volume to persist a key named `foo` with value `123:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'set foo 123'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    set foo 123
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call set --key=foo --value=123
    ```
    </TabItem>
    </Tabs>

- Retrieve the value of the key `foo` after recreating the service state from the cache volume:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'get foo'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    get foo
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call get --key=foo
    ```
    </TabItem>
    </Tabs>

### Execute functions concurrently

The following Dagger Function demonstrates how to use native-language concurrency features ([errgroups](https://pkg.go.dev/golang.org/x/sync/errgroup) in Go, [task groups](https://anyio.readthedocs.io/en/stable/tasks.html) in Python), and [promises](https://basarat.gitbook.io/typescript/future-javascript/promise) in TypeScript to execute other Dagger Functions concurrently. If any of the concurrently-running functions fails, the remaining ones will be immediately cancelled.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/execute-concurrently/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=./snippets/execute-concurrently/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/execute-concurrently/typescript/index.ts
```

</TabItem>
</Tabs>

### Example

Execute a Dagger Function which performs different types of tests by executing other Dagger Functions concurrently.

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'my-module $(host | directory .) | run-all-tests'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    my-module $(host | directory .) | run-all-tests
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call --source=. run-all-tests
    ```
    </TabItem>
    </Tabs>

## Error handling

### Terminate gracefully

The following Dagger Function demonstrates how to handle errors in a workflow.


<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/handle-errors/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=./snippets/handle-errors/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/handle-errors/typescript/index.ts
```

</TabItem>
</Tabs>

### Example

Execute a Dagger Function which creates a container and runs a command in it. If the command fails, the error is captured and the Dagger Function is gracefully terminated with a custom error message.

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c test
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    test
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call test
    ```
    </TabItem>
    </Tabs>

### Continue using a container after command execution fails

The following Dagger Function demonstrates how to continue using a container after a command executed within it fails. A common use case for this is to export a report that a test suite tool generates.

:::note
The caveat with this approach is that forcing a zero exit code on a failure caches the failure. This may not be desired depending on the use case.
:::

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=./snippets/continue-after-errors/go/main.go
```

</TabItem>
<TabItem value="python" label="Python">

```python file=./snippets/continue-after-errors/python/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=./snippets/continue-after-errors/typescript/src/index.ts
```

</TabItem>
</Tabs>

### Example

Continue executing a Dagger Function even after a command within it fails. The Dagger Function returns a custom `TestResult` object containing a test report and the exit code of the failed command.

- Obtain the exit code:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'test | exit-code'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    test | exit-code
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call test exit-code
    ```
    </TabItem>
    </Tabs>

- Obtain the report:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c 'test | report | contents'
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    test | report | contents
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call test report contents
    ```
    </TabItem>
    </Tabs>

## Debugging

### Debug container builds

Dagger provides two features that can help greatly when trying to debug a workflow - opening an interactive terminal session at the failure point, or at explicit breakpoints throughout your workflow code. All context is available at the point of failure. Multiple terminals are supported in the same Dagger Function; they will open in sequence.

The following Dagger Function opens an interactive terminal session at different stages in a Dagger workflow to debug a container build.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=../extending/snippets/debugging/go/terminal-container/main.go
```

</TabItem>
<TabItem value="python" label="Python">
```python file=../extending/snippets/debugging/python/terminal-container/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=../extending/snippets/debugging/typescript/terminal-container/index.ts
```

</TabItem>
</Tabs>

### Example

Execute a Dagger Function to build a container, and open an interactive terminal at two different points in the build process. The interactive terminal enables you to inspect the container filesystem and environment "live", during the build process.

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c container
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    container
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call container
    ```
    </TabItem>
    </Tabs>

### Inspect directories and files

The following Dagger Function clones Dagger's GitHub repository and opens an interactive terminal session to inspect it. Under the hood, this creates a new container (defaults to `alpine`) and starts a shell, mounting the repository directory inside.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=../extending/snippets/debugging/go/terminal-directory-1/main.go
```

</TabItem>
<TabItem value="python" label="Python">
```python file=../extending/snippets/debugging/python/terminal-directory-1/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=../extending/snippets/debugging/typescript/terminal-directory-1/index.ts
```

</TabItem>
</Tabs>

The container created to mount the directory can be customized using additional options. The following Dagger Function revised the previous example to demonstrate this, using an `ubuntu` container image and `bash` shell instead of the defaults.

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">

```go file=../extending/snippets/debugging/go/terminal-directory-2/main.go
```

</TabItem>
<TabItem value="python" label="Python">
```python file=../extending/snippets/debugging/python/terminal-directory-2/main.py
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript file=../extending/snippets/debugging/typescript/terminal-directory-2/index.ts
```

</TabItem>
</Tabs>

### Example

- Execute a Dagger Function to clone Dagger's GitHub repository and open a terminal session in the repository directory:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c simple-directory
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    simple-directory
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call simple-directory
    ```
    </TabItem>
    </Tabs>

- Execute another Dagger Function that does the same as the previous one, except using an `ubuntu` container image as base and initializing the terminal with the `bash` shell:

    <Tabs groupId="shell">
    <TabItem value="System shell">
    ```shell
    dagger -c advanced-directory
    ```
    </TabItem>
    <TabItem value="Dagger Shell">
    ```shell title="First type 'dagger' for interactive mode."
    advanced-directory
    ```
    </TabItem>
    <TabItem value="Dagger CLI">
    ```shell
    dagger call advanced-directory
    ```
    </TabItem>
    </Tabs>

### Create custom spans

Dagger represents operations performed by a Dagger Function as [OpenTelemetry spans](https://opentelemetry.io/docs/concepts/signals/traces/#spans). Spans are typically used to separate tasks that are running in parallel, with each branch waiting for completion.

It is possible to instrument custom OpenTelemetry spans inside any Dagger Function. This allows you to define logical boundaries within complex workflows, measure execution time, and track nested operations with greater granularity. These custom spans appear in the Dagger TUI and Traces.

The following Dagger Function demonstrates this by emitting custom spans for various tasks.

:::warning
The approach described below is experimental and may be deprecated in favor of a new OpenTelemetry span API. [Contribute to the ongoing discussion of this topic on GitHub](https://github.com/dagger/dagger/pull/9327).
:::

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/custom-spans/go/main.go
```

</TabItem>
<TabItem value="Python">
```python file=./snippets/custom-spans/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/custom-spans/typescript/index.ts
```

</TabItem>
</Tabs>

:::warning
When using spans to group and measure Dagger API function calls, ensure that the function calls are not [lazily evaluated](../extending/internals.mdx#lazy-evaluation). The duration of the corresponding spans in this case will always be zero.
:::

### Example

Execute a Dagger Function to run unit tests on the `dagger/hello-dagger` source code repository with different versions of Node.js, emitting a custom span for each version tested:

```shell
dagger call foo
```
