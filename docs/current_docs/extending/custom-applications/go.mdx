---
title: "Go Custom Application"
sidebar_label: "Go"
slug: /extending/custom-applications/go
description: "Learn how to extend Dagger by embedding it into your own Go applications, enabling custom workflows and integrations."
---

:::note
The Dagger Go SDK requires [Go 1.22 or later](https://go.dev/doc/install).
:::

From an existing Go module, install the Dagger Go SDK using the commands below:

```shell
go get dagger.io/dagger@latest
```

After importing `dagger.io/dagger` in your Go module code, run the following command to update `go.sum`:

```shell
go mod tidy
```

This example demonstrates how to build a Go application for multiple architectures and Go versions using the Go SDK.

Clone an example project and create a new Go module in the project directory:

```shell
git clone https://go.googlesource.com/example
cd example/hello
mkdir multibuild && cd multibuild
go mod init multibuild
```

Create a new file in the `multibuild` directory named `main.go` and add the following code to it:

```go file=./snippets/clients-sdk/go/main.go
```

This Go program imports the Dagger SDK and defines two functions. The `build()` function represents the workflow and creates a Dagger client, which provides an interface to the Dagger API. It also defines the build matrix, consisting of two OSs (`darwin` and `linux`) and two architectures (`amd64` and `arm64`), and builds the Go application for each combination. The Go build process is instructed via the `GOOS` and `GOARCH` build variables, which are reset for each case.

Try the Go program by executing the command below from the project directory:

```shell
dagger run go run multibuild/main.go
```

The `dagger run` command executes the specified command in a Dagger session and displays live progress. The Go program builds the application for each OS/architecture combination and writes the build results to the host. You will see the build process run four times, once for each combination. Note that the builds are happening concurrently, because the builds do not depend on eachother.

Use the `tree` command to see the build artifacts on the host, as shown below:

```shell
tree build
build
├── 1.22
│   ├── darwin
│   │   ├── amd64
│   │   │   └── hello
│   │   └── arm64
│   │       └── hello
│   └── linux
│       ├── amd64
│       │   └── hello
│       └── arm64
│           └── hello
└── 1.23
    ├── darwin
    │   ├── amd64
    │   │   └── hello
    │   └── arm64
    │       └── hello
    └── linux
        ├── amd64
        │   └── hello
        └── arm64
            └── hello
```
