---
slug: /features/language-interoperability
---

# Language Interoperability

Modern development takes place in a mix of languages, tools and platforms. In this polyglot environment, no one language or tool can "win". Every component must be interoperable with every other.

Some benefits of this interoperability include:
- simplified debugging across tools and languages
- the flexibility to select the "best fit" tool for a specific task
- a unified ecosystem for sharing and reusability

Dagger supports cross-language linking, so you can mix and match Dagger Functions written in different languages without worrying about interoperability. For example, a Python function can call a Go function, which can call a TypeScript function, and so on.

This means that you no longer need to care which language your CI tooling is written in; you can use the one that you're most comfortable with or that best suits your requirements. This feature also immediately unlocks cross-team collaboration: even though different teams might prefer different languages, the Dagger Functions they create are instantly compatible and usable by other teams (or even by the broader Dagger community).

Here's an example, where a Dagger Function written in Python calls both core functions and third-party Dagger Functions written in Go:

```python
@function
async def ci(self, source: dagger.Directory) -> str:
    # Use third-party Golang module to configure project
    go_project = dag.golang().with_project(source)

    # Run Go tests using Golang module
    await go_project.test()

    # Get container with built binaries using Golang module
    image = await go_project.build_container()

    # Push image to a registry using core Dagger API
    ref = await image.publish("ttl.sh/demoapp:1h")

    # Scan image for vulnerabilites using third-party Trivy module
    return await dag.trivy().scan_container(dag.container().from_(ref))
```

Dagger is able to do this because it uses GraphQL as its low-level language-agnostic API query language.  Each Dagger SDK generates native code-bindings for all dependencies, which abstract away the underlying GraphQL queries. An additional bonus of this approach is that it gives you all the benefits of type-checking, code completion and other IDE features when developing Dagger Functions.

Language interoperability also creates new opportunities for sharing and reusability. Since Dagger Functions are language-agnostic, you can speed up development by importing and reusing external Dagger Functions in your pipelines. These might be Dagger Functions developed by your team, your organization or the broader Dagger community.

To make it easier to search and consume Dagger Functions, the [Daggerverse](https://daggerverse.dev) is a free service run by Dagger, which indexes all publicly available Dagger modules and Dagger Functions.
