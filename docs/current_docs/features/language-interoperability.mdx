---
slug: /features/language-interoperability
---

# Language Interoperability

Dagger supports cross-language linking, so you can mix and match Dagger Functions written in different languages without worrying about interoperability. For example, a Python function can call a Go function, which can call a TypeScript function, and so on.

This means that you no longer need to care which language your CI tooling is written in; you can use the one that you're most comfortable with or that best suits your requirements. This feature also immediately unlocks cross-team collaboration: even though different teams might prefer different languages, the Dagger Functions they create are instantly compatible and usable by other teams (or even by the broader Dagger community).

Here's an example, where a Dagger Function written in Python calls both core functions and third-party Dagger Functions written in Go:

```python
@function
async def ci(self, source: dagger.Directory) -> str:
    # Use third-party Golang module to configure project
    go_project = dag.golang().with_project(source)

    # Run Go tests using Golang module
    await go_project.test()

    # Get container with built binaries using Golang module
    image = await go_project.build_container()

    # Push image to a registry using core Dagger API
    ref = await image.publish("ttl.sh/demoapp:1h")

    # Scan image for vulnerabilites using third-party Trivy module
    return await dag.trivy().scan_container(dag.container().from_(ref))
```

Dagger is able to do this because it uses GraphQL as its low-level language-agnostic API query language.  Each Dagger SDK generates native code-bindings for all dependencies, which abstract away the underlying GraphQL queries. An additional bonus of this approach is that it gives you all the benefits of type-checking, code completion and other IDE features when developing Dagger Functions.
