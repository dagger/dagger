---
slug: /features/shell
description: "Iterate faster with familiar Bash-like syntax and autocomplete"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import VideoPlayer from '../../src/components/VideoPlayer';

# Interactive Shell

The Dagger CLI includes an interactive shell that translates the familiar Bash syntax to Dagger API requests.
It's the simplest and fastest way to run Dagger workflows directly from the command-line.

You can use it for builds, tests, ephemeral environments, deployments, or any other task you want to automate from the terminal.

Dagger Shell commands run as sandboxed functions, accessing host resources (files, secrets, services) only when explicitly provided as arguments.
This can make commands slightly more verbose, but also more repeatable, giving you confidence to iterate quickly without second-guessing.

Here's an example of Dagger Shell in action:

```shell
container | from alpine | with-exec apk add curl | with-exec -- curl -L https://dagger.io | stdout
```

<VideoPlayer src="/img/current_docs/features/shell-curl.webm" alt="Dagger Shell" />

Here's another, more complex example:

```shell
container |
  from cgr.dev/chainguard/wolfi-base |
  with-exec apk add go |
  with-directory /src https://github.com/golang/example#master |
  with-workdir /src/hello |
  with-exec -- go build -o hello . |
  file ./hello |
  export ./hello-from-dagger
```

<VideoPlayer src="/img/current_docs/features/shell-build.webm" alt="Shell build example" />

## Bash frontend, Dagger backend

Dagger Shell uses the Bash syntax as a frontend, but its behavior is quite different in the backend:

- Instead of executing UNIX commands, you execute Dagger Functions
- Instead of passing text streams from command to command, you pass typed objects from function to function
- Instead of available commands being the same everywhere in the pipeline, each command is executed in the context of the previous command's output object. For example, `foo | bar` really means `foo().bar()`
- Instead of using the local host as an execution environment, you use containerized runtimes
- Instead of being mixed with regular commands, shell builtins are prefixed with `.` (similar to SQLite)

Besides these differences, all the features of the Bash *syntax* are available in Dagger Shell, including:

- Shell variables: `container=$(container | from alpine)`
- Shell functions: `container() { container | from alpine; }`
- Job control: `frontend | test & backend | test & .wait`
- Quoting: single quotes and double quotes have the same meaning as in bash

## Input modes

Dagger Shell supports multiple ways to input commands:

<Tabs groupId="shell">
<TabItem value="Inline execution">
```shell
dagger -c 'container | from alpine | terminal'
```
</TabItem>
<TabItem value="Standard input">
```shell title="First type 'dagger' for interactive mode."
dagger <<EOF
container | from alpine | terminal
EOF
```
</TabItem>
<TabItem value="Script">
```shell
#!/usr/bin/env dagger

container |
from alpine |
with-exec cat /etc/os-release |
stdout
```
</TabItem>
<TabItem value="Interactive REPL">
```shell title="First type 'dagger' for interactive mode."
container | from alpine | terminal
```
</TabItem>
</Tabs>

## Modules

Dagger Shell can load [Dagger Modules](/features/modules), inspect their types, and run their functions. You can do this by either *executing* modules as functions, or *entering* them as environments.

### Modules as functions

Dagger Shell accepts module addresses as executable functions. For example, the command `github.com/dagger/dagger/docs@v0.18.3 | .help` will:

- Load the module `github.com/dagger/dagger/docs` at version `v0.18.3`
- Execute the module's constructor function, which returns a new instance of the module's main type
- Inspect the returned object and print available functions

When executing a module, you are actually executing the module's constructor function. Therefore, the same rules apply:

- Executing the module constructor does not change the shell's environment. When execution is complete, the current directory and available commands remain the same.
- A module constructor may accept arguments. You can inspect them with `.help <MODULE>`, and pass them with `<MODULE> --foo --bar`
- The returned object may be inspected with `<MODULE> | .help`
- The returned object may be the start of a pipeline: `<MODULE> | foo | bar`
- The returned object may be passed as an argument to another function: `foo --bar=$(<MODULE> | baz)`
- The returned object may be saved to a variable: `foo=$(<MODULE>)`

### Modules as environments

Dagger Shell can enter a module, and use it as a new execution environment, using the builtin command `.cd`. You can think of it as a combination of `cd` and `ssh`.

For example, the command `.cd github.com/dagger/dagger@docs@v0.18.3; .help` will:

- Load the module `github.com/dagger/dagger/docs` at version `v0.18.3`
- Execute the module's constructor function, which returns a new instance of the module's main type
- Inspect the returned object's functions, and add them to the shell's execution context
- Inspect the module's dependencies, and add their constructor to the shell's execution context
- Change the filesystem location to the module's source directory
- Execute `.help` in the new context

<VideoPlayer src="/img/current_docs/features/shell-module.webm" alt="Dagger Shell module loading" />

#### Constructor arguments

`.cd` executes the module constructor without arguments. To pass arguments, you can execute the special command `.` from within the module. For example:

```
# Enter the module
.cd github.com/dagger/dagger/docs
# Show arguments on the current module constructor
.help .
# Execute the constructor with arguments
. --nginx-config=./nginx.conf | server | up
```

If a module has a constructor with required arguments, at the moment it cannot be used as an environment.

## Variables

Dagger Shell lets you save the result of any command to a variable, using the standard bash syntax.
Values of any type can be saved to a variable, including objects.

Here's an example:

<Tabs groupId="shell">
<TabItem value="System shell">
```shell
dagger <<'.'
repo=$(git https://github.com/dagger/hello-dagger | head | tree)
env=$(container | from node:23 | with-directory /app $repo | with-workdir /app)
build=$($env | with-exec npm install | with-exec npm run build | directory ./dist)
container | from nginx | with-directory /usr/share/nginx/html $build | terminal --cmd=/bin/bash
.
```
</TabItem>
<TabItem value="Dagger Shell">
```shell title="First type 'dagger' for interactive mode."
repo=$(git https://github.com/dagger/hello-dagger | head | tree)
env=$(container | from node:23 | with-directory /app $repo | with-workdir /app)
build=$($env | with-exec npm install | with-exec npm run build | directory ./dist)
container | from nginx | with-directory /usr/share/nginx/html $build | terminal --cmd=/bin/bash
```
</TabItem>
</Tabs>

<VideoPlayer src="/img/current_docs/features/shell-variables.webm" alt="Dagger Shell variables" />

## Learn more

- [Call the Dagger API using Dagger Shell](../api/clients-cli.mdx)
- [Chain Dagger Functions using Dagger Shell](../api/chaining.mdx)
