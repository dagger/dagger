---
slug: /integrations/depot
---

# Depot

Depot provides managed, Dagger-powered GitHub Actions runners. These runners, which serve as drop-in replacements for GitHub's own runners, are optimized to make it faster and easier to run Dagger pipelines in GitHub repositories.

## How it works

When running a CI pipeline on a Dagger-powered Depot GitHub Runner, the general workflow looks like this:

1. GitHub emits a repository event which triggers a workflow
1. Depot receives this event, process it, and runs one or more jobs in the workflow, each running in an isolated Depot GitHub Runner.
1. Each Depot GitHub Runner is already connected to an already running Dagger Engine (this exists outside of the Depot GitHub Runner). Previous runs may have cached data in this external Dagger Engine.
1. The "Dagger for GitHub" GitHub Action installs the Dagger CLI, and then calls the specified sub-command, module, function name, and arguments.
1. The Dagger CLI running inside a Depot GitHub Runner gets automatically connected to Dagger Cloud.
1. The Dagger CLI is also configured to connect to the external Dagger Engine which is already
1. The Dagger CLI executes the specified sub-command and sends telemetry to Dagger Cloud.
1. The workflow completes with success or failure. Logs appear in GitHub as usual. They also appear in Dagger Cloud.

## Prerequisites

- A GitHub repository in a GitHub organization
- A Depot account and [organization](https://depot.dev/docs/github-actions/quickstart#create-an-organization)
- The [Depot organization connected to the GitHub organization](https://depot.dev/docs/github-actions/quickstart#connect-to-github)

## Examples

The following example demonstrates how to run a Dagger Function on a Dagger-powered Depot runner in a GitHub Actions workflow.

```yaml title=".github/workflows/dagger.yml" file=./snippets/depot-hello.yml
```

The following is a more complex example demonstrating how to create a GitHub Actions workflow that checks out source code, calls a Dagger Function to test the project, and then calls another Dagger Function to build and publish a container image of the project. This example uses a simple [Go application](https://github.com/kpenfound/greetings-api) and assumes that you have already forked it in your own GitHub repository.

```yaml title=".github/workflows/dagger.yml" file=./snippets/depot-test-build.yml
```

:::warning
Always ensure that the same Dagger versions are specified in the `runs-on` and `version` clauses of the workflow definition.
:::

More information is available in the [Dagger for GitHub page](https://github.com/marketplace/actions/dagger-for-github) and in the [Depot documentation](https://depot.dev/docs/).

#### SSH configuration

When using SSH keys in GitHub Actions, ensure proper SSH agent setup:

```yaml
- name: Set up SSH
  run: |
    eval "$(ssh-agent -s)"
    ssh-add - <<< '${{ secrets.SSH_PRIVATE_KEY }}'
```

Replace `${{ secrets.SSH_PRIVATE_KEY }}` with your provider secret containing the private key.

## Resources

If you have any questions about additional ways to use Depot with Dagger, join our [Discord](https://discord.gg/dagger-io) and ask your questions in our [help channel](https://discord.com/channels/707636530424053791/1030538312508776540).

## About Depot

[Depot](https://depot.dev/) is a build acceleration platform focused on making builds more efficient and performant.
