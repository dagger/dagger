---
title: "Checks"
slug: /features/checks
description: "Validate code quality, security, and standards"
toc_max_heading_level: 2
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Dagger checks are functions that validate commits against quality, security, or standards requirements. A check is a special type of Dagger Function designed to run without arguments, making it perfect for validating any commit—locally before pushing, on every commit in CI, on merge to main, or anywhere else in your development workflow.

Checks provide a simple, unified way to run linters, security scanners, policy validators, and other verification tools. Mark any Dagger Function with the check annotation to make it discoverable and executable via the `dagger check` command. This allows you to centralize all your commit validation logic in one place and run it consistently across local development, CI/CD, and team environments.

## Creating Checks

To create a check, mark a Dagger Function with the check annotation. Checks must not require any arguments—they should validate the current state of the repository when run with no input. However, checks can accept **optional** arguments to customize behavior, such as filtering which tests to run or adjusting validation strictness. This design ensures checks can run automatically in any environment while still being flexible for advanced use cases.

Checks can return an error (for pass/fail validation) or a container (for tools that produce exit codes).

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">
Use the `+check` comment annotation:

```go
// Runs linting checks on the code
// +check
func (m *MyModule) LintCode(ctx context.Context) error {
    _, err := dag.Container().
        From("golangci/golangci-lint:latest").
        WithExec([]string{"golangci-lint", "run"}).
        Sync(ctx)
    return err
}

// Runs security scan with optional severity filter
// +check
func (m *MyModule) SecurityScan(
    ctx context.Context,
    // +optional
    // +default="HIGH,CRITICAL"
    severity string,
) error {
    _, err := dag.Container().
        From("aquasec/trivy:latest").
        WithExec([]string{"trivy", "fs", "--severity", severity, "."}).
        Sync(ctx)
    return err
}
```
</TabItem>
<TabItem value="python" label="Python">
Use the `@check` decorator:

```python
from dagger import dag, check, function, object_type

@object_type
class MyModule:
    @function
    @check
    async def lint_code(self) -> None:
        """Runs linting checks on the code"""
        await dag.container().from_("golangci/golangci-lint:latest").with_exec(["golangci-lint", "run"]).sync()

    @function
    @check
    async def security_scan(self, severity: str = "HIGH,CRITICAL") -> None:
        """Runs security scan with optional severity filter"""
        await dag.container().from_("aquasec/trivy:latest").with_exec(["trivy", "fs", "--severity", severity, "."]).sync()
```
</TabItem>
<TabItem value="typescript" label="TypeScript">
Use the `@check()` decorator:

```typescript
import { dag, object, func, check } from "@dagger.io/dagger";

@object()
class MyModule {
  /**
   * Runs linting checks on the code
   */
  @func()
  @check()
  async lintCode(): Promise<void> {
    await dag
      .container()
      .from("golangci/golangci-lint:latest")
      .withExec(["golangci-lint", "run"])
      .sync();
  }

  /**
   * Runs security scan with optional severity filter
   */
  @func()
  @check()
  async securityScan(severity: string = "HIGH,CRITICAL"): Promise<void> {
    await dag
      .container()
      .from("aquasec/trivy:latest")
      .withExec(["trivy", "fs", "--severity", severity, "."])
      .sync();
  }
}
```
</TabItem>
</Tabs>

## Running Checks

Use the `dagger check` command to run checks:

```shell
# Run all checks
dagger check

# List available checks
dagger check -l

# Run specific checks using glob patterns
dagger check lint-*
dagger check security-scan
```

Checks are automatically executed in parallel for maximum performance. The command exits with a non-zero status if any check fails, making it easy to integrate into CI/CD pipelines or pre-commit hooks.

## Filtering Checks

You can use glob patterns to selectively run checks:

```shell
# Run all lint checks
dagger check lint-*

# Run security-related checks
dagger check security-*

# Run a specific check
dagger check code-style
```

When multiple patterns are provided, checks matching any pattern will run.

## Ignoring Checks

There are two ways to ignore checks, depending on your use case:

### Module-Level Ignore

Ignore checks on your own module by adding `ignoreChecks` to your `dagger.json`:

```json
{
  "name": "my-module",
  "sdk": "go",
  "ignoreChecks": [
    "expensive-check",
    "experimental-*"
  ]
}
```

This is useful when developing toolchain modules where self-checks aren't needed in CI, but the checks should still run when others install your module as a toolchain.

:::important
Module-level `ignoreChecks` only applies to the module itself. When someone installs your module as a toolchain, these patterns are **not** honored—they can configure their own ignore patterns separately.
:::

### Toolchain-Level Ignore

When you install a module as a [toolchain](./toolchains.mdx), you can ignore specific checks from that toolchain:

```json
{
  "name": "my-app",
  "toolchains": [
    {
      "name": "linter",
      "source": "github.com/example/linter",
      "ignoreChecks": [
        "failing-check",
        "beta-*"
      ]
    }
  ]
}
```

Check patterns in toolchain `ignoreChecks` are scoped to that toolchain, so you don't need to include the toolchain name prefix.

### Using Glob Patterns

Both module-level and toolchain-level `ignoreChecks` support glob patterns:

```json
{
  "ignoreChecks": [
    "experimental-*",
    "*-beta",
    "temp-check"
  ]
}
```

Common patterns include:
- `experimental-*` - Exclude all experimental checks
- `*-beta` - Exclude beta checks
- `failing-*` - Temporarily exclude failing checks during migration

### When to Use ignoreChecks

- **Gradual adoption**: Ignore failing checks while updating code to meet new standards
- **Toolchain development**: Disable self-checks in CI when developing toolchain modules
- **Environment-specific checks**: Skip checks that don't apply to certain projects
- **Performance optimization**: Skip expensive checks that aren't critical for your workflow

## Checks from Toolchains

Checks from installed [toolchains](./toolchains.mdx) are automatically available alongside your module's checks. Toolchain checks are namespaced with the toolchain name:

```shell
# List all checks (including toolchain checks)
dagger check -l

# Example output:
# my-check-a
# my-check-b
# linter:code-style
# linter:documentation
# security:scan
```

To run checks from a specific toolchain:

```shell
# Run all checks from the linter toolchain
dagger check linter:*

# Run a specific toolchain check
dagger check linter:code-style
```

This makes it easy to compose validation workflows by installing multiple toolchains that each provide their own checks.

### Use Checks in CI/CD

Integrate checks into your CI/CD pipeline to enforce quality gates:

```yaml
# Example GitHub Actions
- name: Run checks
  run: dagger check
```

Since checks are just Dagger Functions, they run consistently across all environments with full access to Dagger's caching and parallelization capabilities.
