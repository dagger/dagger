---
title: "Toolchains"
slug: /features/toolchains
description: "Install multiple reusable modules as toolchains to extend your workflows"
toc_max_heading_level: 2
---

Dagger toolchains allow you to install and use multiple Dagger modules as composable extensions to your own module. Unlike dependencies or blueprints, toolchains provide a flexible way to combine functionality from multiple modules, making them available as namespaced functions within your module's API.

## Key Concepts

### What are Toolchains?

Toolchains are Dagger modules that are installed into your module to provide additional functionality without needing to integrate with your module's SDK or blueprint. When you install a toolchain:

- The toolchain's functions become available in your module's API as a namespaced field
- Multiple toolchains can be installed simultaneously
- Toolchains work with modules that have an SDK, use a blueprint, or neither
- Each toolchain maintains its own context and can access files from your module's directory

## Use Cases

### Platform Engineering

Toolchains are ideal for platform teams providing standardized tools to application teams:

```shell
# Platform team publishes toolchains
github.com/platform/linter
github.com/platform/security-scanner
github.com/platform/deployer

# App teams install them
dagger toolchain install github.com/platform/linter
dagger toolchain install github.com/platform/security-scanner
dagger toolchain install github.com/platform/deployer

dagger call linter lint
```

Platform teams can include [checks](./checks.mdx) in their toolchains, enabling app teams to run standardized validation with a single command:

```shell
# Run all checks from installed toolchains
dagger check
```

### CI/CD Composition

Build a complete CI/CD pipeline by composing toolchains:

```shell
dagger toolchain install github.com/example/tester
dagger toolchain install github.com/example/builder
dagger toolchain install github.com/example/publisher
dagger toolchain install github.com/example/notifier
```

Run your entire pipeline:

```shell
dagger call tester test && \
dagger call builder build && \
dagger call publisher publish && \
dagger call notifier notify --status success
```

### Polyglot Projects

Use toolchains written in different languages without worrying about compatibility:

```shell
# Go toolchain
dagger toolchain install github.com/example/go-linter

# Python toolchain
dagger toolchain install github.com/example/python-tester

# TypeScript toolchain
dagger toolchain install github.com/example/ts-bundler
```

All toolchains work together seamlessly regardless of their implementation language.


## Installing Toolchains

### Install a Toolchain

To install a toolchain in your module, use the `dagger toolchain install` command:

```shell
dagger toolchain install github.com/example/toolchain
```

You can install toolchains from:
- **GitHub repositories**: `github.com/user/repo/path`
- **Local paths**: `./path/to/toolchain` or `/absolute/path`
- **Git URLs**: Any valid Git URL with optional version tags

### Install with a Custom Name

By default, the toolchain is accessible using its module name. If the module name is not suitable or conflicts with a function in your module, you can specify a custom name:

```shell
dagger toolchain install github.com/example/toolchain --name mytool
```

### Install Multiple Toolchains

You can install as many toolchains as you need:

```shell
dagger toolchain install github.com/example/hello
dagger toolchain install github.com/example/builder
dagger toolchain install github.com/example/tester
```

Each toolchain becomes available under its own namespace in your module's API.

## Using Toolchains

### Calling Toolchain Functions

Once installed, toolchain functions are available through the toolchain's namespace. For example, if you installed a toolchain named `hello`:

```shell
dagger call hello message
```

If the toolchain has a constructor that accepts parameters, you can provide them:

```shell
dagger call hello --config myconfig.txt field-config
```

### Accessing Module Files from Toolchains

Toolchains have access to your module's context directory. This means a toolchain can reference files in your module using default path parameters or explicit file arguments:

```go
// In a toolchain module
func (m *Hello) AppConfig(
    ctx context.Context,
    // +defaultPath="./app-config.txt"
    config *dagger.File,
) (string, error) {
    return config.Contents(ctx)
}
```

When called from your module, `app-config.txt` will be resolved from your module's directory, not the toolchain's repository.

## Toolchains with SDKs

Toolchains work seamlessly with modules that have an SDK. Your module can implement its own functions while also exposing toolchain functions:

### Example: Go Module with Toolchain

Initialize a Go module and install a toolchain:

```shell
dagger init --sdk=go
dagger toolchain install github.com/example/hello
```

Now you can call both your module's functions and the toolchain's functions:

```shell
# Call your module's function
dagger call container-echo --string-arg "hello" stdout

# Call the toolchain's function
dagger call hello message
```

## Toolchains with Blueprints

Toolchains can be combined with blueprints, giving you the best of both worlds: a blueprint provides the core template for your module, while toolchains add supplementary functionality.

```shell
dagger init --blueprint=github.com/example/app-blueprint
dagger toolchain install github.com/example/linter
dagger toolchain install github.com/example/deployer
```

This configuration allows you to:
- Use the blueprint's functions as your module's primary API
- Access additional toolchain functions for auxiliary tasks
- Keep your module focused while still having access to extended functionality

## Toolchains without an SDK

Even if your module doesn't use an SDK or blueprint, toolchains are valuable. They let you compose functionality from multiple modules without writing any code:

```shell
dagger init
dagger toolchain install github.com/example/hello
dagger toolchain install github.com/example/builder
dagger toolchain install github.com/example/tester
```

Your module becomes a collection point for these toolchains, making their combined functionality available through a single interface:

```shell
dagger call hello message
dagger call builder build --source ./app
dagger call tester test --source ./app
```

## Filtering Toolchain Checks

When you install a toolchain that includes checks, all checks from that toolchain are automatically included when you run `dagger check`. However, there may be times when you want to exclude certain checks from a toolchain while keeping others. The `ignoreChecks` configuration allows you to selectively filter out specific checks from a toolchain.

:::tip
Learn more about creating and using checks in the [Checks feature guide](./checks.mdx). This section focuses specifically on filtering checks from installed toolchains.
:::

### Using ignoreChecks

To ignore checks from a toolchain, you can manually edit your `dagger.json` configuration file to add an `ignoreChecks` array to the toolchain configuration:

```json
{
  "name": "my-app",
  "engineVersion": "v0.16.0",
  "toolchains": [
    {
      "name": "linter",
      "source": "github.com/example/linter",
      "ignoreChecks": [
        "failing-check",
        "optional-check"
      ]
    }
  ]
}
```

The check patterns in `ignoreChecks` are scoped to the toolchain, so you don't need to include the toolchain name prefix. For example, if a toolchain named `linter` has a check `linter:code-style`, you would only specify `code-style` in the `ignoreChecks` array.

### Using Glob Patterns

The `ignoreChecks` configuration supports glob patterns, allowing you to ignore multiple checks that match a pattern:

```json
{
  "name": "my-app",
  "engineVersion": "v0.16.0",
  "toolchains": [
    {
      "name": "security-scanner",
      "source": "github.com/example/security",
      "ignoreChecks": [
        "experimental-*",
        "*-beta"
      ]
    }
  ]
}
```

This is useful when you want to:
- Exclude all experimental or beta checks: `experimental-*`, `*-beta`
- Skip checks for specific components: `frontend-*`, `*-integration`
- Ignore checks by category: `style-*`, `performance-*`

### When to Use ignoreChecks

Common use cases for ignoring toolchain checks include:

- **Gradual adoption**: Ignore failing checks while your codebase is being updated to meet new standards
- **Environment-specific checks**: Skip checks that don't apply to certain projects or environments
- **Experimental features**: Exclude experimental or beta checks that may not be stable
- **Performance optimization**: Skip expensive checks that aren't critical for your workflow

### Viewing Active Checks

To see which checks are available after applying `ignoreChecks` filters, use the `dagger check -l` command:

```shell
dagger check -l
```

This will list all checks that will run, excluding any that match your `ignoreChecks` patterns.

## Customizing Toolchains

When you install a toolchain, you can customize how its functions behave in your module by overriding argument defaults. This allows you to adapt toolchains to your specific needs without modifying the toolchain itself.

Any modifications to defaults that can be applied to function arguments can be customized. This includes `default`, `defaultPath`, and `ignore`.

### Configuration Format

Toolchain customizations are configured in your `dagger.json` file using the `customizations` array within each toolchain configuration:

```json
{
  "name": "my-app",
  "engineVersion": "v0.19.4",
  "toolchains": [
    {
      "name": "toolchain-name",
      "source": "github.com/example/toolchain",
      "customizations": [
        {
          "function": ["functionName"],
          "argument": "argumentName",
          "default": "newDefaultValue"
        }
      ]
    }
  ]
}
```

:::note
To override a constructor argument, simply omit the function name.
:::

### Overriding Function Argument Defaults

You can override the default value of any function argument in a toolchain. For example, if a toolchain has a function with a `message` argument that defaults to "hello", you can change it to "hola":

```json
{
  "name": "my-app",
  "engineVersion": "v0.19.4",
  "toolchains": [
    {
      "name": "greeter",
      "source": "github.com/example/greeter",
      "customizations": [
        {
          "function": ["greet"],
          "argument": "message",
          "default": "hola"
        }
      ]
    }
  ]
}
```

### Overriding defaultPath Arguments

Many toolchain functions use `+defaultPath` annotations to automatically load files from your module's directory. You can customize these paths to point to different paths:

```json
{
  "name": "my-app",
  "engineVersion": "v0.19.4",
  "toolchains": [
    {
      "name": "linter",
      "source": "github.com/example/linter",
      "customizations": [
        {
          "argument": "source",
          "defaultPath": "/my-subdirectory"
        }
      ]
    }
  ]
}
```

This is particularly useful when you want to use a different path for specific subprojects.

### Customizing Chained Functions

For toolchains that return objects with their own methods (chained functions), you can specify a function path to target specific arguments:

```json
{
  "name": "my-app",
  "engineVersion": "v0.19.4",
  "toolchains": [
    {
      "name": "deployer",
      "source": "github.com/example/deployer",
      "customizations": [
        {
          "function": ["environment", "deploy"],
          "argument": "region",
          "default": "us-west-2"
        }
      ]
    }
  ]
}
```

This customization applies to the `region` argument of the `deploy` function, which is called on the object returned by the `environment` function:

```shell
# Uses "us-west-2" as the default region
dagger call deployer environment deploy
```

## Best Practices

### Keep Toolchains Focused

Each toolchain should provide a cohesive set of related functions. Instead of creating a monolithic "everything" toolchain, create smaller, focused toolchains that teams can mix and match.

### Namespace Considerations

When naming toolchains (especially with `--name`), choose clear, descriptive names that won't conflict with your module's own functions or other toolchains.

### Use ignoreChecks Sparingly

While `ignoreChecks` provides flexibility, it's generally better to work with toolchain maintainers to address problematic checks at the source. Use `ignoreChecks` as a temporary measure or for legitimate environment-specific filtering, not as a way to permanently suppress important checks.

## Conclusion

Toolchains provide a powerful way to compose and extend Dagger modules. Whether you're building a platform, assembling a CI/CD pipeline, or creating a collection of useful utilities, toolchains give you the flexibility to combine functionality from multiple sources while maintaining clean, organized APIs.
