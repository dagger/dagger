---
slug: /manuals/developer/constructor
displayed_sidebar: "current"
toc_max_heading_level: 2
title: "Module Constructor"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Module Constructor

The main object's constructor is exposed as the entrypoint function for a module. Its parameters are available as flags in the `dagger call` command directly.

This is a simple way to accept module-wide configuration, or just to set a few attributes without having to create setter functions for them.

:::note
Dagger modules have only one constructor. Constructors of [custom types](./custom-types.mdx) are not registered; they are constructed by the function that [chains](./chaining.mdx) them.
:::

Here is an example module with a constructor:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/constructor/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/constructor/python/main.py
```

:::info
In the Python SDK, the [`@dagger.object_type`](https://dagger-io.readthedocs.io/en/latest/module.html#dagger.object_type) decorator wraps [`@dataclasses.dataclass`](https://docs.python.org/3/library/dataclasses.html), which means that an `__init__()` method is automatically generated, with parameters that match the declared class attributes.
:::

The code listing above is an example of an object that has typed attributes.

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/constructor/typescript/index.ts
```

</TabItem>
</Tabs>

Here is an example call for this module:

```shell
dagger call --name=Foo message
```

The result will be:

```shell
Hello, Foo!
```

:::note
If you plan to use constructor fields in other module functions, ensure that they are declared as public (in Go and TypeScript). This is because Dagger stores fields using serialization and private fields are omitted during the serialization process. As a result, if a field is not declared as public, calling methods that use it will produce unexpected results.
:::
