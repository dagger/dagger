---
slug: /manuals/developer/python
displayed_sidebar: "current"
toc_max_heading_level: 2
title: "Python Extras"
---

# Python Extras

This page lists features specific to the Python SDK.

## Name overrides

Sometimes it's possible to get into a situation where the name you want to use
for the Dagger API is reserved or has a naming conflict within Python.

To resolve this, the [`@dagger.function`][@function] decorator and the
[`dagger.field`][dag-field] descriptor have a `name` argument to provide
an alternative name for the Dagger API. And for function arguments,
[annotate][Annotated] with an additional [`dagger.Arg`][dag-arg] metadata.

Here's an example with a renamed object attribute (and constructor argument),
function and function argument:

```python file=./snippets/python/name-overrides/main.py
```

Confirm with `dagger call --help` that the names were overridden:

```
FUNCTIONS
  def           Definition
  import        Import the specified image

ARGUMENTS
      --def string   Definition (default "latest")
```

And the same for the function argument, with `dagger call import --help`:

```
ARGUMENTS
      --from string   Image ref (default "alpine")
```

[@function]: https://dagger-io.readthedocs.io/en/latest/module.html#dagger.function
[dag-field]: https://dagger-io.readthedocs.io/en/latest/module.html#dagger.field
[dag-arg]: https://dagger-io.readthedocs.io/en/latest/module.html#dagger.Arg
[Annotated]: https://docs.python.org/3/library/typing.html#typing.Annotated

## Language dependencies

### Lock file

While Python doesn't have a [lock file standard](https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593/313) yet, other than using a tool that has a proprietary format (like Poetry), the most common way to do it is with a `pip`-compatible format like [`pip-tools`](https://pip-tools.readthedocs.io/en/latest/) uses.

Since the introduction of [uv](./python/820256-module-structure.mdx#uv-installer), dependencies are pinned by default using a `requirements.lock` file. If it exists, the Python SDK will use it directly to install dependencies, resulting in a faster installation.

:::tip
Check [compatibility with `pip` and `pip-tools`](https://github.com/astral-sh/uv/blob/main/PIP_COMPATIBILITY.md) if migrating from or integrating with those tools.
:::

The lock file is only created automatically for new modules. For existing modules that don't have it, it can be created (and updated) manually. For example:

```console
uv pip compile --generate-hashes --update-all -o requirements.lock pyproject.toml sdk/pyproject.toml
```

The above command pulls in dependencies from `pyproject.toml` and `sdk/pyproject.toml`, gets their latest compatible versions, and writes them to `requirements.lock` with added hashes to verify integrity when downloading during install.

:::important
Make sure that `./sdk/pyproject.toml` is up to date first with:

```console
dagger develop
```
:::

:::note
The lock file should only include dependencies, and not the editable installs for the `./sdk` and current module.
:::

#### Poetry's lock file

Dagger doesn't support running the `poetry` CLI. It depends on standards like [PEP 517](./python/820256-module-structure.mdx#modules-as-python-libraries). That means that it doesn't know about the `poetry.lock` file, but the `requirements.lock` file can be generated with [`poetry export`](https://python-poetry.org/docs/cli#export):

```console
poetry export --with dev --without main -o requirements.lock
```

:::important
The `dagger-io` dev dependency is [not exported correctly](https://github.com/python-poetry/poetry-plugin-export/issues/145), so it needs to be removed:

```console
sed -i '' '/dagger-io @/d' requirements.lock
```
:::

## Python debug logs

The Python SDK prints debugging information at various steps of the execution
flow of a module, which can be very useful in understanding what's being
received from and sent to the API.

This is done using standard Python [logging](https://docs.python.org/3/howto/logging.html),
so it's highly configurable (for example, saving to a file or sending to an
external system like Sentry). But for a simple lowering of the default logging
level to [logging.DEBUG](https://docs.python.org/3/library/logging.html#logging.DEBUG),
there's a convenience function for that:

```python file=./snippets/python/debugging/main.py
```

:::note
With the TUI, you need to use a progress output that doesn't collapse on success
like `--progress=plain` or `--debug`, otherwise it won't show in the terminal.
:::

Using the command `dagger call --debug echo --msg="hello"`, should print
something like:

```
✔ MyModule.echo(msg: "hello"): String! 0.5s
  ✔ exec /runtime 0.5s
  ┃ [DEBUG] dagger.client._session: Configuring shared connection to GraphQL server
  ┃ [DEBUG] dagger.client._session: Establishing client session to GraphQL server
  ┃ [DEBUG] dagger.mod._module: invoke => {'parent_name': 'MyModule', 'parent_json': '{}', 'name': 'echo', 'input_args': "{'msg': 'hello'}"}
  ┃ [DEBUG] dagger.mod._module: resolver => MyModule.echo
  ┃ [DEBUG] dagger.mod._resolver: func => <Signature (msg: str) -> str>
  ┃ [DEBUG] dagger.mod._resolver: input args => {'msg': 'hello'}
  ┃ [DEBUG] dagger.mod._resolver: structured args => {'msg': 'hello'}
  ┃ [DEBUG] dagger.mod._module: result => 'hello'
  ┃ [DEBUG] dagger.mod._module: output => '"hello"'
  ┃ [DEBUG] dagger.client._session: Closing client session to GraphQL server
DEBUG: executing query="query{myModule{echo(msg:\"hello\")}}"
```

The above gives a lot of useful information:
- The function and parent object that the API wants to execute
- The parent object's state
- The function's signature
- The user inputs before and after deserialization
- The user inputs after being converted to more complex types (structuring)
- The function's result before and after serialization

Additionally, with `--debug`, the GraphQL query that the Dagger CLI produced is also shown.
