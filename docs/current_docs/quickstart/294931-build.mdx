---
slug: /quickstart/294931/build
hide_table_of_contents: true
title: "Daggerize the application build"
---

# Quickstart

## Daggerize the application build

If your application passes all its tests, the typical next step is to build it. Use the following command to do this using the Golang module:

```shell
dagger -m golang call build --source=. --args=. --os=linux --arch=amd64
```

:::tip
By default, the `build` Dagger Function from the Golang module builds a Go binary based on information derived from the runtime container. Since the runtime container uses Linux, this means that the compiled binary will be a `linux/amd64` binary, which will not work on Windows or macOS operating systems. This can be resolved by passing explicit `--os` and `--arch` arguments to the Dagger Function.
:::

You should see various operations taking place, ending with this output:

```
Directory evaluated. Use "dagger call build --help" to see available sub-commands.
```

This means that the build succeeded, and a directory was returned. This is a just-in-time directory - a transient artifact produced as the result of a Dagger Function. Since Dagger Functions execute within containers spawned by the Dagger Engine, the returned directory also exists in a container, not on the host from where you ran `dagger call`. It must therefore be explicitly transferred or exported from the container's filesystem to the host filesystem before you can use it.


--TODO
Just-in-time artifacts such as containers, directories and files have an `Export()` function, enabling them to be exported to the host filesystem from the Dagger Function that produced them. The destination path on the host is passed to the function using the --path argument.

Here is an example of exporting the directory returned by a Go builder Dagger Function to the ./my-build directory on the host:

# chaining

dagger -m golang call build --source=. --args=. export --path=./build
```
