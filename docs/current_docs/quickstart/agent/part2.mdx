---
slug: /quickstart/agent-part-2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import PartialIde from '../../partials/_ide.mdx';

# Build a Contextual Agent

Now that you've learned the basics of creating an AI Agent with Dagger in [Built an AI Agent](./agent), its time to apply those lessons to a more realistic use case. In this guide, you will build an AI Agent that builds features for an existing project.

For this guide you will start with a Daggerized project. The agent will use the Dagger functions in this project that are already used locally and in CI for testing the project.

## Requirements

- you have [installed the Dagger CLI](../../install.mdx).
- You have [configured](../../configuration/llm.mdx) an LLM provider to use with Dagger
- You have completed the first [AI Agent quickstart](./agent)

## Initialize the example application

FIXME create and clone a repo from the TODO template repository

```shell
TODO: create repo from template
git clone https://github.com/<username>/<new-repo>
```

This example project is a Vue.js project that has already been Daggerized.

Check out the existing Dagger functions:

```shell
dagger functions
```

This should show:

```
Name        Description
build       Build the application container
build-env   Build a ready-to-use development environment
publish     Publish the application container after building and testing it on-the-fly
test        Return the result of running unit tests
```

## Create a workspace for the Agent

To give the agent a specialized set of tools to edit files, create a Dagger submodule called `Workspace`. This module will have functions to read, write, and list files. Modules like this are useful for agents to accomplish tasks like file editing without too much room for error.

<Tabs groupId="language" queryString="sdk">
    <TabItem value="go" label="Go">
        Start by creating the submodule:

        ```shell
        dagger init --sdk go .dagger/workspace
        ```

        Now replace the main file in the workspace with the following content.
        Edit `.dagger/workspace/main.go`:
        ```go file=./snippets/part2/workspace/go/main.go
        ```
    </TabItem>
    <TabItem value="python" label="Python">
        Start by creating the submodule:

        ```shell
        dagger init --sdk python .dagger/workspace
        ```

        Now replace the main file in the workspace with the following content.
        Edit `.dagger/workspace/src/workspace/main.py`:
        ```python file=./snippets/part2/workspace/python/src/workspace/main.py
        ```
    </TabItem>
    <TabItem value="typescript" label="Typescript">
        Start by creating the submodule:

        ```shell
        dagger init --sdk typescript .dagger/workspace
        ```

        Now replace the main file in the workspace with the following content.
        Edit `.dagger/workspace/src/index.ts`:
        ```typescript file=./snippets/part2/workspace/typescript/src/index.ts
        ```
    </TabItem>
    <TabItem value="java" label="Java">
    TODO
    </TabItem>
    <TabItem value="php" label="PHP">
    TODO
    </TabItem>
</Tabs>

Now install the new submodule as a dependency to the main module:

```shell
dagger install ./.dagger/workspace
```

## Create an Agentic function

This agent will be used to make changes to the application and use the existing `Test` function to validate the changes.


<Tabs groupId="language" queryString="sdk">
    <TabItem value="go" label="Go">
        Add the following new function to the main dagger module in `.dagger/main.go`:

        ```go file=./snippets/part2/agent/go/agent.go.snippet
        ```
    </TabItem>
    <TabItem value="python" label="Python">
        Add the following new function to the main dagger module in `.dagger/src/hello_dagger/main.py`:

        ```python file=./snippets/part2/agent/python/agent.py.snippet
        ```
    </TabItem>
    <TabItem value="typescript" label="Typescript">
        Add the following new function to the main dagger module in `.dagger/src/index.ts`:

        ```typescript file=./snippets/part2/agent/typescript/agent.ts.snippet
        ```
    </TabItem>
    <TabItem value="java" label="Java">
    TODO
    </TabItem>
    <TabItem value="php" label="PHP">
    TODO
    </TabItem>
</Tabs>

This new function `Develop` is the new agent. Because you installed the `Workspace` submodule, `Env` has generated functions for `WithWorkspaceInput` and `WithWorkspaceOutput`. Using these, you've created an environment with a `Workspace` input and output.

The `Env` in this agent is privileged, which means the environment will also include the current module and core Dagger APIs. This allows the agent to use the existing `Test` function.

Notice the LLM references a prompt file instead of an inline prompt. The final step is to add this prompt file. Create a file `.dagger/develop_prompt.md` with the following content:

```
You are a developer on the HelloDagger Vue.js project.
You will be given an assignment and the tools to complete the assignment.
Your assignment is: $assignment

## Constraints
- Before writing code, analyze the Workspace to understand the project.
- Do not make unneccessary changes.
- Run tests with the HelloDagger Test tool.
- You must pass the Directory from the Workspace_get_source to the Test tool.
- Always run tests to validate your code changes.
- Do not stop until you have completed the assignment and the tests pass.
```

This prompt is longer and more structured than the prompt from the first quickstart. The tasks the agent will be asked to complete will be more complex because its making modifications to an existing codebase and will need to understand more context. To create a reliable agent that can operate with more complexity, the prompt structure and tools are extremely important.

## Run the agent

Now its time to run the new agent. Enter Dagger shell by running `dagger`, and then:

```shell
develop "make the main page green"
```

If all goes well, the agent will explore the project to find the correct place to make the changes, write the appropriate changes, and then validate them by calling the `Test` function.

If the agent misbehaves, try providing more guidance in the prompt file based on what went wrong.

TODO gif of output

Since the agent returns a `Directory`, we can use Dagger shell to do more things with that `Directory`. First, save the output to a variable:

```shell
completed=$(develop "make the main page green")
```

With that completed assignment in a variable, you can use it just like any other Dagger object in shell:

```shell
# Get a terminal in the build container with the directory
build-env --source $completed | terminal
# Run the app with the updated source code
build --source $completed | as-service | up --ports 8080:80
# Save the changes to your filesystem
$completed | export .
```

## Next steps

TODO
