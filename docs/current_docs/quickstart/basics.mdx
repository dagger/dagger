---
slug: /quickstart/basics
hide_table_of_contents: false
title: "Understand the basics of Dagger"
---

# Quickstart

## Understand the basics of Dagger

Before diving into the code, here is some important information you should know about Dagger.

### What is Dagger?

Dagger is an open source CI/CD engine that runs your pipelines in containers. It lets you replace your software project's artisanal scripts with a modern API and cross-language scripting engine.

- Encapsulate all your project's tasks and workflows into simple Dagger Functions, written in your programming language of choice.
- Run your Dagger Functions from the command line, your language interpreter, or a custom HTTP client.
- Package your Dagger Functions into a module, to reuse in your next project or share with the community.
- Search for existing modules, and import them into yours. All Dagger modules can reuse each other's Dagger Functions - regardless of which language they are written in.

### What problem does Dagger solve?

Application delivery pipelines are a source of pain. The majority of pipelines use messy, hard-to-debug YAML, which is not portable across CI providers, and inconsistent shell scripts, which may not work consistently across environments and platforms. Developers have to "push and pray" - instead of being able to test and build code locally and seeing near-instant feedback from their delivery pipelines, they have to wait (and hope) for a green signal from pipelines running on remote servers.

### How does Dagger solve this problem?

Dagger solves this by running your application delivery pipelines in containers. A "Daggerized" pipeline runs the same way locally or on your CI provider, resulting in faster feedback to the developer and the elimination of last-minute surprises. Dagger also caches everything, which accelerates each pipeline run significantly and often cuts run times by over 50%. And finally, Dagger supports multiple programming languages via native-language SDKs, enabling developers to build their delivery pipelines in the same language as their application and benefit from the ecosystem's existing tooling and best practices.

### Who is Dagger for?

Dagger may be a good fit if you are...

- Your team's "designated devops person", hoping to replace a pile of artisanal scripts with something more powerful.
- A platform engineer writing custom tooling, with the goal of unifying application delivery across organizational silos.
- A cloud-native developer advocate or solutions engineer, looking to demonstrate a complex integration on short notice.

### How does Dagger work?

To use Dagger, you call Dagger Functions. Dagger Functions are regular code, written in a supported programming language, and run in containers. Dagger Functions let you encapsulate common operations or workflows into discrete units with clear inputs and outputs.

Dagger Functions are the fundamental unit of computing in Dagger. Core pipeline operations, such as "pull a container image", "copy a file", "forward a TCP port", are exposed as callable Dagger Functions. Dagger also adds a crucial innovation: instead of calling one Dagger Function at a time, callers can chain multiple Dagger Functions together into a dynamic pipeline, with a single query.

The Dagger Engine provides some core functions, but you are encouraged to write your own and share them with others. Dagger also lets you import and reuse Dagger Functions developed by your team, your organization or the broader Dagger community.

### How are Dagger Functions used and shared?

The simplest and most common way to use Dagger Functions is via the Dagger CLI. The Dagger CLI is a full-featured, easy to use tool that can be used interactively from a terminal or non-interactively from a shell script or a CI configuration. But Dagger Functions can also be called from other Dagger Functions.

Dagger Functions are packaged, shared and reused using modules. The [Daggerverse](https://daggerverse.dev) is a free service run by Dagger, which indexes all publicly available Dagger modules, and lets you easily search and consume them.

Modules don't need to be installed locally. Dagger lets you consume modules from GitHub repositories as well. You call functions from external modules in exactly the same way as you call core functions.
