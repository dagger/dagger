---
slug: /quickstart/build
hide_table_of_contents: true
title: "Daggerize the application's build"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Daggerize the application's build

If your application passes all its tests, the typical next step is to build it. Let's add a new Dagger Function to the module to create a production build of the example application.

<Tabs groupId="language">
<TabItem value="Go">

Update the generated `dagger/main.go` file with the following code:

```go
package main

import (
	"context"
)

type HelloDagger struct{}

// Returns a directory with the production build
func (m *HelloDagger) Build(source *Directory) *Directory {
	return dag.Node(NodeOpts{Version: "21"}).
		WithNpm().
		WithSource(source).
		Install(nil).
		Commands().
		Build().
		Directory("./dist")
}

// Returns the result of running unit tests
func (m *HelloDagger) Test(ctx context.Context, source *Directory) (string, error) {
	return dag.Node(NodeOpts{Version: "21"}).
		WithNpm().
		WithSource(source).
		Install(nil).
		Commands().
		Run([]string{"test:unit", "run"}).
		Stdout(ctx)
}
```

This Dagger Function does many of the same things as the previous one, but with these modifications:

- Instead of calling the `Node.Commands().Run()` function, it calls the `Node.Commands().Build()` function. This function returns a revised `Node` container object after setting the `npm run build` command to run in the container image.
  - The `npm run build` command builds the application and places the build in a `dist/` directory in the container filesystem.
- It uses the `Container.Directory()` method to return the directory to the function caller as Dagger's special `Directory` type. This is called a "just-in-time" directory - a transient artifact produced as the result of a Dagger Function.

</TabItem>
<TabItem value="Python">
FIXME
</TabItem>

<TabItem value="TypeScript">
FIXME
</TabItem>
</Tabs>

Call the Dagger Function:

```shell
dagger call build \
  --source=.
```

You should see various operations taking place, ending with this output:

```
Directory evaluated. Use "dagger call build --help" to see available sub-commands.
```

This means that the build succeeded, and a directory was returned as a `Directory` type.

At this point, the Dagger Function has produced a directory with a production build of the application. However, since Dagger Functions execute within containers spawned by the Dagger Engine, the returned directory is only available in the container, not on the host from where you ran `dagger call`. It must therefore be explicitly transferred or exported from the container to the host before you can use it.

Dagger's core types (`Container`, `Directory`, `Service`, `Secret`, ...) are all objects, each with pre-defined functions of their own. When calling a Dagger Function that returns one of these objects, the Dagger API lets you follow up by calling one of that object's functions, which itself can return another object, and so on. This is called "function chaining", and is a core feature of Dagger.

As an example, when a Dagger Function returns a directory (like in the previous example), the caller typically continues the chain by calling a function exposed by the `Directory` type to perform further processing on it: export it to the local filesystem, modify it, mount it into a container, etc.

All just-in-time artifacts, such as containers, directories and files, have an `export` function, enabling them to be exported to the host filesystem from the Dagger Function that produced them. The destination path on the host is passed to the function using the `--path` argument.

With this knowledge of just-in-time artifacts and function chaining, the next step should be clear:  transfer the directory returned by the Dagger Function from the container to the host, by chaining an `export` function call to it. Use the following command:

```shell
dagger call \
  build --source=. \
  export --path=./build
```

This command exports the directory returned by the `build` Dagger Function to a custom path (`./build`) on the host. Inspect this directory and you should see the production build of the application:

```
$ ls ./build/
assets  favicon.ico  index.html
```

:::tip FUNCTION CHAINING
FIXME
:::
