---
slug: /quickstart/cache
hide_table_of_contents: true
title: "Use caching"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Use caching

One of Dagger's most powerful features is its ability to cache data across Dagger Function runs. This is typically most useful when dealing with package managers such as `npm`, `maven`, `pip` and similar. For these tools to cache properly, they need their own cache data (usually a directory) to be persisted between runs.

:::tip CACHING
Dagger accelerates pipelines significantly, often cutting run times by over 50%. It does this with:

- Aggressive caching: Dagger has two distinct caching mechanisms, a layers cache for build instructions and a volumes cache for filesystem artifacts like data caches or package manager caches. Every operation is cached by default.
- Parallelization: Dagger automatically generates a [Directed Acyclic Graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) to run your pipeline steps concurrently to maximize pipeline speed and accuracy.
:::

Dagger lets you define one or more such directories as cache volumes and persist their contents across runs. This enables you to reuse the contents of the cache volume(s) every time the pipeline runs, and thereby speed up pipeline operations.

:::caution
Cache volumes are not meant to be shared outside of Dagger; they are for persisting specific parts of the internal state of your pipeline, for optimal use of Dagger's caching features.
:::

Remember that when creating the build environment, the Dagger Function executes the `npm install` command to download the application's dependencies. These dependencies are usually locked to specific versions in the application's manifest and don't change frequently. Therefore, re-downloading them on every Dagger Function call is inefficient and time-consuming. That's why it makes sense to add a cache volume for the application dependencies.

<Tabs groupId="language">
<TabItem value="Go">

Look into the `BuildEnv()` Dagger Function to see a cache volume in use:

```go file=./snippets/cache/go/main.go
```

This Dagger Function first uses the `dag.CacheVolume()` method to initialize a new cache volume. Then, it uses the `Container().WithMountedCache()` method to mount this cache volume at the `/src/node_modules/` mount point in the container.

</TabItem>
<TabItem value="Python">

FIXME

</TabItem>
<TabItem value="TypeScript">
```typescript file=./snippets/cache/typescript/index.ts
```

FIXME

</TabItem>
</Tabs>

With the cache volume in play, every time the `npm install` command runs in the container, it finds the application dependencies already stored in the cached volume at the `/src/node_modules/` mount point and does not need to re-download them. This speeds up the pipeline significantly. Since the `/src/node_modules/` directory is defined as a cache volume, its contents will persist even after the pipeline terminates and can be reused on the next pipeline run.

If you run the pipeline a few times (without changing the application code) and time each run, you will notice that subsequent executions are faster:

```shell
dagger call \
  publish --source=.
```
