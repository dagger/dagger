---
slug: /quickstart/package
hide_table_of_contents: true
title: "Daggerize the application's packaging"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Daggerize the application's packaging

At this point, you've written Dagger Functions to test, build and deliver the application to your local host. But why not also package the application and publish a containerized image to a registry?

<Tabs groupId="language">
<TabItem value="Go">

Update the `dagger/main.go` file and create a new Dagger Function to copy the build output directory into an NGINX web server container image.

```go file=./snippets/package/go/main.go
```

This Dagger Function performs the following operations:

- It uses the `dag` client's `Container().From()` method to initialize a new container from a base image - in this case, the `nginx:1.25-alpine` image. The `From()` method returns a new `Container` object representing the container image.
- It uses the `Container().WithDirectory()` method to write the build output directory to the `/usr/share/nginx/html` path in the container and return a revised `Container`. The location of the build output directory is obtained from the `build` argument passed to the Dagger Function.
- It uses the `Container().WithExposedPort()` function to expose port 80 (the default NGINX port in the `nginx:1.25-alpine` image) and return a revised `Container`.

</TabItem>
<TabItem value="Python">

Update the `dagger/src/main/__init__.py` file and create a new Dagger Function to copy the build output directory into an NGINX web server container image.

```python file=./snippets/package/python/__init__.py
```

This Dagger Function performs the following operations:

- It uses the `dag` client's `container().from_()` method to initialize a new container from a base image - in this case, the `nginx:1.25-alpine` image. The `from_()` method returns a new `Container` object representing the container image.
- It uses the `container().with_directory()` method to write the build output directory to the `/usr/share/nginx/html` path in the container and return a revised `Container`. The location of the build output directory is obtained from the `build` argument passed to the Dagger Function.
- It uses the `container().with_exposed_port()` function to expose port 80 (the default NGINX port in the `nginx:1.25-alpine` image) and return a revised `Container`.

</TabItem>
<TabItem value="TypeScript">

Update the `dagger/src/index.ts` file and create a new Dagger Function to copy the build output directory into an NGINX web server container image.

```typescript file=./snippets/package/typescript/index.ts
```

This Dagger Function performs the following operations:

- It uses the `dag` client's `container().from()` method to initialize a new container from a base image - in this case, the `nginx:1.25-alpine` image. The `from()` method returns a new `Container` object representing the container image.
- It uses the `container().withDirectory()` method to write the build output directory to the `/usr/share/nginx/html` path in the container and return a revised `Container`. The location of the build output directory is obtained from the `build` argument passed to the Dagger Function.
- It uses the `container().withExposedPort()` function to expose port 80 (the default NGINX port in the `nginx:1.25-alpine` image) and return a revised `Container`.

</TabItem>
</Tabs>

Call the Dagger Function, passing it the location of the build output directory exported in the previous step:

```shell
dagger call \
  package --build=./build
```

You should see the application being built and the build output added to a container image. Once complete, you should see the following output:

```
Container evaluated. Use "dagger call package --help" to see available sub-commands.
```

This means that the build succeeded, and a `Container` type representing the built container image was returned. And, like `Directory`, `Container` is a Dagger core type which comes with useful functions of its own.

One of the most interesting `Container` functions is `terminal`, which can be used to open an interactive terminal session with the container. To see this in action, revise the previous command and chain an additional function call to `terminal` on the returned `Container`:

```shell
dagger call \
  package --build=./build \
  terminal
```

This revised command builds the container image and then drops you into an interactive terminal, allowing you to directly execute commands in the running container. For example, you can inspect the contents of the container filesystem:

```shell
tree /usr/share/nginx
```

You should see a file listing similar to the following, which should match the contents of the build directory exported in the previous step:

```
/usr/share/nginx
└── html
    ├── 50x.html
    ├── assets
    │   ├── AboutView-C6Dx7pxG.css
    │   ├── AboutView-CEwcYZ3g.js
    │   ├── index-CfPjtpcd.js
    │   └── index-D6pr4OYR.css
    ├── favicon.ico
    └── index.html

2 directories, 7 files
```

:::tip INTERACTIVE CONTAINER DEBUGGING
The `terminal` function is very useful for debugging and experimenting, since it allows you to interact directly with containers and inspect their state, at any stage of your Dagger Function execution.
:::

You can also execute a command in the container. For example, you can start the NGINX service and send an HTTP request for the application's index page with `curl`:

```shell
nginx
curl localhost:80
```

You should receive an HTML page as response:

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
    <script type="module" crossorigin src="/assets/index-CfPjtpcd.js"></script>
    <link rel="stylesheet" crossorigin href="/assets/index-D6pr4OYR.css">
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
```

Exit the interactive terminal once done:

```shell
exit
```

:::caution
While most terminal programs such as `htop` or `vim` work with `dagger call ... terminal`, you may experience visual bugs with some programs due to terminal emulator incompatibilities.
:::

The `Container` type also has a `publish` function, which publishes the container to a registry. To see this in action, go back to the original command and chain an additional function call on the returned `Container`, as shown below:

```shell
dagger call \
  package --build=./build \
  publish --address ttl.sh/hello-dagger-$RANDOM
```

To prevent name collisions, this command suffixes the container image name with a random number. You should the container image being built and published, with the final result being an image reference on the [ttl.sh container registry](https://ttl.sh), as shown below:

```
ttl.sh/hello-dagger-47384@sha256:57c15999fdc59df452161f648aaa9b9a1ea9dbda710a0a0242f509966a286b4b
```

Test the published container image using the command below (update the image name as per the output of the previous Dagger Function call):

```shell
docker run -d --rm --publish 8080:80 ttl.sh/hello-dagger-47384
```

Browse to port 8080 of the Dagger host and confirm that you see a "Hello from Dagger!" welcome page, served by NGINX.

:::tip CONTAINER-FIRST CI PIPELINES
Did you notice that even though you're testing, building and packaging a Node.js application in this quickstart, you didn't need to install any dependencies on your local machine? You only needed the Dagger CLI and the ability to run containers. This is a very powerful feature of Dagger, because it allows development teams to create standardized tooling and eliminates all the variables and dependencies related to the host environment and/or configuration.
:::
