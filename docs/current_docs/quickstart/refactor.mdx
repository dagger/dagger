---
slug: /quickstart/refactor
hide_table_of_contents: true
title: "Refactor the pipeline using a Daggerverse module"
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Refactor the pipeline using a Daggerverse module

FIXME USING NEW NODE MODULE

At this point, you have successfully built a CI pipeline for an application using the Dagger API. This is important knowledge to have, so that you understand the basics of using Dagger and can begin creating CI pipelines for your own applications.

That said, Dagger also lets you use Dagger Functions developed by others. This can save you significant time and effort, because it allows you to reuse functionality developed by others without needing to write any code yourself. You can search for useful Dagger Functions in the [Daggerverse](https://daggerverse.dev), Dagger's free and publicly-available index of Dagger modules.


:::tip THE DAGGERVERSE
Dagger's superpower is its community. All around the world, Daggernauts are encoding their expertise into Dagger Functions, and sharing them for anyone to reuse. The [Daggerverse](https://daggerverse.dev) is a free service run by Dagger, which indexes all publicly available Dagger modules, and lets you easily search and consume them. Using the Daggerverse, you can easily discover great modules being developed by the community, learn how they work, and start using them. Since modules are just source code, it's easy to contribute to them, too!

Using the Daggerverse is optional, and does not change how you use Dagger. If you find a module you like, simply copy its URL, and use it the usual way. Here are a few modules to explore:

- [Scan a container image for vulnerabilities](https://daggerverse.dev/mod/github.com/jpadams/daggerverse/trivy)
- [Stitch videos together](https://daggerverse.dev/mod/github.com/marcosnils/daggerverse/videostitch)
- [Build a Go project](https://daggerverse.dev/mod/github.com/kpenfound/dagger-modules/golang)
- [Generate GIFs of interactive terminal sessions](https://daggerverse.dev/mod/github.com/shykes/daggerverse/termcast)
- [Integrate with Terraform](https://daggerverse.dev/mod/github.com/Excoriate/daggerverse/terraform)
- [Play a game of yamlinvaders](https://daggerverse.dev/mod/github.com/sipsma/daggerverse/yamlinvaders)
:::

To understand how this works in practice, let's refactor the CI pipeline you just built by using a third-party Dagger module. A good candidate here is the [Node module](https://daggerverse.dev/mod/github.com/dagger/dagger/sdk/typescript/dev/node) from the Daggerverse. This module contains tested, ready-to-use Dagger Functions for building, linting and testing Node.js applications.

To install the Node module as a dependency, copy and run the `dagger install` command shown on its [Daggerverse page](https://daggerverse.dev/mod/github.com/dagger/dagger/sdk/typescript/dev/node):

```shell
dagger install github.com/dagger/dagger/sdk/typescript/dev/node@9e59bae142f64975b7c9ad851e6bd4901d43513a
```

Once the command completes, look at the `dagger.json` file again. You should see the newly-added dependency in it, similar to that shown below:

```json
{
  "name": "hello-dagger",
  ...
  "dependencies": [
    {
      "name": "node",
      "source": "github.com/dagger/dagger/sdk/typescript/dev/node@9e59bae142f64975b7c9ad851e6bd4901d43513a"
    }
  ]
}
```

The exact Git commit for the module version is recorded in `dagger.json`. Dagger enforces version pinning, which guarantees that the module version you install is the one you'll be using.

Once you've installed the Node module, start exploring it to see what you can do with it. There are various ways to do this:

- Read the [module's auto-generated documentation](https://daggerverse.dev/mod/github.com/dagger/dagger/sdk/typescript/dev/node@9e59bae142f64975b7c9ad851e6bd4901d43513a) in the Daggerverse.
- Inspect the [module's source code](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts).
- Use the Dagger CLI to inspect the module.

Let's use the `dagger functions` command to inspect the Dagger Functions available in the Node module:

```shell
dagger -m node functions
```

You should see the following output:

```
Name          Description
commands      Execute commands in the container.
container     -
install       Downloads dependencies in the container.
version       -
with-npm      Add npm as package manager in the container.
with-pnpm     Add pnpm as package manager in the container.
with-source   Add source to the module container.
with-yarn     Add yarn as package manager in the container.
```

From the output, you can see that this module includes Dagger Functions to add source code to a container (`with-source`), install dependencies (`install`) and execute commands (`commands`) for a Node.js application.

Take a closer look at the `commands` Dagger Function in the Node module:

```shell
dagger -m node call commands --help
```

You should see the following output (truncated for brevity):

```
Execute commands in the container.
Usage:
  dagger call commands [flags]
  dagger call commands [flags] [command]
Function Commands:
  build
  lint
  run
  test
Global Flags:
...
```

With your knowledge of the Dagger Functions available in the Node module, let's refactor the pipeline to use this module.

<Tabs groupId="language">
<TabItem value="Go">

Update the `dagger/main.go` file with the following code:

```go file=./snippets/refactor/go/main.go
```

This code listing revises the `Test()` and `Build()` Dagger Functions from earlier, replacing calls to the core Dagger API with calls to Dagger Functions from the Node module.

- It calls the Node module's constructor function via the `dag` client. This function returns a `node` container image with the given Node.js version. This container image is represented as a `Node` object.
- It calls the `Node().WithNpm()` function, which returns a revised container after adding the `npm` package manager and a cache volume for `npm`.
- It calls the `Node().WithSource()` function, which returns a revised container with the directory passed to the Dagger Function via the `source` argument mounted in the container filesystem. The `Node().WithSource()` function also creates a cache volume for application dependencies.
- It calls the `Node().Install()` function, which runs `npm install` in the container and returns a revised container with the application's dependencies installed.
- It calls the `Node().Commands().Run()` function with an array of arguments, which returns a revised container configured to execute the `npm run test:unit run` or the `npm run build` command in the container image.
- It uses the `Container().Stdout()` method to return the test results or the `Container().Directory()` method to return the build output directory.
</TabItem>
<TabItem value="Python">

Update the `dagger/src/main/__init__.py` file with the following code:

```python file=./snippets/refactor/python/__init__.py
```

This code listing revises the `test()` and `build()` Dagger Functions from earlier, replacing calls to the core Dagger API with calls to Dagger Functions from the Node module.

- It calls the Node module's constructor function via the `dag` client. This function returns a `node` container image with the given Node.js version. This container image is represented as a `node` object.
- It calls the `node().with_npm()` function, which returns a revised container after adding the `npm` package manager and a cache volume for `npm`.
- It calls the `node().with_source()` function, which returns a revised container with the directory passed to the Dagger Function via the `source` argument mounted in the container filesystem. The `node().with_source()` function also creates a cache volume for application dependencies.
- It calls the `node().install()` function, which runs `npm install` in the container and returns a revised container with the application's dependencies installed.
- It calls the `node().commands().run()` function with an array of arguments, which returns a revised container configured to execute the `npm run test:unit run` or the `npm run build` command in the container image.
- It uses the `container().stdout()` method to return the test results or the `container().directory()` method to return the build output directory.

</TabItem>
<TabItem value="TypeScript">
Update the `dagger/src/index.ts` file with the following code:

```typescript file=./snippets/refactor/typescript/index.ts
```

This code listing revises the `test()` and `build()` Dagger Functions from earlier, replacing calls to the core Dagger API with calls to Dagger Functions from the Node module.

- It calls the Node module's constructor function via the `dag` client. This function returns a `node` container image with the given Node.js version. This container image is represented as a `node` object.
- It calls the `node().withNpm()` function, which returns a revised container after adding the `npm` package manager and a cache volume for `npm`.
- It calls the `node().withSource()` function, which returns a revised container with the directory passed to the Dagger Function via the `source` argument mounted in the container filesystem. The `node().withSource()` function also creates a cache volume for application dependencies.
- It calls the `node().install()` function, which runs `npm install` in the container and returns a revised container with the application's dependencies installed.
- It calls the `node().commands().run()` function with an array of arguments, which returns a revised container configured to execute the `npm run test:unit run` or the `npm run build` command in the container image.
- It uses the `container().stdout()` method to return the test results or the `container().directory()` method to return the build output directory.

</TabItem>
</Tabs>

Let's backtrack a little further and inspect the [Node module's source code](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts) to see what's happening there.

- The first thing to notice is that the Node module is written in TypeScript. However, its functions are being called from your primary Dagger module, which could be written in Go, Python or TypeScript. Dagger takes care of the translation via its language-agnostic GraphQL layer.
- The [Node module's constructor](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L22) uses the `container().from()` method of the Dagger API to initialize a new container from a `node` base image, using the version number passed to it. This method returns a `Container` type representing an OCI-compatible container image.
- The [Node module's `withNpm()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L73) uses the `container().withEntrypoint()` method of the Dagger API to set the container entrypoint to the `npm` CLI and initalizes a cache volume for the `npm` cache using the `container().withMountedCache()` method.
- The [Node module's `withSource()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L34) uses the `container().withDirectory()`, `container().withWorkdir()` and `container().withMountedCache()` methods of the Dagger API to mount the source code directory in the container, set the working directory to that mount point, and create a cache volume for dependencies.
- The [Node module's `install()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L109) uses the `container().withExec()` method to define the command to download dependencies in the container (`npm install`).
- The [Node module's `commands().run()`](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/commands.ts#L13) function accepts an array of command line arguments and readies them for execution in the container, also using the `container().withExec()` method.

Using Dagger Functions from the Node module instead of the core Dagger API offers some advantages:

- The Node module provides tested and ready-to-use functions to select a specific Node version, install a package manager, mount the source code in the correct location in the container, and so on.
- The Node module automatically creates and uses cache volumes for application dependencies.

:::tip UNLOCKING CROSS-LANGUAGE COLLABORATION
Dagger Functions can call other functions, across languages. So, even though the Node module in this quickstart is written in TypeScript, you can transparently call its functions from another Dagger module written in Go, Python or any other supported language. This means that you no longer need to care which language your CI tooling is written in; you can use the one that you're most comfortable with or that best suits your requirements.

Dagger is able to do this because it uses GraphQL as its low-level language-agnostic API query language.  Each Dagger SDK generates native code-bindings for all dependencies, which abstract away the underlying GraphQL queries. This gives you all the benefits of type-checking, code completion and other IDE features when developing Dagger Functions.
:::
