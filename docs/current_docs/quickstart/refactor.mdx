---
slug: /quickstart/refactor
hide_table_of_contents: true
title: "Refactor the pipeline"
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Refactor the pipeline

With your knowledge of the Dagger Functions available in the Node module, let's refactor the pipeline to use this module.

<Tabs groupId="language">
<TabItem value="Go">

Update the generated `dagger/main.go` file with the following code:

```go file=./snippets/refactor/go/main.go
```

This code listing revises the `Test()` and `Build()` Dagger Functions from earlier, replacing calls to the core Dagger API with calls to Dagger Functions from the Node module.

- It calls the Node module's constructor function via the `dag` client. This function returns a `node` container image with the given Node.js version. This container image is represented as a `Node` object.
- It calls the `Node.WithNpm()` function, which returns a revised container after adding the `npm` package manager and a cache volume for `npm`.
- It calls the `Node.WithSource()` function, which returns a revised container with the directory passed to the Dagger Function via the `source` argument mounted in the container filesystem. The `Node.WithSource()` function also creates a cache volume for application dependencies.
- It calls the `Node.Install()` function, which runs `npm install` in the container and returns a revised container with the application's dependencies installed.
- It calls the `Node.Commands().Run()` function with an array of arguments, which returns a revised container configured to execute the `npm run test:unit run` or the `npm run build` command in the container image.
- It uses the `Container().Stdout()` method to return the test results or the `Container().Directory()` method to return the build output directory.
</TabItem>

<TabItem value="Python">
FIXME
</TabItem>
<TabItem value="TypeScript">
FIXME
</TabItem>
</Tabs>

Let's backtrack a little further and inspect the [Node module's source code](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts) to see what's happening there.

- The first thing to notice is that the Node module is written in TypeScript. However, its functions are being called from your primary Dagger module, which could be written in Go, Python or TypeScript. Dagger takes care of the translation via its language-agnostic GraphQL layer.
- The [Node module's constructor](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L22) uses the `container().from()` method of the Dagger API to initialize a new container from a `node` base image, using the version number passed to it. This method returns a `Container` type representing an OCI-compatible container image.
- The [Node module's `withNpm()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L73) uses the `container().withEntrypoint()` method of the Dagger API to set the container entrypoint to the `npm` CLI and initalizes a cache volume for the `npm` cache using the `container().withMountedCache()` method.
- The [Node module's `withSource()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L34) uses the `container().withDirectory()`, `container().withWorkdir()` and `container().withMountedCache()` methods of the Dagger API to mount the source code directory in the container, set the working directory to that mount point, and create a cache volume for dependencies.
- The [Node module's `install()` function](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/index.ts#L109) uses the `container().withExec()` method to define the command to download dependencies in the container (`npm install`).
- The [Node module's `commands().run()`](https://github.com/dagger/dagger/blob/9e59bae142f64975b7c9ad851e6bd4901d43513a/sdk/typescript/dev/node/src/commands.ts#L13) function accepts an array of command line arguments and readies them for execution in the container, also using the `container().withExec()` method.

Using Dagger Functions from the Node module instead of the core Dagger API offers some advantages:
- The Node module provides tested and ready-to-use functions to select a specific Node version, install a package manager, mount the source code in the correct location in the container, and so on.
- The Node module automatically creates and uses cache volumes for application dependencies.

:::tip LANGUAGE-AGNOSTIC TOOLING
Dagger Functions can call other functions, across languages. So, even though the Node module in this quickstart is written in TypeScript, you can transparently call its functions from another Dagger module written in Go, Python or any other supported language. This means that you no longer need to care which language your CI tooling is written in; you can use the one that you're most comfortable with or that best suits your requirements.

Dagger is able to do this because it uses GraphQL as its low-level language-agnostic API query language.  Each Dagger SDK generates native code-bindings for all dependencies, which abstract away the underlying GraphQL queries. This gives you all the benefits of type-checking, code completion and other IDE features when developing Dagger Functions.
:::
