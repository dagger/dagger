---
slug: /quickstart/run
hide_table_of_contents: true
title: "Build and run a pipeline"
displayed_sidebar: "current"
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Build and run a pipeline

The best way to understand how Dagger works is by creating a composable CI pipeline in code for an application - a process we call "Daggerizing".

:::tip DAGGERIZING
1. Choose a Dagger SDK and bootstrap a new Dagger module for your pipeline with `dagger init`.
2. Compose your pipeline by creating and combining one or more Dagger Functions to produce the desired results. Your Dagger Functions can use the core Dagger API and/or call Dagger Functions from third-party Daggerverse modules.
3. Use `dagger call` to run and test your pipeline locally. Once you're satisfied, transfer your Dagger module and your `dagger call` commands to your CI configuration.
:::

Follow the steps below to Daggerize an example application. Don't worry about how it all works for the moment, it's explained in detail over the next few pages!

1. The example application is a skeleton Vue framework application written in TypeScript and modified to return a "Hello from Dagger!" welcome page. Clone it and set it as the current working directory:

    ```shell
    git clone https://github.com/dagger/hello-dagger
    cd hello-dagger
    ```

1. Bootstrap a new Dagger module in Go, Python or TypeScript by running `dagger init` in the application's root directory:

    <Tabs groupId="language">
    <TabItem value="Go">

    ```shell
    dagger init --sdk=go
    ```

    This will generate a `dagger.json` module metadata file, an initial `dagger/main.go` source code template, as well as a `dagger/dagger.gen.go` file and `dagger/internal/` directory.
    </TabItem>
    <TabItem value="Python">

    ```shell
    dagger init --sdk=python
    ```

    This will generate a `dagger.json` module metadata file, initial `dagger/src/main/__init__.py` source code template, `dagger/pyproject.toml` and `dagger/requirements.lock` files, as well as a generated `dagger/sdk` folder for local development.
    </TabItem>
    <TabItem value="TypeScript">

    ```shell
    dagger init --sdk=typescript
    ```

    This will generate a `dagger.json` module metadata file, initial `dagger/src/index.ts` source code template, `dagger/package.json` and `dagger/tsconfig.json` files, as well as a generated `dagger/sdk` folder for local development.
    </TabItem>
    </Tabs>

1. Dagger Functions are regular code, written in Go, Python or TypeScript using the corresponding Dagger SDK. They consist of a series of method/function calls, such as "pull a container image", "copy a file", "forward a TCP port", and so on. These calls are chained together to achieve specific results, such as running tests, building a container image, and so on.

    <Tabs groupId="language">
    <TabItem value="Go">

    Replace the generated `dagger/main.go` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```go file=./snippets/publish/go/main.go
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `Publish()` Dagger Function tests, builds and publishes a container image of the application to a registry. It depends on the `Test()` and `Build()` Dagger Functions.
    - The `Test()` Dagger Function uses the container to run the application's unit tests and returns the results. It depends on the `BuildEnv()` Dagger Function.
    - The `Build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it. It depends on the `BuildEnv()` Dagger Function.
    - The `BuildEnv()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.

    </TabItem>
    <TabItem value="Python">

    Replace the generated `dagger/src/main/__init__.py` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```python file=./snippets/publish/python/__init__.py
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `publish()` Dagger Function tests, builds and publishes a container image of the application to a registry. It depends on the `test()` and `build()` Dagger Functions.
    - The `test()` Dagger Function uses the container to run the application's unit tests and returns the results. It depends on the `build_env()` Dagger Function.
    - The `build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it. It depends on the `build_env()` Dagger Function.
    - The `build_env()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.

    </TabItem>
    <TabItem value="TypeScript">

    Replace the generated `dagger/src/index.ts` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```typescript file=./snippets/publish/typescript/index.ts
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `publish()` Dagger Function tests, builds and publishes a container image of the application to a registry. It depends on the `test()` and `build()` Dagger Functions.
    - The `test()` Dagger Function uses the container to run the application's unit tests and returns the results. It depends on the `buildEnv()` Dagger Function.
    - The `build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it. It depends on the `buildEnv()` Dagger Function.
    - The `buildEnv()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.

    </TabItem>
    </Tabs>

    Dagger Functions can accept arguments, which may be simple string, numeric or Boolean arguments, or more complex Dagger-specific types like `Directory`, `File`, or `Container`. In this listing, each Dagger Function expects a `source` argument of type `Directory`, which tells the Dagger Function where to find the application's source code.

1. Once you've created your Dagger Functions, you can call them with the Dagger CLI. Here are a few examples to try!

    - Test the application, then build and publish it as a container image to the [ttl.sh container registry](https://ttl.sh):

        ```shell
        dagger call \
          publish --source=.
        ```

        When the container image is published, you should see an image reference on the registry:

        ```
        ttl.sh/hello-dagger-47384@sha256:57c15999fdc59df452161f648aaa9b9a1ea9dbda710a0a0242f509966a286b4b
        ```

    - Create a container image with the application's build environment, then open an interactive shell into the running container:

        ```shell
        dagger call \
          build-env --source=. \
          terminal --cmd=bash
        ```

        From this shell, you can inspect and modify the state of the container "live", including running commands to view the contents of the filesystem...

        ```shell
        ls /src
        ```

        ...get operating system details

        ```shell
        uname -a
        ```

        ...list installed Node packages

        ```shell
        npm list
        ```

        ...lint the application code, and so on.

        ```shell
        npm run lint
        ```

    - Build a container image containing the production-ready application and an NGINX service to host it, then test it by running it as a local service:

        ```shell
        dagger call \
          build --source=. \
          as-service \
          up --ports=8080:80
        ```

        Browse to port 8080 of your local machine and confirm that you see a "Hello from Dagger!" welcome page, served by NGINX.

    - Run the application's unit tests:

        ```shell
        dagger call \
          test --source=.
        ```

    - Inspect the module to see available Dagger Functions:

        ```shell
        dagger functions
        ```

:::tip DID YOU NOTICE...
1. Even though you just tested, built and published a Node.js application, you didn't need to install any dependencies like `node` or `npm` on your local machine. You only needed the Dagger CLI and the ability to run containers. This is a very powerful feature that eliminates all the variability and dependencies related to the host environment and/or configuration.
1. Subsequent calls to `dagger call publish...` are significantly faster than the first run. Dagger caches every operation by default and automatically generates a [Directed Acyclic Graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) to run your pipeline steps concurrently to maximize pipeline speed and accuracy.
1. The code used to create a Dagger Function in Go, Python or TypeScript looks remarkably similar, with only minor language-specific changes. Dagger uses GraphQL as its low-level language-agnostic API query language, and each Dagger SDK generates native code-bindings for all dependencies from this API. This gives you all the benefits of type-checking, code completion and other IDE features for your favorite language when developing Dagger Functions.
:::
