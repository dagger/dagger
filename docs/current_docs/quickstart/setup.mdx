---
slug: /quickstart/setup
hide_table_of_contents: true
title: "Set up the example application"
---

# Quickstart

## Set up the example application

The best way to understand how Dagger works is by creating a composable CI pipeline in code for an application - a process we call "Daggerizing".

Daggerizing the CI pipeline for an existing application involves the following steps:

1. Choose a Dagger SDK and bootstrap a new Dagger module for your pipeline with `dagger init`.
2. Find useful third-party Dagger modules from the Daggerverse and install them as dependencies with `dagger install`.
3. Compose your pipeline by combining core Dagger API calls with Dagger Functions from third-party Daggerverse modules to produce the desired results.
4. Use `dagger call` to invoke and test your pipeline locally.
5. Once you're satisfied, transfer your Dagger module and your `dagger call` commands to your CI configuration.

Why do this? By expressing your pipeline as code, you benefit from:
- Easier maintenance, because it encourages you to transform your workflows into structured, discrete and composable units with clear inputs and outputs.
- Higher reliability, because performing pipeline operations in containers removes environment-related variance which can destabilize shell scripts in unexpected ways.
- An improved development experience, because using a programming language opens up access to that language's entire ecosystem, enabling the use of better tooling and adherence to coding standards and best practices.

This tutorial will walk you through these steps by Daggerizing an example application.

Clone the application's source code repository into your local development environment and set it as the current working directory:

```shell
# FIXME: this will eventually be the hello-dagger repository
git clone https://github.com/kpenfound/greetings-api.git hello-dagger
cd hello-dagger
# FIXME: should be removed in the final example app
rm dagger.json
```

:::tip DAGGERIZING
A common question from our Discord is "how much of my pipeline should I Daggerize?". Our advice is to Daggerize as much as you can get away with, within the constraints of your project. In the extreme version of this, you can collapse your entire CI pipeline into a single Dagger Function, which receives a raw source code change event and takes over from there; essentially, your entire CI workflow expressed in code. But typically, you would begin by only Daggerizing simple individual tasks - one Dagger Function per task - and manually configure your CI to call each Dagger Function. This allows for very incremental adoption of Dagger in an existing stack that is hard to change.
:::
