---
slug: /quickstart/speedrun
hide_table_of_contents: false
title: "Speedrun"
displayed_sidebar: "current"
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Speedrun

The best way to understand how Dagger works is by creating a composable CI pipeline in code for an application - a process we call "Daggerizing".

Daggerizing the CI pipeline for an existing application involves the following steps:

1. Choose a Dagger SDK and bootstrap a new Dagger module for your pipeline with `dagger init`.
2. Compose your pipeline by creating and combining one or more Dagger Functions to produce the desired results. Your Dagger Functions can use the core Dagger API and/or call Dagger Functions from third-party Daggerverse modules.
3. Use `dagger call` to run and test your pipeline locally. Once you're satisfied, transfer your Dagger module and your `dagger call` commands to your CI configuration.

Follow the steps below to get a quick taste of Dagger's capabilities, by Daggerizing an example application. Don't worry about how it all works for the moment, it's explained in detail over the next few pages!

1. The example application is a skeleton Vue framework application written in TypeScript and modified to return a "Hello from Dagger!" welcome page. Clone it and set it as the current working directory:

    ```shell
    git clone https://github.com/dagger/hello-dagger
    cd hello-dagger
    ```

1. Bootstrap a new Dagger module in Go, Python or TypeScript by running `dagger init` in the application's root directory:

    <Tabs groupId="language">
    <TabItem value="Go">

    ```shell
    dagger init --sdk=go
    ```

    This will generate a `dagger.json` module metadata file, an initial `dagger/main.go` source code template, as well as a `dagger/dagger.gen.go` file and `dagger/internal/` directory.
    </TabItem>
    <TabItem value="Python">

    ```shell
    dagger init --sdk=python
    ```

    This will generate a `dagger.json` module metadata file, initial `dagger/src/main/__init__.py` source code template, `dagger/pyproject.toml` and `dagger/requirements.lock` files, as well as a generated `dagger/sdk` folder for local development.
    </TabItem>
    <TabItem value="TypeScript">

    ```shell
    dagger init --sdk=typescript
    ```

    This will generate a `dagger.json` module metadata file, initial `dagger/src/index.ts` source code template, `dagger/package.json` and `dagger/tsconfig.json` files, as well as a generated `dagger/sdk` folder for local development.
    </TabItem>
    </Tabs>

1. Dagger Functions are regular code, written in Go, Python or TypeScript using the corresponding Dagger SDK. They consist of a series of method/function calls, such as "pull a container image", "copy a file", "forward a TCP port", and so on. These calls are chained together to achieve specific results, such as running tests, building a container image, and so on.

    <Tabs groupId="language">
    <TabItem value="Go">

    Replace the generated `dagger/main.go` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```go file=./snippets/cache/go/main.go
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `BuildEnv()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.
    - The `Test()` Dagger Function uses the container to run the application's unit tests and returns the results.
    - The `Build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it.
    - The `Publish()` Dagger Function combines the previous three Dagger Functions into a single pipeline and publishes the final container image to a registry.

    </TabItem>
    <TabItem value="Python">

    Replace the generated `dagger/src/main/__init__.py` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```python file=./snippets/cache/python/__init__.py
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `build_env()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.
    - The `test()` Dagger Function uses the container to run the application's unit tests and returns the results.
    - The `build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it.
    - The `publish()` Dagger Function combines the previous three Dagger Functions into a single pipeline and publishes the final container image to a registry.

    </TabItem>
    <TabItem value="TypeScript">

    Replace the generated `dagger/src/index.ts` file with the following code, which adds four Dagger Functions to your Dagger module:

    ```typescript file=./snippets/cache/typescript/index.ts
    ```

    In this Dagger module, each Dagger Function performs a different operation:

    - The `buildEnv()` Dagger Function creates a container with the build environment for the application, including all required tooling and dependencies.
    - The `test()` Dagger Function uses the container to run the application's unit tests and returns the results.
    - The `build()` Dagger Function uses the container to perform a multi-stage build and returns a final container image with the production-ready application and an NGINX Web server to host and serve it.
    - The `Publish()` Dagger Function combines the previous three Dagger Functions into a single pipeline and publishes the final container image to a registry.

    </TabItem>
    </Tabs>

    Dagger Functions can accept arguments, which may be simple string, numeric or Boolean arguments, or more complex Dagger-specific types like `Directory`, `File`, or `Container`. In this listing, each Dagger Function expects a `source` argument of type `Directory`, which tells the Dagger Function where to find the application's source code.

1. Once you've created your Dagger Functions, you can call them with the Dagger CLI. Here are a few examples to try!

    - Test the application, then build and publish it as a container image to the [ttl.sh container registry](https://ttl.sh):

        ```shell
        dagger call \
          publish --source=.
        ```

        When the container image is published, you should see an image reference on the [ttl.sh container registry](https://ttl.sh):

        ```
        ttl.sh/hello-dagger-47384@sha256:57c15999fdc59df452161f648aaa9b9a1ea9dbda710a0a0242f509966a286b4b
        ```

    - Create a container image with the application's build environment, then open an interactive shell into the running container:

        ```shell
        dagger call \
          build-env --source=. \
          terminal --cmd=bash
        ```

        From this shell, you can inspect and modify the state of the container "live", including viewing the filesystem...

        ```shell
        ls /src
        ```

        ...and running commands.

        ```shell
        npm run lint && npm run test:unit run
        ```

    - Build a container image containing the production-ready application and an NGINX service to host it, then test it by running it as a local service:

        ```shell
        dagger call \
          build --source=. \
          as-service \
          up
        ```

        Browse to port 8080 of your local machine and confirm that you see a "Hello from Dagger!" welcome page, served by NGINX.

:::tip DID YOU NOTICE...
1. Even though you just tested, built and published a Node.js application, you didn't need to install any dependencies like `node` or `npm` on your local machine. You only needed the Dagger CLI and the ability to run containers. This is a very powerful feature that eliminates all the variability and dependencies related to the host environment and/or configuration.
1. Subsequent calls to `dagger call publish...` are significantly faster than the first run. Dagger caches every operation by default and automatically generates a [Directed Acyclic Graph (DAG)](https://en.wikipedia.org/wiki/Directed_acyclic_graph) to run your pipeline steps concurrently to maximize pipeline speed and accuracy.
1. The Dagger SDK code used to create a Dagger Function in Go, Python or TypeScript looks remarkably similar, with only minor language-specific changes. Dagger uses GraphQL as its low-level language-agnostic API query language, and each Dagger SDK generates native code-bindings for all dependencies from this API. This gives you all the benefits of type-checking, code completion and other IDE features for your favorite language when developing Dagger Functions.
:::
