---
slug: /quickstart/test-build
hide_table_of_contents: true
title: "Daggerize the test and build stages"
---
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

## Daggerize the test and build steps

Once you have the build environment in place, you can use it for the next stages of the pipeline: test and build. Let's look into that next!

<Tabs groupId="language">
<TabItem value="Go">

The `Test()` and `Build()` Dagger Functions use the build environment container returned the `BuildEnv()` Dagger Function, but for different purposes. Let's look at `Test()` first.

```go file=./snippets/test/go/main.go
```

The `Test()` Dagger Function works merely as a CLI wrapper around the `npm run test:unit run` command.
- It first calls `BuildEnv()` to obtain the build environment container.
- It then uses the `Container().WithExec()` method to set this command to run in the container, and the `Container().Stdout()` method to capture and return the output as a string.
</TabItem>
<TabItem value="Python">

FIXME

</TabItem>
<TabItem value="TypeScript">

FIXME

</TabItem>
</Tabs>

Call it with the Dagger CLI:

```shell
dagger call \
  test --source=.
```

You should see various operations taking place, ending with a test run and the following output:

```
> hello-dagger@0.0.0 test:unit
> vitest run

 RUN  v1.5.3 /src

 âœ“ src/components/__tests__/HelloWorld.spec.ts  (1 test) 28ms

 Test Files  1 passed (1)
      Tests  1 passed (1)
   Start at  12:30:25
   Duration  9.93s (transform 436ms, setup 1ms, collect 436ms, tests 28ms, environment 8.46s, prepare 724ms)
```

<Tabs groupId="language">
<TabItem value="Go">

The `Build()` Dagger Function builds a production-ready container with the application and an NGINX server to host it.

```go file=./snippets/build/go/main.go
```

This Dagger Function performs a multi-stage build, as follows:
- It first calls `BuildEnv()` to obtain the build environment container.
- It uses the `Container().WithExec()` method to run the `npm run build` command in the container. This creates a compressed, production-ready build of the application and places the result in a `dist/` directory in the container filesystem.
- It uses the `Container().Directory()` method to return the `dist/` directory as Dagger's special `Directory` type.
- It uses the `dag` client's `Container().From()` method to initialize a new container from a base image - in this case, the `nginx:1.25-alpine` image. The `From()` method returns a new `Container` object representing the container image.
- It uses the `Container().WithDirectory()` method to copy the `dist/` directory to the NGINX Web server root directory `/usr/share/nginx/html` in the container.
- It uses the `Container().WithExposedPort()` function to expose port 80 (the default NGINX port in the `nginx:1.25-alpine` image).
</TabItem>
<TabItem value="Python">

FIXME

</TabItem>
<TabItem value="TypeScript">

FIXME

</TabItem>
</Tabs>

The result of this Dagger Function is a `Container` representing the final production build of the application. This is an `nginx:1.25-alpine` container image with an NGINX Web server ready to host and serve the built application.

Since the return value is a just-in-time `Container`, you can use your knowledge of function chaining and just-in-time artifacts to inspect it "live" with the `terminal` function, as you did earlier. But this is a good place to explore another interesting built-in `Container` function: the `as-service` function.

The `as-service` function can be used to [start a just-in-time container as a local service in your local environment](../manuals/user/artifacts/consumption/384829-services.mdx) and have any exposed ports forwarded to the host machine. This has many potential use cases, such as manually testing web applications or database services directly from the host browser or host system.

To see this in action, chain additional function calls to `as-service` and `up` on the returned `Container`:

```shell
dagger call \
  build --source=. \
  as-service \
  up --ports=8080:80
```

By default, Dagger will map each exposed container service port to the same port on the host. Since NGINX operates on port 80, which is often a privileged port on the host, the additional `--ports 8080:80` argument re-maps container port 80 to unprivileged host port 8080.

You should now be able to access the application by browsing to `http://localhost:8080` on the Dagger host (replace `localhost` with your Dagger host's network name or IP address if accessing it remotely). You should see a "Hello from Dagger!" welcome page, served by NGINX.

:::tip FUNCTION CHAINING
[Function chaining](../manuals/user/functions/539201-chaining.mdx) works the same way, whether you're writing Dagger Function code using a Dagger SDK or invoking a Dagger Function using the Dagger CLI. The following are equivalent:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/chain/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/chain/python/__init__.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/chain/typescript/index.ts
```

</TabItem>
<TabItem value="Dagger CLI">
```shell
dagger call foo --address="ttl.sh/bar"
```

```shell
dagger call bar
```
</TabItem>
</Tabs>
:::
