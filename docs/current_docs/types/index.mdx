---
slug: /types
title: "Types"
description: "Dagger modules are the building blocks of your workflows. They can be composed together to create complex pipelines."
sidebar_label: "Overview"
---

In addition to basic types (string, boolean, integer, arrays...), the Dagger API also provides powerful core types which serve as both arguments and return values for Dagger Functions.

:::note
The types listed on this page are indicative and not exhaustive. For a complete list of supported types and their fields, refer to the [Dagger API reference](https://docs.dagger.io/api/reference).
:::

## Core types

The following table lists available types and what they represent:

| Type | Description |
|------|-------------|
| `CacheVolume` | A directory whose contents persist across runs |
| [`Container`](container.mdx) | An OCI-compatible container |
| `CurrentModule` | The current Dagger module and its context |
| `Engine` | The Dagger Engine configuration and state |
| [`Directory`](directory.mdx) | A directory (local path or Git reference) |
| `EnvVariable` | An environment variable name and value |
| [`Env`](env.mdx) | An environment variable name and value |
| [`File`](file.mdx) | A file |
| `GitRepository` | A Git repository |
| `GitRef` | A Git reference (tag, branch, or commit) |
| `Host` | The Dagger host environment |
| [`LLM`](llm.mdx) | A Large Language Model (LLM) |
| `Module` | A Dagger module |
| `Port` | A port exposed by a container |
| [`Secret`](secret.mdx) | A secret credential like a password, access token or key) |
| [`Service`](service.mdx) | A content-addressed service providing TCP connectivity |
| `Socket` | A Unix or TCP/IP socket that can be mounted into a container |
| `Terminal` | An interactive terminal session |

Each type exposes additional fields. Some of these are discussed on their respective pages.

## Dagger modules

When you work with a Dagger workflow, you are using types that are comprised of one or more Dagger modules. A Dagger module is a collection of reusable code that can be shared and used across different workflows. Modules allow you to encapsulate functionality, making it easier to manage and maintain your code.

:::tip
In addition to the default Dagger types, you can create and add your own custom types to Dagger. These custom types can be used in Dagger modules and can be composed with other types to create complex workflows.

Learn more about creating custom types and developing Dagger modules in [Extending Dagger](../extending/index.mdx).
:::

As part of developing a Dagger module, you group your code into Dagger Functions. A Dagger Function is a piece of code that can be executed by the Dagger Engine, and it can return a value or perform an action (e.g creating and returning a base container, or publishing a container to a registry).

The recommended, and most common way, to interact with the Dagger API is through Dagger Functions. Dagger Functions are just regular code, written in your usual language using a type-safe Dagger SDK.

Dagger Functions are packaged, shared and reused using Dagger modules. A new Dagger module is initialized by calling `dagger init`. This creates a new `dagger.json` configuration file in the current working directory, together with sample Dagger Function source code. The configuration file will default the name of the module to the current directory name, unless an alternative is specified with the `--name` argument.

Once a module is initialized, `dagger develop --sdk=...` sets up or updates all the resources needed to develop the module locally using a Dagger SDK. By default, the module source code will be stored in the current working directory, unless an alternative is specified with the `--source` argument.

Here is an example of initializing a Dagger module:

<Tabs groupId="language" queryString="sdk">
<TabItem value="go" label="Go">
```shell
dagger init --name=my-module
dagger develop --sdk=go
```
</TabItem>
<TabItem value="python" label="Python">
```shell
dagger init --name=my-module
dagger develop --sdk=python
```
</TabItem>
<TabItem value="typescript" label="TypeScript">
```shell
dagger init --name=my-module
dagger develop --sdk=typescript
```
</TabItem>
<TabItem value="php" label="PHP">
```shell
dagger init --name=my-module
dagger develop --sdk=php
```
</TabItem>
<TabItem value="java" label="Java">
```shell
dagger init --name=my-module
dagger develop --sdk=java
```
</TabItem>
</Tabs>

:::warning
Running `dagger develop` regenerates the module's code based on dependencies, the current state of the module, and the current Dagger API version. This can result in unexpected results if there are significant changes between the previous and latest installed Dagger API versions. Always refer to the [changelog](https://github.com/dagger/dagger/blob/main/CHANGELOG.md) for a complete list of changes (including breaking changes) in each Dagger release before running `dagger develop`, or use the `--compat=skip` option to bypass updating the Dagger API version.
:::
