---
slug: /developer-guide/typescript/582020/conventions
displayed_sidebar: 'zenith'
toc_max_heading_level: 2
title: 'Conventions'
---

import PartialExperimentalDocs from '../../partials/_experimental.mdx';

# Conventions

<PartialExperimentalDocs />

## Decorators

A module's main functions is declared as methods of a class (decorated with `@object()`) having the same name as the module (in PascalCase).

Every objects, functions (decorated with `@func()`) and fields (decorated with `field()`) with a decorator are exposed through the Dagger API to the user.

Here is an example of a module that exposes a function `alpine` that returns an object `Alpine` with the method `echo` and the field `ctr`:

```typescript file=./snippets/conventions/decorators/index.ts

```

And here is an example of call to this module:

```shell
dagger call alpine echo --msg "hello","world"
```

The reult will be:

```shell
hello world
```

But you could also directly query the field `ctr` to chain operations:

```shell
/opt/homebrew/bin/dagger call alpine ctr with-exec --args "echo","hello","world" stdout
```

This will output the same result as before:

```shell
hello world
```

## Default value for complex type

You might create a module that depends on some Dagger object such as `Container` and want to add a default value on
one of your field or function's arugment. In that case, you cannot use the classic TypeScript notation for default
argument in the field because it is not a primitive type.
The correct way to define a default object type as function argument is to use the `??` notation.

Here's is an example of a module with a default argument `ctr` of type `Container`:

```typescript file=./snippets/conventions/default-object-in-constructor/index.ts

```

You can also define a default value directly in the field:

```typescript file=./snippets/conventions/default-object-in-field/index.ts

```

:::note
You need to explicly declare the type even if you have a default value, the TypeScript SDK needs it to extend the GraphQL schema correctly.
:::

Here's an example of call for these modules:

```shell
dagger call version
```

And the result will be:

```shell
VERSION_ID=3.14.0
```

## Fields exposition

TypeScript has some keywords to handle fields exposition in class (`private`, `protected` and `public`).
However, Dagger will only expose the fields of a modude that are explicitely exposed using the `@field()` decorators, the rest
will stay private in the context of your class.
Note that even if it's private, their state will still be loaded so you can use these fields without exposing them.

Here's an example of a module `Person` that has multiple properties not exposed outside the module and a function `identity` that use the `crypto` library to hash these:

```typescript file=./snippets/conventions/fields-exposition/index.ts

```

If we execute `dagger functions`, we can see that `age` and `job` are not exposed:

```shell
dagger functions
Name       Description
identity   Get the identity of the person based on its personal information.
name       Get the name of the person
```

Here is an example of call to this module:

```shell
dagger call --name="john" --age=23 --job="devops"  identity
```

And the result is:

```shell
c11fb2dc1c5bfe34b0ed5737b8c58914ddb56a83602ead3eff2f06e46efc4a24
```
