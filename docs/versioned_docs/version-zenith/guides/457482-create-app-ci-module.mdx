---
slug: /guides/457482/create-app-ci-module
displayed_sidebar: "zenith"
toc_max_heading_level: 2
authors: ["Erik Sipsma", "Vikram Vaswani"]
date: "2024-02-06"
---

import PartialExperimentalDocs from '../partials/_experimental.mdx';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Standardize Your Application's CI Functions as a Dagger Module

<PartialExperimentalDocs />

## Introduction

Dagger lets you encapsulate all your project's CI tasks and workflows into functions, written in your programming language of choice, and then call those functions, either locally from your development environment or remotely on your CI provider.

This gives teams standard, consistent tooling with reduced host environment requirements; you only need the Dagger CLI and the ability to run containers (no local dependencies like Golang, Python, Node, etc). Local and remote CI environments achieve parity; developers can run CI test, build and deployment pipelines locally and see the results almost instantly, and there are fewer surprises when pushing final code. A standard, cross-language toolkit enables new team members to become productive faster and reduce friction in cross-team collaboration.

This guide walks you through the process of creating a Dagger module encapsulating common CI functions for an application: testing, building, and publishing it. You will learn how to:

- Initialize a new Dagger module as part of your application codebase
- Import modules from the Daggerverse to benefit from pre-packaged functionality
- Connect imported modules with your own Dagger functions
- Call Dagger functions to test, build, publish and run your application locally
- Understand how to work with containers as function input arguments and return values

## Requirements

This guide assumes that:

- You know the basics of calling and writing Dagger modules. If not, refer to the [quickstart](../quickstart/index.mdx).
- You have the Dagger CLI installed in your development environment. If not, [install the Dagger CLI](../329058-install.mdx).
- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).
- You have a Node.js Web application. If not, follow the steps in Appendix A to [create an example Node.js application](#appendix-a-create-an-example-application).

## Step 1: Initialize a new module

The example module used in this guide builds, tests and publishes a Node.js application.

Within your application directory, create a new `ci/` directory:

```shell
mkdir ci && cd ci
```

Run `dagger mod init` in the `ci` directory to bootstrap a new module:

<Tabs groupId="language">
<TabItem value="Go">

```sh
dagger mod init --name=my-module --sdk=go
```

This will generate a `dagger.json` module file, an initial `main.go` source file, as well as a generated `dagger.gen.go` and `querybuilder` directory for the generated module code.

</TabItem>
<TabItem value="Python">

```sh
dagger mod init --name=my-module --sdk=python
```

This will generate a `dagger.json` module file, initial `src/main.py` and `pyproject.toml` files, as well as a generated `sdk` folder for local development.

</TabItem>
<TabItem value="TypeScript">

```sh
dagger mod init --name=my-module --sdk=typescript
```

This will generate a `dagger.json` module file, initial `src/index.ts`, `package.json` and `tsconfig.json` files, as well as a generated `sdk` folder for local development.

</TabItem>
</Tabs>

## Step 2: Add a function to build the application base image

The first step is to add a function to build a base image containing the application source code and runtime. This base image will serve as an input to other functions.

Since the application is a Node.js application, it's convenient to use the [`node` module](https://github.com/quartz-technology/daggerverse/node), which provides a set of ready-made functions to manage a Node.js project.

:::note
Dagger exposes every module using a language-agnostic HTTP API. So, even though the [`node` module](https://github.com/quartz-technology/daggerverse/node) is written in TypeScript, you can transparently call its functions from your module written in Go, Python or any other supported language.
:::

First, add the `node` module as a dependency:

```shell
dagger mod install github.com/quartz-technology/daggerverse/node/typescript
```

<Tabs groupId="language">
<TabItem value="Go">

Next, update the generated `main.go` file with the following code:

```go file=./snippets/create-app-ci-module/base/go/main.go
```

</TabItem>
<TabItem value="Python">

Next, update the generated `src/main.py` file with the following code:

```python file=./snippets/create-app-ci-module/base/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

Next, update the generated `src/index.ts` file with the following code:

```typescript file=./snippets/create-app-ci-module/base/typescript/index.ts
```

</TabItem>
</Tabs>

This function does the following:

  - It calls the `node` module's `WithVersion()` API via the `dag` client. This API method returns a `node` container image with the given Node.js version. This container image is represented as a `Node` object.
  - It calls the `Node.WithNpm()` API, which returns a revised `Node` object after adding the `npm` package manager and a cache volume for `npm`.
  - It calls the `Node.WithSource()` API, which returns a revised `Node` object including the application source code mounted in the container filesystem and a cache volume for Node.js modules.
    - The `Node.WithSource()` API accepts a `Directory` representing the application source code directory. This directory path will be passed as a command-line flag when calling the function using the CLI.
    - Since this directory path will be required by multiple functions, it's convenient to specify it once as a field (`source`) in the module constructor and then access its value from other functions.
  - It calls the `Node.Install()` API, which runs `npm install` in the container and returns a revised `Node` object including the application's dependencies.
  - It calls the `Node.Container()` API, which returns a `Container` representing the final container image with the application source code, Node.js runtime and cache volume.

:::note
`dag` is the Dagger client, which is pre-initialized. It contains all the core types (like `Container`, `Directory`, etc.), as well as bindings to any dependencies your module has declared (like `node`).
:::

## Step 3: Add a function to test the application

The return value of the `BuildBaseImage()` API is a `Container` object with the application source code, Node.js runtime and cache volume. This is everything needed to test, build and publish the application.

Add a new function that runs tests for the example application, by executing the `test:unit run` command:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/create-app-ci-module/test/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/create-app-ci-module/test/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/create-app-ci-module/test/typescript/index.ts
```

</TabItem>
</Tabs>

This function does the following:

- It calls the `node` module's `WithContainer()` API via the `dag` client and passes it the container returned by the `BuildBaseImage()` API. The `Node.WithContainer()` API returns a `Node` object.
- It calls the `Node.Run()` API, which returns a revised `Node` object after setting the commands to run in the container image - in this case, the command `npm run test:unit run`.
- It uses the `Container.Stdout()` API to return the output of the last executed command. If tests pass, the output shows the list of passed tests. If not, a non-nil error is returned, which propagates to the Dagger CLI and lets it know that one or more tests failed.

Try the function by running it as below:

```shell
dagger -m ci call --source=. test
```

:::note
For security, Dagger modules do not have access to the host and so, host resources such as directories, files, environment variables, services and so on must be explicitly passed using command-line arguments.
:::

Here's an example of the output you will see:

```shell
✔ dagger call test [1m14.2s]
┃
┃ > myapp@0.0.0 test:unit
┃ > vitest run
┃
┃  RUN  v1.1.0 /src
┃
┃  ✓ src/components/__tests__/HelloWorld.spec.ts  (1 test) 65ms
┃
┃  Test Files  1 passed (1)
┃       Tests  1 passed (1)
┃    Start at  15:46:12
┃    Duration  8.85s (transform 751ms, setup 0ms, collect 1.04s, tests 65ms, environment 4.51s, prepare 1.19s)
```

## Step 4: Add a function to build the application

If your application passes all its tests, the typical next step is to build it.

Add a new function that creates a production build of the example application:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/create-app-ci-module/build/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/create-app-ci-module/build/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/create-app-ci-module/build/typescript/index.ts
```

</TabItem>
</Tabs>

This function does the following:

- It calls the `node` module's `WithContainer()` API via the `dag` client and passes it the container returned by the `BuildBaseImage()` module API. The `Node.WithContainer()` API returns a `Node` object.
- It calls the `Node.Build()` API, which returns a revised `Node` object after setting the `npm run build` command to run in the container image. This command builds the application and places the build in a `dist/` directory in the container filesystem.
- It obtains a reference to the `dist/` directory in the container with the `Container.Directory()` API. This function returns a `Directory` object.

:::note
The `npm run build` command is appropriate for the example Vue application used in this guide, but other applications may use different commands. Modify your function code accordingly.
:::

Try the function by running it as below. Note the additional chained call to `Directory.Entries()` on the function's `Directory` return value, to display a file listing for the build directory.

```shell
dagger -m ci call --source=. build entries
```

Here's an example of the output you will see:

```shell
✔ dagger call build [1m32.7s]
┃ assets
┃ favicon.ico
┃ index.html
```

## Step 5: Add a function to publish the application image

At this point, your Dagger module has functions to test and build the application. However, the Dagger API and SDKs also have native support to publish container images to remote registries.

Update the module and add new functions to copy the built application into an NGINX web server container image and deliver the result to [ttl.sh](https://ttl.sh), an ephemeral Docker registry:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/create-app-ci-module/publish/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/create-app-ci-module/publish/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/create-app-ci-module/publish/typescript/index.ts
```

</TabItem>
</Tabs>

This code listing adds two functions:

- The `Package()` API calls the `Container().From()` API to initialize a new container from a base image - here, the `nginx:1.25-alpine` image.The `From()` API returns a new `Container` object with the result.
    - It uses the `Container.WithDirectory()` API to write the `Directory` returned by the `Build()` API to the `/usr/share/nginx/html` path in the container and return a revised `Container`.
    - It uses the `Container.WithExposedPort()` API to expose port 80 (the default NGINX port in the `nginx:1.25-alpine` image) and return a revised `Container`.
- The `Publish()` API calls the `Package()` API to obtain the container image and then calls the built-in `Container.Publish()` API to publish it to the [ttl.sh](https://ttl.sh) registry and return the image identifier.

Try the function by running the command below:

```shell
dagger -m ci call --source=. publish
```

Here's an example of the output you will see:

```shell
✔ dagger call publish [5m32.6s]
┃ ttl.sh/myapp-6263158:10m@sha256:802f4edeb30b47b5ab4c52d8cccd9d18dd9f4c0d6a0a6b8015926d0290312bb0
```

## Step 6: Add a function to run the application as a local service

Dagger functions can return services as well as containers. These services can then be started in your local environment and have any exposed ports forwarded to the host machine. This has many potential use cases, such as manually testing web applications or database services directly from the host browser or host system.

In order for this to work, the container image used by the service must have one or more exposed ports defined. This is already implemented in the functions shown in the previous section. So, update the module and add a new function to return the built container image as a service:

<Tabs groupId="language">
<TabItem value="Go">

```go file=./snippets/create-app-ci-module/serve/go/main.go
```

</TabItem>
<TabItem value="Python">

```python file=./snippets/create-app-ci-module/serve/python/main.py
```

</TabItem>
<TabItem value="TypeScript">

```typescript file=./snippets/create-app-ci-module/serve/typescript/index.ts
```

</TabItem>
</Tabs>

This function simply calls the `Package()` API created earlier to obtain the container image and then returns it as a service using the `Container.AsService()` API.

Try the function by running the command below:

```shell
dagger -m ci call --source=. serve up --ports 8080:80
```

You should now be able to access the application by browsing to http://localhost:8080 on the host (replace `localhost` with your Docker host's network name if accessing it remotely).

:::tip
The `--ports 8080:80` argument results in container port 80 being mapped to host port 8080. An alternative is to use the `--native` argument, which results in the exposed ports on the container being auto-mapped to the corresponding ports on the host.
:::

## Conclusion

This guide walked you through the process of creating a Dagger module to encapsulate common CI pipeline operations for an application. It explained how to create a module, add functions to it, and work with function inputs and outputs. It also demonstrated how to use modules developed by the Dagger community to speed up your development.

## Appendix A: Create an example application

This tutorial assumes that you have a Node.js Web application. If not, create a simple TypeScript application using the Vue framework. Run the command below, answer "Yes" to all the prompts and select "Cypress" as the testing tool:

```shell
npm create vue@latest myapp
```
