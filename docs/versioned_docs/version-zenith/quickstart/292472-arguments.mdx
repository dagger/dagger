---
slug: /quickstart/292472/arguments
hide_table_of_contents: true
title: "Pass arguments to a function"
---
import PartialExperimentalDocs from '../partials/_experimental.mdx';

# Quickstart

<PartialExperimentalDocs />

## Pass arguments to a function

Dagger Functions, just like regular functions, can accept arguments. In addition to basic types (string, boolean, integer, arrays...), Dagger also defines powerful core types which functions can use for their arguments: `Directory`, `Container`, `Service`, and `Secret`.

When calling a function from the CLI, its arguments are exposed as command-line flags. How the flag is interpreted depends on the argument type.
### List available arguments

To list available arguments for a function, you can use `dagger call FUNC --help`. The Dagger CLI will dynamically inspect the function's arguments, and print the corresponding flag information.

For example, let's inspect the arguments of the `hello` function we called earlier:

```shell
dagger -m github.com/shykes/daggerverse/hello call hello --help

### Pass a string or boolean argument

To pass a string argument to a function, add the corresponding flag to your `dagger call` command, followed by the string value. Passing a boolean argument is even simpler: just add the corresponding flag (the value `true` is implied).

We have already passed a string and boolean argument earlier:

```shell
dagger -m github.com/shykes/daggerverse/hello call test --giant --name daggernaut

### Directories

Dagger functions can also return directories. To see this in action, use the following command:

```shell
dagger call -m github.com/kpenfound/dagger-modules/golang --proj https://github.com/dagger/dagger build --args ./cmd/dagger entries
```

This example uses the same Go builder module as before, but this time calls its `Build()` function. Like the `Test()` function, the `Build()` function accepts a remote Go repository URL and builds a binary from the remote Go repository. It returns a Dagger `Directory` representing the state of the working directory in the repository after the build, similar to the output shown below:

```
✔ dagger call build [3m13.7s]
┃ .changes
┃ .git
┃ .github
...
┃ sdk
┃ telemetry
┃ tracing
```

:::tip
It's important to realize that even though you're testing and building a Go application in this example, you don't need to have Go, Git or any other local dependencies installed on the Dagger host. You only need the Dagger CLI and the ability to run containers. This is a very powerful feature of Dagger, because it allows development teams to create standardized tooling and eliminates all the variables and dependencies related to the host environment and/or configuration.
:::

### Pass a container as argument

In addition to basic types, Dagger defines powerful core types, which can be used in a function's arguments. For example, using the core `Container` type, a function can literally receive a container as argument. For example, a function that builds a container could use a default base image, but allow passing a custom base as an argument; or a custom publishing function could take a container as argument and upload it to a registry.

This feature is most powerful when calling a function from your own code (see [Create your first module](/428201/custom-modules/)). But you can also pass a container argument from the command-line. To do so, add the corresponding flag, followed by the address of an OCI image. The CLI will dynamically pull the image, and pass the resulting container object as argument to the function.

For example, let's call our `hello` function again, with a custom container in which to call the `figlet` tool. We must make sure that the container has the tool already installed.

```shell
dagger -m github.com/shykes/daggerverse/hello call hello --giant --figlet-container index.docker.io/hairyhenderson/figlet
