---
slug: /quickstart/292472/functions
hide_table_of_contents: true
title: "Understand arguments and return values"
---
import PartialExperimentalDocs from '../partials/_experimental.mdx';

# Quickstart

<PartialExperimentalDocs />

## Understand arguments and return values

Module functions can accept arguments and return both basic and custom types. The `HelloDagger()` function in the previous section returned a string, but you can also return Dagger's special `Directory`, `Container`, `Service` and other types, as well as your own custom types.

To begin, try the following command:

```shell
dagger call -m github.com/kpenfound/dagger-modules/golang --proj https://github.com/dagger/dagger test --args ./core
```

This Go builder module exposes a `Test()` function that accepts a remote Go repository URL as input argument. It then runs the test suite in the repository and returns the test results to the caller. This example uses Dagger's GitHub repository as input and returns the results of a subset of Dagger's own test suite.

Once the command completes, you should see output similar to the following:

```shell
✔ dagger call test [5m19.0s]
┃ ok      github.com/dagger/dagger/core   0.397s
```

Dagger functions can also return directories. To see this in action, try the following command:

```shell
dagger call -m github.com/kpenfound/dagger-modules/golang --proj https://github.com/dagger/dagger build --args ./cmd/dagger
```

This example uses the same Go builder module as before, but this time calls its `Build()` function. Like the `Test()` function, the `Build()` function accepts a remote Go repository URL and builds a binary from the remote Go repository. It returns a special Dagger `Directory` type representing the state of the working directory in the repository after the build, similar to the output shown below:

```
 dagger call build [3m13.7s]
┃ .changes
┃ .git
┃ .github
...
┃ sdk
┃ telemetry
┃ tracing
```

:::info
It's important to realize that even though you're testing and building a Go application in this example, you don't need to have Go, Git or any other local dependencies installed on your Dagger host. You only need the Dagger CLI and the ability to run containers. This is a very powerful feature of Dagger, because it allows development teams to create standardized tooling and eliminates all the variables and dependencies related to the host environment and/or configuration.
:::
