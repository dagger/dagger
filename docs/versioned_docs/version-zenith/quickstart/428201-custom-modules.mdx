---
slug: /quickstart/428201/custom-modules
hide_table_of_contents: true
title: "Create your first module"
---
import PartialExperimentalDocs from '../partials/_experimental.mdx';
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Quickstart

<PartialExperimentalDocs />

## Create your first module

So far, you've been calling Dagger functions using the Dagger CLI. However, you can also call Dagger functions through code, by creating your own Dagger module and installing other modules into it. This allows you to express more complex workflows and operations by reusing modules created by others and connecting them together using the programming language you're most comfortable with.

In the previous sections, you've used the Dagger CLI to call Dagger functions to build a Go binary from a remote repository and export it to your local filesystem, and to build and publish a container image to a registry. But what if you wanted to combine these operations (and other) into a single workflow?

One approach is to use multiple Dagger CLI calls (similar to what you've used in previous sections) and connect them together using shell scripts. However, this approach is not recommended, because you will typically end up with long and unwieldy CLI commands and shell scripting "glue" that is hard to debug and maintain.

A better approach is to create a programmable Dagger module, which can then call other Dagger modules and functions to achieve the required results. Creating your own Dagger module enables you to transform your workflows into structured, discrete and composable units with clear inputs and outputs, with all the benefits of using a native programming language.

To see this in action, create a custom Dagger module to build a Go binary, add it to a container image and publish the container image to a registry.

1. Begin by creating a new directory for your Dagger module and running `dagger init` to bootstrap a new module:

    <Tabs groupId="language">
    <TabItem value="Go">

    ```shell
    mkdir my-module
    dagger init --name=my-module --sdk=go
    ```

    This will generate a `dagger.json` module file, an initial `main.go` source file, as well as a generated `dagger.gen.go` and `querybuilder` directory for the generated module code.

    </TabItem>
    <TabItem value="Python">

    ```shell
    mkdir my-module
    dagger init --name=my-module --sdk=python
    ```

    This will generate a `dagger.json` module file, initial `src/main.py` and `pyproject.toml` files, as well as a generated `sdk` folder for local development.

    </TabItem>
    <TabItem value="TypeScript">

    ```shell
    mkdir my-module
    dagger init --name=my-module --sdk=typescript
    ```

    This will generate a `dagger.json` module file, initial `src/index.ts`, `package.json` and `tsconfig.json` files, as well as a generated `sdk` folder for local development.

    </TabItem>
    </Tabs>

1. Dagger lets you add dependencies to your modules, so that you can build on modules created by others. Add the `golang` and `wolfi` modules as dependencies in your new module using `dagger install`:

    ```shell
    dagger install github.com/kpenfound/dagger-modules/golang
    dagger install github.com/shykes/daggerverse/wolfi
    ```

1. Update the generated `main.go` file with the following code:

<Tabs groupId="language">
<TabItem value="Go">

    ```go file=./snippets/create/main.go
    ```

</TabItem>
<TabItem value="Python">

    ```python file=./snippets/create/main.py
    ```

</TabItem>
<TabItem value="TypeScript">

    ```typescript file=./snippets/create/index.ts
    ```

</TabItem>
</Tabs>

    This new `BuildAndPublish()` function does the following:

FIXME
- It uses the `dag` client's `Container().From()` method to initialize a new container from a base image. In this example, the base image is again `node:18-slim`. This method returns a `Container` initialized from that base image.
- When a module is loaded into Dagger, it includes the directory tree at which `dagger.json` is located. In this example, since `dagger.json` is co-located with the application source code directory, that directory is auto-included in the module container's filesystem and can be accessed via `dag.Host().Directory()`.
    - The function code uses the `Container.WithDirectory()` method to mount the source code directory from the module container's filesystem at the `/src` mount point in the container, and the `Container.WithWorkdir()` method to set the working directory to that mount point.
    - The `dag.Host().Directory()` method queries the module container's environment and returns a reference to the application source code directory in the module container's filesystem after excluding the `.git` and `node_modules` sub-directories.
- It uses the `Container.WithExec()` method to define the commands to install dependencies and run tests in the container - in this case, the commands `npm install` and `npm run test:unit run`.
- It uses the `Container.Stdout()` method to return the output of the last executed command (the test results). If tests pass, the output shows the list of passed tests. If not, a non-nil `error` is returned, which propagates to the Dagger CLI and lets it know that one or more tests failed.
END FIXME

Call the new function using the Dagger CLI:

```shell
dagger call build-and-publish
```

Here's an example of the output you will see:

```shell
```


:::info
Each module executes in a container and the common interface between modules is GraphQL. When you install one module in another, Dagger exposes its functions using a language-agnostic GraphQL API. This means that any module is usable from any other module, regardless of whether they use the same programming language or not - for example, you can use a Python module from Go, or a TypeScript module from Python. This also means that you no longer care which language your CI tooling is written in; you can use the one that you're most comfortable with or that best suits the requirements at hand. [Learn more about how Dagger works](../index.mdx#how-does-it-work).
:::
