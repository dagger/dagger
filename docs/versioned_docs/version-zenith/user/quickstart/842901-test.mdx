---
slug: /user/quickstart/842901/test
hide_table_of_contents: true
title: "Add a function to test the application"
---

# Quickstart

## Add a function to test the application

The function in the previous example was illustrative - you wouldn't ever use it in the real world! So, the next step is to write a Dagger function to do something more useful, like running an application's tests.

Since the application is a Node.js application, it's convenient to start with the [`node` module](https://daggerverse.dev/mod/github.com/quartz-technology/daggerverse/node) from the [Daggerverse](https://daggerverse.dev), which provides a set of ready-made functions to manage a Node.js project.

:::info
The [Daggerverse](https://daggerverse.dev) is an online catalog of Dagger modules that enables users to easily discover and use modules created by the Dagger community.
:::

Begin by adding the `node` module as a dependency:

```shell
dagger mod install github.com/quartz-technology/daggerverse/node
```

Then, add a new `Test()` function to `main.go`, which runs the application's unit test suite:

```go file=snippets/test/main.go
```

This function does the following:

- It calls the `node` module's `WithVersion()` function via the `dag` client. This function returns a `node` container image with the given Node.js version. This container image is represented as a `Node` object.
- It calls the module's `Node.WithNpm()` function, which returns a revised `Node` object after adding the `npm` package manager and a cache volume for `npm`.
- It calls the module's `Node.WithSource()` function, which returns a revised `Node` object including the application source code and a cache volume for Node.js modules. The `dag.Host().Directory()` method queries the host environment and returns a reference to the application source code directory on the host after excluding the `.git` and `node_modules` sub-directories.
- It calls the module's `Node.Install()` function, which runs `npm install` in the container and returns a revised `Node` object including the application's dependencies.
- It calls the module's `Node.Run()` function, which returns a revised `Node` object after setting the commands to run in the container image - in this case, the command `npm run test:unit run`.
- It uses the `Container.Stdout()` function to return the output stream of the last executed command. If tests pass, the output shows the list of passed tests. If not, a non-nil `error` is returned, which propagates to the Dagger CLI and lets it know that one or more tests failed.

Call the new function using the Dagger CLI:

```shell
dagger call test
```

Here's an example of the output you will see:

```shell
✔ dagger call test [1m20.7s]
┃
┃ > test1@0.0.0 test:unit
┃ > vitest run
┃
┃
┃  RUN  v1.0.4 /src
┃
┃  ✓ src/components/__tests__/HelloWorld.spec.ts  (1 test) 149ms
┃
┃  Test Files  1 passed (1)
┃       Tests  1 passed (1)
┃    Start at  20:01:59
┃    Duration  9.59s (transform 859ms, setup 0ms, collect 1.16s, tests 149ms, environment 5.35s, prepare 1.
┃ 06s)
• Engine: 378cfbb9549c (version v0.9.3)
⧗ 2m8.0s ✔ 107 ∅ 13
```

:::tip
This example uses the `node` module's `Node.Run().Stdout()` function to explicitly specify the test command and print its output stream. As an alternative, the `node` module also exposes a `Node.Test()` function, which executes the `npm run test` command and prints its output stream.
:::
