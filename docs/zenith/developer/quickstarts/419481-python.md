---
slug: /zenith/developer/quickstarts/419481/python
displayed_sidebar: "zenith"
---

# Write Your First Dagger Module in Python

{@include: ../../partials/_experimental.md}

## Introduction

Welcome to Dagger, a programmable tool that lets you replace your software project's artisanal scripts with a modern API and cross-language scripting engine.

Dagger lets you encapsulate all your project's tasks and workflows into simple modules, written in your programming language of choice.

This tutorial introduces you to Dagger modules and walks you, step by step, through the process of creating your first Dagger module.

## Requirements

This quickstart assumes that:

- You have a good understanding of the Dagger Python SDK. If not, refer to the [Python](https://dagger-io.readthedocs.org/) SDK reference.
- You have the Dagger CLI installed. If not, [install Dagger](../../../current/cli/465058-install.md).
- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).

## Step 1: Initialize a new module

1. Create a new directory on your filesystem and run `dagger mod init` to bootstrap your first module. We'll call it `potato` here, but you can choose your favorite food.

  ```sh
  mkdir potato/
  cd potato/

  # initialize Dagger module
  dagger mod init --name=potato --sdk=python
  ```

  This will generate a `dagger.json` module file, an initial `main.py` source file, as well as a generated `dagger.gen.go` and `internal` folder for the generated module code.

1. Test the module. Run the generated `main.go` with the `dagger call` command:

  ```sh
  dagger call container-echo --string-arg 'Hello daggernauts!'
  ```

  :::tip
  When using `dagger call` to call module functions, do not explicitly use the name of the module.
  :::

  An alternative approach is to run the module using a GraphQL query piped through the `dagger query` command:

  ```sh
  echo '{potato{containerEcho(stringArg:"Hello daggernauts!"){stdout}}}' | dagger query
  ```

:::note
When using `dagger call`, all names (functions, arguments, struct fields, etc) are converted into a shell-friendly "kebab-case" style.

When using `dagger query` and GraphQL, all names are converted into a language-agnostic "camelCase" style.
:::

## Step 2: Add a function

Let's try changing the `main.py` file.

TODO

1. Run `dagger mod sync` to regenerate the module code:

  ```sh
  dagger mod sync
  ```

  :::important
  You will need to run `dagger mod sync` after every change to your module's interface (when you add/remove functions or change their parameters and return types).
  :::

1. Test the new function, once again using `dagger call` or `dagger query`:

  ```sh
  dagger call hello-world
  ```

  or

  ```sh
  echo '{potato{helloWorld}}' | dagger query
  ```

## Step 3: Use input parameters and return types

Your module functions can accept and return multiple different types, not just basic built-in types.

1. Update the function to accept multiple parameters (some of which are optional):

TODO

:::tip
Use `dagger call --help` to get help on the commands and flags available.
:::


## Example: Write a vulnerability scanning module

The example module in the previous sections was just that - an example. Next, let's put everything you've learnt to the test, by building a module with a real-world application: scanning a container image for vulnerabilities with [Trivy](https://trivy.dev/).

1. Initialize a new module:

  ```
  mkdir trivy/
  cd trivy/
  dagger mod init --name=trivy --sdk=python
  ```

1. Replace the generated `main.py` file with the following code:

TODO


1. Test the function using `dagger call`:

  ```
  dagger call  scan-image --image-ref alpine:latest
  ```

  Here's an example of the output:

  ```
  ✔ dagger call scan-image [5.28s]
  ┃
  ┃ alpine:latest (alpine 3.18.4)
  ┃ =============================
  ┃ Total: 2 (UNKNOWN: 0, LOW: 0, MEDIUM: 2, HIGH: 0, CRITICAL: 0)
  ┃
  ┃ ┌────────────┬───────────────┬──────────┬────────┬───────────────────┬───────────────┬───────────────────────────────────────────────┐
  ┃ │  Library   │ Vulnerability │ Severity │ Status │ Installed Version │ Fixed Version │                     Title                     │
  ┃ ├────────────┼───────────────┼──────────┼────────┼───────────────────┼───────────────┼───────────────────────────────────────────────┤
  ┃ │ libcrypto3 │ CVE-2023-5363 │ MEDIUM   │ fixed  │ 3.1.3-r0          │ 3.1.4-r0      │ Incorrect cipher key and IV length processing │
  ┃ │            │               │          │        │                   │               │ https://avd.aquasec.com/nvd/cve-2023-5363     │
  ┃ ├────────────┤               │          │        │                   │               │                                               │
  ┃ │ libssl3    │               │          │        │                   │               │                                               │
  ┃ │            │               │          │        │                   │               │                                               │
  ┃ └────────────┴───────────────┴──────────┴────────┴───────────────────┴───────────────┴───────────────────────────────────────────────┘
  • Engine: 8212a964c511 (version v0.9.2)
  ⧗ 33.46s ✔ 65 ∅ 4
  ```

Congratulations! You've just written your first Dagger module!

:::tip
The Daggerverse is an online catalog of Dagger modules created by the Dagger community. You can publish your own modules to the Daggerverse, so that others can easily find and use them. You can also use Daggerverse modules via the Dagger CLI, or include them as dependendencies to reuse them in your own Dagger modules. Daggerverse modules are open source, and inspecting their code is a great way to improve your module development skills. [Browse the Daggerverse](https://daggerverse.dev/) or learn how to [publish your module to the Daggerverse](../guides/821742-publish-modules.md).
:::

## Conclusion

This guide taught you the basics of writing a Dagger module in Python. It showed you how to initialize a module, add functions to it, and work with input parameters and custom return values. It also worked through a real-world use case: a Dagger module to scan container images with Trivy.

Continue your journey into Dagger programming with the following resources:

- The [Daggerverse](https://daggerverse.dev), an online catalog of Dagger modules for you to use and learn from
- Guide on [publishing modules to the Daggerverse](../guides/821742-publish-modules.md)
- Guide on [advanced module development](../guides/191108-advanced-module-development.md)
- [Reference documentation for the Python SDK](https://dagger-io.readthedocs.org/)
- [FAQ](../../../current/faq.md)

## Appendix A: Troubleshooting

If you come across bugs, here are some simple troubleshooting suggestions.

{@include: ../../partials/_developer_troubleshooting.md}
