---
slug: /zenith/developer/quickstarts/525021/go
displayed_sidebar: "zenith"
---

# Write Your First Dagger Module in Go

{@include: ../../partials/_experimental.md}

## Introduction

Welcome to Dagger, a programmable tool that lets you replace your software project's artisanal scripts with a modern API and cross-language scripting engine.

Dagger lets you encapsulate all your project's tasks and workflows into simple modules, written in your programming language of choice.

This tutorial introduces you to Dagger modules and walks you, step by step, through the process of creating your first Dagger module.

## Requirements

This quickstart assumes that:

- You have a good understanding of the Dagger Go SDK. If not, refer to the [Go](https://pkg.go.dev/dagger.io/dagger) SDK reference.
- You have the Dagger CLI installed. If not, [install Dagger](../../../current/cli/465058-install.md).
- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).

## Step 1: Initialize a new module

1. Create a new directory on your filesystem and run `dagger mod init` to bootstrap your first module. We'll call it `potato` here, but you can choose your favorite food.

  ```sh
  mkdir potato/
  cd potato/

  # initialize Dagger module
  dagger mod init --name=potato --sdk=go
  ```

  This will generate a `dagger.json` module file, an initial `main.go` source file, as well as a generated `dagger.gen.go` and `internal` folder for the generated module code.

1. Test the module. Run the generated `main.go` with the `dagger call` command:

  ```sh
  dagger call container-echo --string-arg 'Hello daggernauts!'
  ```

  :::tip
  When using `dagger call` to call module functions, do not explicitly use the name of the module.
  :::

  An alternative approach is to run the module using a GraphQL query piped through the `dagger query` command:

  ```sh
  echo '{potato{containerEcho(stringArg:"Hello daggernauts!"){stdout}}}' | dagger query
  ```

:::note
When using `dagger call`, all names (functions, arguments, struct fields, etc) are converted into a shell-friendly "kebab-case" style.

When using `dagger query` and GraphQL, all names are converted into a language-agnostic "camelCase" style.
:::

## Step 2: Add a function

Let's try changing the `main.go` file.

1. The module is named `potato`, so that means all methods on the `Potato` type are published as functions. Let's replace the auto-generated template with something simpler:

  ```go
  package main

  type Potato struct{}

  func (m *Potato) HelloWorld() string {
    return "Hello daggernauts!"
  }
  ```

  Module functions are flexible in what parameters they can take. You can include
  an optional `context.Context`, and an optional `error` result. These are all
  valid variations of the above:

  ```go
  func (m *Potato) HelloWorld() string
  func (m *Potato) HelloWorld() (string, error)
  func (m *Potato) HelloWorld(ctx context.Context) string
  func (m *Potato) HelloWorld(ctx context.Context) (string, error)
  ```

1. Run `dagger mod sync` to regenerate the module code:

  ```sh
  dagger mod sync
  ```

  :::important
  You will need to run `dagger mod sync` after every change to your module's interface (when you add/remove functions or change their parameters and return types).
  :::

1. Test the new function, once again using `dagger call` or `dagger query`:

  ```sh
  dagger call hello-world
  ```

  or

  ```sh
  echo '{potato{helloWorld}}' | dagger query
  ```

## Step 3: Use input parameters and return types

Your module functions can accept and return multiple different types, not just basic built-in types.

1. Update the function to accept multiple parameters (some of which are optional):

  ```go
  package main

  import "fmt"

  type Potato struct{}

  func (m *Potato) HelloWorld(
    // the number of potatoes to process
    count  int,
    // whether the potatoes are mashed (this is an optional parameter!)
    mashed Optional[bool],
  ) string {
    if mashed.GetOr(false) {
      return fmt.Sprintf("Hello world, I have mashed %d potatoes", count)
    }
    return fmt.Sprintf("Hello world, I have %d potatoes", count)
  }
  ```

  The optional parameters are specified using the special `Optional` type and assigned default values. These optional parameters can then be set using `dagger call` or `dagger query` (exactly as if they'd been specified as top-level options):

  ```sh
  dagger call hello-world --count 10 --mashed true
  ```

  or

  ```sh
  echo '{potato{helloWorld(count:10, mashed:true)}}' | dagger query
  ```

1. Update the function to return a custom `PotatoMessage` type:

  ```go
  package main

  type Potato struct{}

  // HACK: to be queried, custom object fields require `json` tags
  type PotatoMessage struct {
    Message string `json:"message"`
    From    string `json:"from"`
  }

  // HACK: this is temporarily required to ensure that the codegen discovers
  // PotatoMessage
  func (msg PotatoMessage) Void() {}

  func (m *Potato) HelloWorld(message string) PotatoMessage {
    return PotatoMessage{
      Message: message,
      From:    "potato@example.com",
    }
  }
  ```

  Test it using `dagger call` or `dagger query`:

  ```sh
  dagger call hello-world --message "I am a potato" message
  dagger call hello-world --message "I am a potato" from
  ```

  or

  ```sh
  echo '{potato{helloWorld(message: "I am a potato"){message, from}}}' | dagger query
  ```

:::tip
Use `dagger call --help` to get help on the commands and flags available.
:::


## Example: Write a vulnerability scanning module

The example module in the previous sections was just that - an example. Next, let's put everything you've learnt to the test, by building a module with a real-world application: scanning a container image for vulnerabilities with [Trivy](https://trivy.dev/).

1. Initialize a new module:

  ```
  mkdir trivy/
  cd trivy/
  dagger mod init --name=trivy --sdk=go
  ```

1. Replace the generated `main.go` file with the following code:

  ```
  package main

  import (
    "context"
    "strconv"
  )

  type Trivy struct{}

  // pull the official Trivy image
  // send the trivy CLI an image ref to scan
  func (t *Trivy) ScanImage(
    ctx context.Context,
    imageRef string,
    severity Optional[string],
    exitCode Optional[int],
    format Optional[string]) (string, error) {

    sv := severity.GetOr("UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL")
    ec := exitCode.GetOr(0)
    ft := format.GetOr("table")
    return dag.
      Container().
      From("aquasec/trivy:latest").
      WithExec([]string{"image", "--quiet", "--severity", sv, "--exit-code", strconv.Itoa(ec), "--format", ft, imageRef}).Stdout(ctx)
  }
  ```

  Here, the `ScanImage()` function accepts four parameters (apart from the context):
    - A reference to the container image to be scanned (required);
    - A severity filter (optional);
    - The exit code to use if scanning finds vulnerabilities (optional);
    - The reporting format (optional).

  The function code performs the following operations:
    - It uses the client's `Container().From()` method to initialize a new container from a base image. In this example, the base image is the official Trivy image `aquasec/trivy:latest`. This method returns a `Container` representing an OCI-compatible container image.
    - It uses the `Container.WithExec()` method to define the command to be executed in the container - in this case, the `trivy image` command for image scanning. It also passes the optional parameters to the command. The `WithExec()` method returns a revised `Container` with the results of command execution.
    - It retrieves the output stream of the command with the `Container.Stdout()` method and prints the result to the console.

1. Test the function using `dagger call`:

  ```
  dagger call  scan-image --image-ref alpine:latest
  ```

  Here's an example of the output:

  ```
  ✔ dagger call scan-image [5.28s]
  ┃
  ┃ alpine:latest (alpine 3.18.4)
  ┃ =============================
  ┃ Total: 2 (UNKNOWN: 0, LOW: 0, MEDIUM: 2, HIGH: 0, CRITICAL: 0)
  ┃
  ┃ ┌────────────┬───────────────┬──────────┬────────┬───────────────────┬───────────────┬───────────────────────────────────────────────┐
  ┃ │  Library   │ Vulnerability │ Severity │ Status │ Installed Version │ Fixed Version │                     Title                     │
  ┃ ├────────────┼───────────────┼──────────┼────────┼───────────────────┼───────────────┼───────────────────────────────────────────────┤
  ┃ │ libcrypto3 │ CVE-2023-5363 │ MEDIUM   │ fixed  │ 3.1.3-r0          │ 3.1.4-r0      │ Incorrect cipher key and IV length processing │
  ┃ │            │               │          │        │                   │               │ https://avd.aquasec.com/nvd/cve-2023-5363     │
  ┃ ├────────────┤               │          │        │                   │               │                                               │
  ┃ │ libssl3    │               │          │        │                   │               │                                               │
  ┃ │            │               │          │        │                   │               │                                               │
  ┃ └────────────┴───────────────┴──────────┴────────┴───────────────────┴───────────────┴───────────────────────────────────────────────┘
  • Engine: 8212a964c511 (version v0.9.2)
  ⧗ 33.46s ✔ 65 ∅ 4
  ```

Congratulations! You've just written your first Dagger module!

:::tip
The Daggerverse is an online catalog of Dagger modules created by the Dagger community. You can publish your own modules to the Daggerverse, so that others can easily find and use them. You can also use Daggerverse modules via the Dagger CLI, or include them as dependendencies to reuse them in your own Dagger modules. Daggerverse modules are open source, and inspecting their code is a great way to improve your module development skills. [Browse the Daggerverse](https://daggerverse.dev/) or learn how to [publish your module to the Daggerverse](../guides/821742-publish-modules.md).
:::

## Conclusion

This guide taught you the basics of writing a Dagger module in Go. It showed you how to initialize a module, add functions to it, and work with input parameters and custom return values. It also worked through a real-world use case: a Dagger module to scan container images with Trivy.

Continue your journey into Dagger programming with the following resources:

- The [Daggerverse](https://daggerverse.dev), an online catalog of Dagger modules for you to use and learn from
- Guide on [publishing modules to the Daggerverse](../guides/821742-publish-modules.md)
- Guide on [advanced module development](../guides/191108-advanced-module-development.md)
- [Reference documentation for the Go SDK](https://pkg.go.dev/dagger.io/dagger)
- [FAQ](../../../current/faq.md)

## Appendix A: Troubleshooting

If you come across bugs, here are some simple troubleshooting suggestions.

{@include: ../../partials/_developer_troubleshooting.md}
