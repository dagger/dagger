---
slug: /zenith/developer/quickstarts/525021/go
displayed_sidebar: "zenith"
---

# Write Your First Dagger Module in Go

{@include: ../../partials/_experimental.md}

## Introduction

{@include: ../../partials/_developer_quickstart_introduction.md}

## Requirements

This quickstart assumes that:

- You have a good understanding of the Dagger Go SDK. If not, refer to the [Go](https://pkg.go.dev/dagger.io/dagger) SDK reference.
- You have the Dagger CLI installed. If not, [install Dagger](../../../current/cli/465058-install.md).
- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).

## Step 1: Initialize a new module

1. Create a new directory on your filesystem and run `dagger mod init` to bootstrap your first module. We'll call it `potato` here, but you can choose your favorite food.

  ```sh
  mkdir potato/
  cd potato/

  # initialize Dagger module
  dagger mod init --name=potato --sdk=go
  ```

  This will generate a `dagger.json` module file, an initial `main.go` source file, as well as a generated `dagger.gen.go` and `internal` folder for the generated module code.

1. Test the module. Run the generated `main.go` with the `dagger call` command:

  ```sh
  dagger call container-echo --string-arg 'Hello daggernauts!'
  ```

  :::tip
  When using `dagger call` to call module functions, do not explicitly use the name of the module.
  :::

  An alternative approach is to run the module using a GraphQL query piped through the `dagger query` command:

  ```sh
  echo '{potato{containerEcho(stringArg:"Hello daggernauts!"){stdout}}}' | dagger query
  ```

:::note
When using `dagger call`, all names (functions, arguments, struct fields, etc) are converted into a shell-friendly "kebab-case" style.

When using `dagger query` and GraphQL, all names are converted into a language-agnostic "camelCase" style.
:::

## Step 2: Add a function

Let's try changing the `main.go` file.

1. The module is named `potato`, so that means all methods on the `Potato` type are published as functions. Let's replace the auto-generated template with something simpler:

  ```go
  package main

  type Potato struct{}

  func (m *Potato) HelloWorld() string {
    return "Hello daggernauts!"
  }
  ```

  Module functions are flexible in what parameters they can take. You can include
  an optional `context.Context`, and an optional `error` result. These are all
  valid variations of the above:

  ```go
  func (m *Potato) HelloWorld() string
  func (m *Potato) HelloWorld() (string, error)
  func (m *Potato) HelloWorld(ctx context.Context) string
  func (m *Potato) HelloWorld(ctx context.Context) (string, error)
  ```

1. Run `dagger mod sync` to regenerate the module code:

  ```sh
  dagger mod sync
  ```

  :::important
  You will need to run `dagger mod sync` after every change to your module's interface (when you add/remove functions or change their parameters and return types).
  :::

1. Test the new function, once again using `dagger call` or `dagger query`:

  ```sh
  dagger call hello-world
  ```

  or

  ```sh
  echo '{potato{helloWorld}}' | dagger query
  ```

## Step 3: Use input parameters and return types

Your module functions can accept and return multiple different types, not just basic built-in types.

1. Update the function to accept multiple parameters (some of which are optional):

  ```go
  package main

  import "fmt"

  type Potato struct{}

  func (m *Potato) HelloWorld(
    // the number of potatoes to process
    count  int,
    // whether the potatoes are mashed (this is an optional parameter!)
    mashed Optional[bool],
  ) string {
    if mashed.GetOr(false) {
      return fmt.Sprintf("Hello world, I have mashed %d potatoes", count)
    }
    return fmt.Sprintf("Hello world, I have %d potatoes", count)
  }
  ```

  The optional parameters are specified using the special `Optional` type and assigned default values. These optional parameters can then be set using `dagger call` or `dagger query` (exactly as if they'd been specified as top-level options):

  ```sh
  dagger call hello-world --count 10 --mashed true
  ```

  or

  ```sh
  echo '{potato{helloWorld(count:10, mashed:true)}}' | dagger query
  ```

1. Update the function to return a custom `PotatoMessage` type:

  ```go
  package main

  type Potato struct{}

  // HACK: to be queried, custom object fields require `json` tags
  type PotatoMessage struct {
    Message string `json:"message"`
    From    string `json:"from"`
  }

  // HACK: this is temporarily required to ensure that the codegen discovers
  // PotatoMessage
  func (msg PotatoMessage) Void() {}

  func (m *Potato) HelloWorld(message string) PotatoMessage {
    return PotatoMessage{
      Message: message,
      From:    "potato@example.com",
    }
  }
  ```

  Test it using `dagger call` or `dagger query`:

  ```sh
  dagger call hello-world --message "I am a potato" message
  dagger call hello-world --message "I am a potato" from
  ```

  or

  ```sh
  echo '{potato{helloWorld(message: "I am a potato"){message, from}}}' | dagger query
  ```

:::tip
Use `dagger call --help` to get help on the commands and flags available.
:::


## Example: Write a vulnerability scanning module

The example module in the previous sections was just that - an example. Next, let's put everything you've learnt to the test, by building a module for a real-world use case: scanning a container image for vulnerabilities with [Trivy](https://trivy.dev/).

1. Initialize a new module:

  ```
  mkdir trivy/
  cd trivy/
  dagger mod init --name=trivy --sdk=go
  ```

1. Replace the generated `main.go` file with the following code:

  ```go
  package main

  import (
    "context"
    "strconv"
  )

  type Trivy struct{}

  // pull the official Trivy image
  // send the trivy CLI an image ref to scan
  func (t *Trivy) ScanImage(
    ctx context.Context,
    imageRef string,
    severity Optional[string],
    exitCode Optional[int],
    format Optional[string]) (string, error) {

    sv := severity.GetOr("UNKNOWN,LOW,MEDIUM,HIGH,CRITICAL")
    ec := exitCode.GetOr(0)
    ft := format.GetOr("table")
    return dag.
      Container().
      From("aquasec/trivy:latest").
      WithExec([]string{"image", "--quiet", "--severity", sv, "--exit-code", strconv.Itoa(ec), "--format", ft, imageRef}).Stdout(ctx)
  }
  ```

  Here, the `ScanImage()` function accepts four parameters (apart from the context):
    - A reference to the container image to be scanned (required);
    - A severity filter (optional);
    - The exit code to use if scanning finds vulnerabilities (optional);
    - The reporting format (optional).

  The function code performs the following operations:
    - It uses the client's `Container().From()` method to initialize a new container from a base image. In this example, the base image is the official Trivy image `aquasec/trivy:latest`. This method returns a `Container` representing an OCI-compatible container image.
    - It uses the `Container.WithExec()` method to define the command to be executed in the container - in this case, the `trivy image` command for image scanning. It also passes the optional parameters to the command. The `WithExec()` method returns a revised `Container` with the results of command execution.
    - It retrieves the output stream of the command with the `Container.Stdout()` method and prints the result to the console.

{@include: ../../partials/_developer_quickstart_trivy_test.md}

## Conclusion

{@include: ../../partials/_developer_quickstart_conclusion.md}

## Appendix A: Troubleshooting

If you come across bugs, here are some simple troubleshooting suggestions.

{@include: ../../partials/_developer_troubleshooting.md}
