package session

import (
	"context"
	"errors"
	fmt "fmt"
	io "io"
	"os"

	"github.com/moby/buildkit/util/grpcerrors"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

// PipeAttachable implements the PipeServer interface generated by protoc.
type PipeAttachable struct {
	rootCtx context.Context

	stdin  io.Reader
	stdout io.Writer

	UnimplementedPipeServer
}

func NewPipeAttachable(rootCtx context.Context, stdin io.Reader, stdout io.Writer) PipeAttachable {
	return PipeAttachable{
		rootCtx: rootCtx,
		stdin:   stdin,
		stdout:  stdout,
	}
}

func (p PipeAttachable) Register(srv *grpc.Server) {
	RegisterPipeServer(srv, p)
}

func (p PipeAttachable) IO(srv Pipe_IOServer) error {
	ctx, cancel := context.WithCancelCause(srv.Context())
	defer cancel(errors.New("terminal session finished"))

	go p.forwardStdin(ctx, srv, p.stdin)

	for {
		req, err := srv.Recv()
		if err != nil {
			if errors.Is(err, context.Canceled) || grpcerrors.Code(err) == codes.Canceled {
				// canceled
				return nil
			}

			if errors.Is(err, io.EOF) {
				// stopped
				return nil
			}

			if grpcerrors.Code(err) == codes.Unavailable {
				// client disconnected (i.e. quitting Dagger out)
				return nil
			}
			return fmt.Errorf("error reading pipe: %w", err)
		}

		// receive request from engine, forwarding to stdout on client
		data := req.GetData()
		_, err = p.stdout.Write(data)
		if err != nil {
			return fmt.Errorf("pipe write stdout: %w", err)
		}
	}
}

func (p PipeAttachable) forwardStdin(ctx context.Context, srv Pipe_IOServer, stdin io.Reader) {
	if p.stdin == nil {
		return
	}

	// In order to stop reading from stdin when the context is cancelled,
	// we proxy the reads through a Pipe which we can close without closing
	// the underlying stdin.
	pipeR, pipeW := io.Pipe()
	close := func() {
		pipeR.Close()
		pipeW.Close()
	}
	defer close()
	go io.Copy(pipeW, stdin)
	go func() {
		<-ctx.Done()
		close()
	}()

	b := make([]byte, 512)
	for {
		n, err := pipeR.Read(b)
		if err != nil {
			if errors.Is(err, io.EOF) || errors.Is(err, io.ErrClosedPipe) {
				return
			}
			fmt.Fprintf(os.Stderr, "read stdin: %v\n", err)
			return
		}

		err = srv.Send(&Data{
			Data: b[:n],
		})
		if err != nil {
			fmt.Fprintf(os.Stderr, "forward stdin: %v\n", err)
			return
		}
	}
}
