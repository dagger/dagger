package sdk

import (
	"context"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/dagger/dagger/internal/mage/util"

	"dagger.io/dagger"
	"github.com/magefile/mage/mg"
	"golang.org/x/sync/errgroup"
)

var (
	pythonGeneratedAPIPaths = []string{
		"sdk/python/src/dagger/api/gen.py",
		"sdk/python/src/dagger/api/gen_sync.py",
	}
	pythonDefaultVersion = "3.11"
)

var _ SDK = Python{}

type Python mg.Namespace

// Lint lints the Python SDK
func (t Python) Lint(ctx context.Context) error {
	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
	if err != nil {
		return err
	}
	defer c.Close()

	c = c.Pipeline("sdk").Pipeline("python").Pipeline("lint")

	eg, gctx := errgroup.WithContext(ctx)

	base := pythonBase(c, pythonDefaultVersion)

	eg.Go(func() error {
		_, err = base.
			WithExec([]string{"poe", "lint"}).
			Sync(gctx)
		return err
	})

	eg.Go(func() error {
		path := "docs/current"
		_, err = base.
			WithDirectory(
				fmt.Sprintf("/%s", path),
				util.Repository(c).Directory(path),
				dagger.ContainerWithDirectoryOpts{
					Include: []string{"**/*.py", ".ruff.toml"},
				},
			).
			WithExec([]string{"poe", "lint-docs"}).
			Sync(gctx)
		return err
	})

	eg.Go(func() error {
		return lintGeneratedCode(func() error {
			return t.Generate(ctx)
		}, pythonGeneratedAPIPaths...)
	})

	return eg.Wait()
}

// Test tests the Python SDK
func (t Python) Test(ctx context.Context) error {
	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
	if err != nil {
		return err
	}
	defer c.Close()

	c = c.Pipeline("sdk").Pipeline("python").Pipeline("test")

	versions := []string{"3.10", "3.11"}

	devEngine, endpoint, err := util.CIDevEngineContainerAndEndpoint(ctx, c.Pipeline("dev-engine"), util.DevEngineOpts{Name: "sdk-python-test"})
	if err != nil {
		return err
	}

	cliBinPath := "/.dagger-cli"
	eg, gctx := errgroup.WithContext(ctx)
	for _, version := range versions {
		version := version
		eg.Go(func() error {
			_, err := pythonBase(c.Pipeline(version), version).
				WithServiceBinding("dagger-engine", devEngine).
				WithEnvVariable("_EXPERIMENTAL_DAGGER_RUNNER_HOST", endpoint).
				WithMountedFile(cliBinPath, util.DaggerBinary(c)).
				WithEnvVariable("_EXPERIMENTAL_DAGGER_CLI_BIN", cliBinPath).
				WithExec([]string{"poe", "test", "--exitfirst"}).
				Sync(gctx)
			return err
		})
	}

	return eg.Wait()
}

// Generate re-generates the SDK API
func (t Python) Generate(ctx context.Context) error {
	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
	if err != nil {
		return err
	}
	defer c.Close()

	c = c.Pipeline("sdk").Pipeline("python").Pipeline("generate")

	devEngine, endpoint, err := util.CIDevEngineContainerAndEndpoint(ctx, c.Pipeline("dev-engine"), util.DevEngineOpts{Name: "sdk-python-generate"})
	if err != nil {
		return err
	}
	cliBinPath := "/.dagger-cli"

	generated := pythonBase(c, pythonDefaultVersion).
		WithServiceBinding("dagger-engine", devEngine).
		WithEnvVariable("_EXPERIMENTAL_DAGGER_RUNNER_HOST", endpoint).
		WithMountedFile(cliBinPath, util.DaggerBinary(c)).
		WithEnvVariable("_EXPERIMENTAL_DAGGER_CLI_BIN", cliBinPath).
		WithExec([]string{"poe", "generate"})

	for _, f := range pythonGeneratedAPIPaths {
		contents, err := generated.File(strings.TrimPrefix(f, "sdk/python/")).Contents(ctx)
		if err != nil {
			return err
		}
		if err := os.WriteFile(f, []byte(contents), 0o600); err != nil {
			return err
		}
	}
	return nil
}

// Publish publishes the Python SDK
func (t Python) Publish(ctx context.Context, tag string) error {
	c, err := dagger.Connect(ctx, dagger.WithLogOutput(os.Stderr))
	if err != nil {
		return err
	}
	defer c.Close()

	c = c.Pipeline("sdk").Pipeline("python").Pipeline("publish")

	var (
		version = strings.TrimPrefix(tag, "sdk/python/v")
		token   = os.Getenv("PYPI_TOKEN")
		repo    = os.Getenv("PYPI_REPO")
	)

	if token == "" {
		return errors.New("PYPI_TOKEN environment variable must be set")
	}

	build := pythonBase(c, pythonDefaultVersion).
		WithEnvVariable("POETRY_DYNAMIC_VERSIONING_BYPASS", version).
		WithExec([]string{"poetry-dynamic-versioning"}).
		WithExec([]string{"poetry", "build"})

	args := []string{"poetry", "publish"}

	if repo == "test" {
		build = build.WithEnvVariable("POETRY_REPOSITORIES_TEST_URL", "https://test.pypi.org/legacy/")
		args = append(args, "-r", "test")
	} else {
		repo = "pypi"
	}

	_, err = build.
		WithEnvVariable(fmt.Sprintf("POETRY_PYPI_TOKEN_%s", strings.ToUpper(repo)), token).
		WithExec(args).
		Sync(ctx)

	return err
}

// Bump the Python SDK's Engine dependency
func (t Python) Bump(ctx context.Context, version string) error {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")
	engineReference := fmt.Sprintf("# Code generated by dagger. DO NOT EDIT.\n\nCLI_VERSION = %q\n", version)

	// NOTE: if you change this path, be sure to update .github/workflows/publish.yml so that
	// provision tests run whenever this file changes.
	return os.WriteFile("sdk/python/src/dagger/engine/_version.py", []byte(engineReference), 0o600)
}

func pythonBase(c *dagger.Client, version string) *dagger.Container {
	var (
		venv   = "/opt/venv"
		appDir = "sdk/python"
	)

	src := c.Directory().WithDirectory("/", util.Repository(c).Directory(appDir))

	// We mirror the same dir structure from the repo because of the
	// relative paths in ruff (for docs linting).
	mountPath := fmt.Sprintf("/%s", appDir)

	return c.Container().
		From(fmt.Sprintf("python:%s-alpine", version)).
		WithExec([]string{"apk", "add", "-U", "--no-cache", "gcc", "musl-dev", "libffi-dev"}).
		WithMountedCache("/root/.cache/pip", c.CacheVolume("pip_cache")).
		WithMountedCache("/root/.cache/poetry", c.CacheVolume("poetry_cache")).
		WithExec([]string{"pip", "install", "--user", "poetry==1.5.1", "poetry-dynamic-versioning==0.23.0"}).
		// Don't really need a venv here but keeps the SDK's deps isolated
		// from poetry and system's packages.
		WithExec([]string{"python", "-m", "venv", venv}).
		WithEnvVariable("VIRTUAL_ENV", venv).
		WithEnvVariable(
			"PATH",
			"$VIRTUAL_ENV/bin:/root/.local/bin:$PATH",
			dagger.ContainerWithEnvVariableOpts{
				Expand: true,
			},
		).
		WithEnvVariable("POETRY_VIRTUALENVS_CREATE", "false").
		WithWorkdir(mountPath).
		WithFile(fmt.Sprintf("%s/poetry.lock", mountPath), src.File("poetry.lock")).
		// FIXME: Only use `poetry.lock` when able:
		// https://github.com/python-poetry/poetry/issues/1301
		WithFile(fmt.Sprintf("%s/pyproject.toml", mountPath), src.File("pyproject.toml")).
		WithExec([]string{"poetry", "install", "-E", "cli", "--no-root"}).
		WithDirectory(mountPath, src).
		WithExec([]string{"poetry", "install", "-E", "cli", "--only-root"})
}
