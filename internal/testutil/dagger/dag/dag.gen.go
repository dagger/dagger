// Code generated by dagger. DO NOT EDIT.

package dag

import (
	"context"
	"os"
	"sync"

	dagClient "dagger.io/dagger"
	dagger "github.com/dagger/dagger/internal/testutil/dagger"
)

var client *dagger.Client
var clientMu sync.Mutex

func initClient() *dagger.Client {
	clientMu.Lock()
	defer clientMu.Unlock()

	if client == nil {
		opts := []dagClient.ClientOpt{
			dagClient.WithLogOutput(os.Stdout),
		}

		ctx := context.Background()

		var err error
		client, err = dagger.Connect(ctx, opts...)
		if err != nil {
			panic(err)
		}
	}
	return client
}

// Close the engine connection
func Close() error {
	clientMu.Lock()
	defer clientMu.Unlock()

	var err error
	if client != nil {
		err = client.Close()
		client = nil
	}
	return err
}

// initialize an address to load directories, containers, secrets or other object types.
func Address(value string) *dagger.Address {
	client := initClient()
	return client.Address(value)
}

// Constructs a cache volume for a given cache key.
func CacheVolume(key string) *dagger.CacheVolume {
	client := initClient()
	return client.CacheVolume(key)
}

func Changelog(opts ...dagger.ChangelogOpts) *dagger.Changelog {
	client := initClient()
	return client.Changelog(opts...)
}

func Ci() *dagger.Ci {
	client := initClient()
	return client.Ci()
}

func Cli(opts ...dagger.CliOpts) *dagger.Cli {
	client := initClient()
	return client.Cli(opts...)
}

// Dagger Cloud configuration and state
func Cloud() *dagger.Cloud {
	client := initClient()
	return client.Cloud()
}

// Creates a scratch container, with no image or metadata.
//
// To pull an image, follow up with the "from" function.
func Container(opts ...dagger.ContainerOpts) *dagger.Container {
	client := initClient()
	return client.Container(opts...)
}

// Returns the current environment
//
// When called from a function invoked via an LLM tool call, this will be the LLM's current environment, including any modifications made through calling tools. Env values returned by functions become the new environment for subsequent calls, and Changeset values returned by functions are applied to the environment's workspace.
//
// When called from a module function outside of an LLM, this returns an Env with the current module installed, and with the current module's source directory as its workspace.
//
// Experimental: Programmatic env access is speculative and might be replaced.
func CurrentEnv() *dagger.Env {
	client := initClient()
	return client.CurrentEnv()
}

// The FunctionCall context that the SDK caller is currently executing in.
//
// If the caller is not currently executing in a function, this will return an error.
func CurrentFunctionCall() *dagger.FunctionCall {
	client := initClient()
	return client.CurrentFunctionCall()
}

// The module currently being served in the session, if any.
func CurrentModule() *dagger.CurrentModule {
	client := initClient()
	return client.CurrentModule()
}

// The TypeDef representations of the objects currently being served in the session.
func CurrentTypeDefs(ctx context.Context) ([]dagger.TypeDef, error) {
	client := initClient()
	return client.CurrentTypeDefs(ctx)
}

func DaggerDev() *dagger.DaggerDev {
	client := initClient()
	return client.DaggerDev()
}

// The default platform of the engine.
func DefaultPlatform(ctx context.Context) (dagger.Platform, error) {
	client := initClient()
	return client.DefaultPlatform(ctx)
}

// Creates an empty directory.
func Directory() *dagger.Directory {
	client := initClient()
	return client.Directory()
}

func Docs(opts ...dagger.DocsOpts) *dagger.Docs {
	client := initClient()
	return client.Docs(opts...)
}

func ElixirSDK(opts ...dagger.ElixirSDKOpts) *dagger.ElixirSDK {
	client := initClient()
	return client.ElixirSDK(opts...)
}

func EngineDev(opts ...dagger.EngineDevOpts) *dagger.EngineDev {
	client := initClient()
	return client.EngineDev(opts...)
}

// Initializes a new environment
//
// Experimental: Environments are not yet stabilized
func Env(opts ...dagger.EnvOpts) *dagger.Env {
	client := initClient()
	return client.Env(opts...)
}

// Initialize an environment file
func EnvFile(opts ...dagger.EnvFileOpts) *dagger.EnvFile {
	client := initClient()
	return client.EnvFile(opts...)
}

// Create a new error.
func Error(message string) *dagger.Error {
	client := initClient()
	return client.Error(message)
}

// Creates a file with the specified contents.
func File(name string, contents string, opts ...dagger.FileOpts) *dagger.File {
	client := initClient()
	return client.File(name, contents, opts...)
}

// Creates a function.
func Function(name string, returnType *dagger.TypeDef) *dagger.Function {
	client := initClient()
	return client.Function(name, returnType)
}

// Create a code generation result, given a directory containing the generated code.
func GeneratedCode(code *dagger.Directory) *dagger.GeneratedCode {
	client := initClient()
	return client.GeneratedCode(code)
}

// Queries a Git repository.
func Git(url string, opts ...dagger.GitOpts) *dagger.GitRepository {
	client := initClient()
	return client.Git(url, opts...)
}

func Go(opts ...dagger.GoOpts) *dagger.Go {
	client := initClient()
	return client.Go(opts...)
}

func GoSDK(opts ...dagger.GoSDKOpts) *dagger.GoSDK {
	client := initClient()
	return client.GoSDK(opts...)
}

func Helm(opts ...dagger.HelmOpts) *dagger.Helm {
	client := initClient()
	return client.Helm(opts...)
}

// Queries the host environment.
func Host() *dagger.Host {
	client := initClient()
	return client.Host()
}

// Returns a file containing an http remote url content.
func HTTP(url string, opts ...dagger.HTTPOpts) *dagger.File {
	client := initClient()
	return client.HTTP(url, opts...)
}

func Installers() *dagger.Installers {
	client := initClient()
	return client.Installers()
}

func JavaSDK(opts ...dagger.JavaSDKOpts) *dagger.JavaSDK {
	client := initClient()
	return client.JavaSDK(opts...)
}

// Initialize a JSON value
func JSON() *dagger.JSONValue {
	client := initClient()
	return client.JSON()
}

// Initialize a Large Language Model (LLM)
//
// Experimental: LLM support is not yet stabilized
func LLM(opts ...dagger.LLMOpts) *dagger.LLM {
	client := initClient()
	return client.LLM(opts...)
}

// Load a Address from its ID.
func LoadAddressFromID(id dagger.AddressID) *dagger.Address {
	client := initClient()
	return client.LoadAddressFromID(id)
}

// Load a Binding from its ID.
func LoadBindingFromID(id dagger.BindingID) *dagger.Binding {
	client := initClient()
	return client.LoadBindingFromID(id)
}

// Load a CacheVolume from its ID.
func LoadCacheVolumeFromID(id dagger.CacheVolumeID) *dagger.CacheVolume {
	client := initClient()
	return client.LoadCacheVolumeFromID(id)
}

// Load a Changelog from its ID.
func LoadChangelogFromID(id dagger.ChangelogID) *dagger.Changelog {
	client := initClient()
	return client.LoadChangelogFromID(id)
}

// Load a Changeset from its ID.
func LoadChangesetFromID(id dagger.ChangesetID) *dagger.Changeset {
	client := initClient()
	return client.LoadChangesetFromID(id)
}

// Load a Check from its ID.
func LoadCheckFromID(id dagger.CheckID) *dagger.Check {
	client := initClient()
	return client.LoadCheckFromID(id)
}

// Load a CheckGroup from its ID.
func LoadCheckGroupFromID(id dagger.CheckGroupID) *dagger.CheckGroup {
	client := initClient()
	return client.LoadCheckGroupFromID(id)
}

// Load a Ci from its ID.
func LoadCiFromID(id dagger.CiID) *dagger.Ci {
	client := initClient()
	return client.LoadCiFromID(id)
}

// Load a Cli from its ID.
func LoadCliFromID(id dagger.CliID) *dagger.Cli {
	client := initClient()
	return client.LoadCliFromID(id)
}

// Load a Cloud from its ID.
func LoadCloudFromID(id dagger.CloudID) *dagger.Cloud {
	client := initClient()
	return client.LoadCloudFromID(id)
}

// Load a Container from its ID.
func LoadContainerFromID(id dagger.ContainerID) *dagger.Container {
	client := initClient()
	return client.LoadContainerFromID(id)
}

// Load a CurrentModule from its ID.
func LoadCurrentModuleFromID(id dagger.CurrentModuleID) *dagger.CurrentModule {
	client := initClient()
	return client.LoadCurrentModuleFromID(id)
}

// Load a DaggerDev from its ID.
func LoadDaggerDevFromID(id dagger.DaggerDevID) *dagger.DaggerDev {
	client := initClient()
	return client.LoadDaggerDevFromID(id)
}

// Load a Directory from its ID.
func LoadDirectoryFromID(id dagger.DirectoryID) *dagger.Directory {
	client := initClient()
	return client.LoadDirectoryFromID(id)
}

// Load a Docs from its ID.
func LoadDocsFromID(id dagger.DocsID) *dagger.Docs {
	client := initClient()
	return client.LoadDocsFromID(id)
}

// Load a ElixirSdk from its ID.
func LoadElixirSDKFromID(id dagger.ElixirSDKID) *dagger.ElixirSDK {
	client := initClient()
	return client.LoadElixirSDKFromID(id)
}

// Load a EngineDev from its ID.
func LoadEngineDevFromID(id dagger.EngineDevID) *dagger.EngineDev {
	client := initClient()
	return client.LoadEngineDevFromID(id)
}

// Load a EngineDevLoadedEngine from its ID.
func LoadEngineDevLoadedEngineFromID(id dagger.EngineDevLoadedEngineID) *dagger.EngineDevLoadedEngine {
	client := initClient()
	return client.LoadEngineDevLoadedEngineFromID(id)
}

// Load a EnumTypeDef from its ID.
func LoadEnumTypeDefFromID(id dagger.EnumTypeDefID) *dagger.EnumTypeDef {
	client := initClient()
	return client.LoadEnumTypeDefFromID(id)
}

// Load a EnumValueTypeDef from its ID.
func LoadEnumValueTypeDefFromID(id dagger.EnumValueTypeDefID) *dagger.EnumValueTypeDef {
	client := initClient()
	return client.LoadEnumValueTypeDefFromID(id)
}

// Load a EnvFile from its ID.
func LoadEnvFileFromID(id dagger.EnvFileID) *dagger.EnvFile {
	client := initClient()
	return client.LoadEnvFileFromID(id)
}

// Load a Env from its ID.
func LoadEnvFromID(id dagger.EnvID) *dagger.Env {
	client := initClient()
	return client.LoadEnvFromID(id)
}

// Load a EnvVariable from its ID.
func LoadEnvVariableFromID(id dagger.EnvVariableID) *dagger.EnvVariable {
	client := initClient()
	return client.LoadEnvVariableFromID(id)
}

// Load a Error from its ID.
func LoadErrorFromID(id dagger.ErrorID) *dagger.Error {
	client := initClient()
	return client.LoadErrorFromID(id)
}

// Load a ErrorValue from its ID.
func LoadErrorValueFromID(id dagger.ErrorValueID) *dagger.ErrorValue {
	client := initClient()
	return client.LoadErrorValueFromID(id)
}

// Load a FieldTypeDef from its ID.
func LoadFieldTypeDefFromID(id dagger.FieldTypeDefID) *dagger.FieldTypeDef {
	client := initClient()
	return client.LoadFieldTypeDefFromID(id)
}

// Load a File from its ID.
func LoadFileFromID(id dagger.FileID) *dagger.File {
	client := initClient()
	return client.LoadFileFromID(id)
}

// Load a FunctionArg from its ID.
func LoadFunctionArgFromID(id dagger.FunctionArgID) *dagger.FunctionArg {
	client := initClient()
	return client.LoadFunctionArgFromID(id)
}

// Load a FunctionCallArgValue from its ID.
func LoadFunctionCallArgValueFromID(id dagger.FunctionCallArgValueID) *dagger.FunctionCallArgValue {
	client := initClient()
	return client.LoadFunctionCallArgValueFromID(id)
}

// Load a FunctionCall from its ID.
func LoadFunctionCallFromID(id dagger.FunctionCallID) *dagger.FunctionCall {
	client := initClient()
	return client.LoadFunctionCallFromID(id)
}

// Load a Function from its ID.
func LoadFunctionFromID(id dagger.FunctionID) *dagger.Function {
	client := initClient()
	return client.LoadFunctionFromID(id)
}

// Load a GeneratedCode from its ID.
func LoadGeneratedCodeFromID(id dagger.GeneratedCodeID) *dagger.GeneratedCode {
	client := initClient()
	return client.LoadGeneratedCodeFromID(id)
}

// Load a Generator from its ID.
func LoadGeneratorFromID(id dagger.GeneratorID) *dagger.Generator {
	client := initClient()
	return client.LoadGeneratorFromID(id)
}

// Load a GeneratorGroup from its ID.
func LoadGeneratorGroupFromID(id dagger.GeneratorGroupID) *dagger.GeneratorGroup {
	client := initClient()
	return client.LoadGeneratorGroupFromID(id)
}

// Load a GitRef from its ID.
func LoadGitRefFromID(id dagger.GitRefID) *dagger.GitRef {
	client := initClient()
	return client.LoadGitRefFromID(id)
}

// Load a GitRepository from its ID.
func LoadGitRepositoryFromID(id dagger.GitRepositoryID) *dagger.GitRepository {
	client := initClient()
	return client.LoadGitRepositoryFromID(id)
}

// Load a Go from its ID.
func LoadGoFromID(id dagger.GoID) *dagger.Go {
	client := initClient()
	return client.LoadGoFromID(id)
}

// Load a GoSdk from its ID.
func LoadGoSDKFromID(id dagger.GoSDKID) *dagger.GoSDK {
	client := initClient()
	return client.LoadGoSDKFromID(id)
}

// Load a Helm from its ID.
func LoadHelmFromID(id dagger.HelmID) *dagger.Helm {
	client := initClient()
	return client.LoadHelmFromID(id)
}

// Load a Host from its ID.
func LoadHostFromID(id dagger.HostID) *dagger.Host {
	client := initClient()
	return client.LoadHostFromID(id)
}

// Load a InputTypeDef from its ID.
func LoadInputTypeDefFromID(id dagger.InputTypeDefID) *dagger.InputTypeDef {
	client := initClient()
	return client.LoadInputTypeDefFromID(id)
}

// Load a Installers from its ID.
func LoadInstallersFromID(id dagger.InstallersID) *dagger.Installers {
	client := initClient()
	return client.LoadInstallersFromID(id)
}

// Load a InterfaceTypeDef from its ID.
func LoadInterfaceTypeDefFromID(id dagger.InterfaceTypeDefID) *dagger.InterfaceTypeDef {
	client := initClient()
	return client.LoadInterfaceTypeDefFromID(id)
}

// Load a JSONValue from its ID.
func LoadJSONValueFromID(id dagger.JSONValueID) *dagger.JSONValue {
	client := initClient()
	return client.LoadJSONValueFromID(id)
}

// Load a JavaSdk from its ID.
func LoadJavaSDKFromID(id dagger.JavaSDKID) *dagger.JavaSDK {
	client := initClient()
	return client.LoadJavaSDKFromID(id)
}

// Load a LLM from its ID.
func LoadLLMFromID(id dagger.LLMID) *dagger.LLM {
	client := initClient()
	return client.LoadLLMFromID(id)
}

// Load a LLMTokenUsage from its ID.
func LoadLLMTokenUsageFromID(id dagger.LLMTokenUsageID) *dagger.LLMTokenUsage {
	client := initClient()
	return client.LoadLLMTokenUsageFromID(id)
}

// Load a Label from its ID.
func LoadLabelFromID(id dagger.LabelID) *dagger.Label {
	client := initClient()
	return client.LoadLabelFromID(id)
}

// Load a ListTypeDef from its ID.
func LoadListTypeDefFromID(id dagger.ListTypeDefID) *dagger.ListTypeDef {
	client := initClient()
	return client.LoadListTypeDefFromID(id)
}

// Load a ModuleConfigClient from its ID.
func LoadModuleConfigClientFromID(id dagger.ModuleConfigClientID) *dagger.ModuleConfigClient {
	client := initClient()
	return client.LoadModuleConfigClientFromID(id)
}

// Load a Module from its ID.
func LoadModuleFromID(id dagger.ModuleID) *dagger.Module {
	client := initClient()
	return client.LoadModuleFromID(id)
}

// Load a ModuleSource from its ID.
func LoadModuleSourceFromID(id dagger.ModuleSourceID) *dagger.ModuleSource {
	client := initClient()
	return client.LoadModuleSourceFromID(id)
}

// Load a ObjectTypeDef from its ID.
func LoadObjectTypeDefFromID(id dagger.ObjectTypeDefID) *dagger.ObjectTypeDef {
	client := initClient()
	return client.LoadObjectTypeDefFromID(id)
}

// Load a PhpSdk from its ID.
func LoadPhpSDKFromID(id dagger.PhpSDKID) *dagger.PhpSDK {
	client := initClient()
	return client.LoadPhpSDKFromID(id)
}

// Load a Port from its ID.
func LoadPortFromID(id dagger.PortID) *dagger.Port {
	client := initClient()
	return client.LoadPortFromID(id)
}

// Load a PythonSdkDocs from its ID.
func LoadPythonSDKDocsFromID(id dagger.PythonSDKDocsID) *dagger.PythonSDKDocs {
	client := initClient()
	return client.LoadPythonSDKDocsFromID(id)
}

// Load a PythonSdk from its ID.
func LoadPythonSDKFromID(id dagger.PythonSDKID) *dagger.PythonSDK {
	client := initClient()
	return client.LoadPythonSDKFromID(id)
}

// Load a PythonSdkTestSuite from its ID.
func LoadPythonSDKTestSuiteFromID(id dagger.PythonSDKTestSuiteID) *dagger.PythonSDKTestSuite {
	client := initClient()
	return client.LoadPythonSDKTestSuiteFromID(id)
}

// Load a Release from its ID.
func LoadReleaseFromID(id dagger.ReleaseID) *dagger.Release {
	client := initClient()
	return client.LoadReleaseFromID(id)
}

// Load a ReleaseReportArtifact from its ID.
func LoadReleaseReportArtifactFromID(id dagger.ReleaseReportArtifactID) *dagger.ReleaseReportArtifact {
	client := initClient()
	return client.LoadReleaseReportArtifactFromID(id)
}

// Load a ReleaseReportFollowUp from its ID.
func LoadReleaseReportFollowUpFromID(id dagger.ReleaseReportFollowUpID) *dagger.ReleaseReportFollowUp {
	client := initClient()
	return client.LoadReleaseReportFollowUpFromID(id)
}

// Load a ReleaseReport from its ID.
func LoadReleaseReportFromID(id dagger.ReleaseReportID) *dagger.ReleaseReport {
	client := initClient()
	return client.LoadReleaseReportFromID(id)
}

// Load a RustSdk from its ID.
func LoadRustSDKFromID(id dagger.RustSDKID) *dagger.RustSDK {
	client := initClient()
	return client.LoadRustSDKFromID(id)
}

// Load a SDKConfig from its ID.
func LoadSDKConfigFromID(id dagger.SDKConfigID) *dagger.SDKConfig {
	client := initClient()
	return client.LoadSDKConfigFromID(id)
}

// Load a ScalarTypeDef from its ID.
func LoadScalarTypeDefFromID(id dagger.ScalarTypeDefID) *dagger.ScalarTypeDef {
	client := initClient()
	return client.LoadScalarTypeDefFromID(id)
}

// Load a Sdks from its ID.
func LoadSdksFromID(id dagger.SdksID) *dagger.Sdks {
	client := initClient()
	return client.LoadSdksFromID(id)
}

// Load a SearchResult from its ID.
func LoadSearchResultFromID(id dagger.SearchResultID) *dagger.SearchResult {
	client := initClient()
	return client.LoadSearchResultFromID(id)
}

// Load a SearchSubmatch from its ID.
func LoadSearchSubmatchFromID(id dagger.SearchSubmatchID) *dagger.SearchSubmatch {
	client := initClient()
	return client.LoadSearchSubmatchFromID(id)
}

// Load a Secret from its ID.
func LoadSecretFromID(id dagger.SecretID) *dagger.Secret {
	client := initClient()
	return client.LoadSecretFromID(id)
}

// Load a Security from its ID.
func LoadSecurityFromID(id dagger.SecurityID) *dagger.Security {
	client := initClient()
	return client.LoadSecurityFromID(id)
}

// Load a Service from its ID.
func LoadServiceFromID(id dagger.ServiceID) *dagger.Service {
	client := initClient()
	return client.LoadServiceFromID(id)
}

// Load a Socket from its ID.
func LoadSocketFromID(id dagger.SocketID) *dagger.Socket {
	client := initClient()
	return client.LoadSocketFromID(id)
}

// Load a SourceMap from its ID.
func LoadSourceMapFromID(id dagger.SourceMapID) *dagger.SourceMap {
	client := initClient()
	return client.LoadSourceMapFromID(id)
}

// Load a Stat from its ID.
func LoadStatFromID(id dagger.StatID) *dagger.Stat {
	client := initClient()
	return client.LoadStatFromID(id)
}

// Load a Terminal from its ID.
func LoadTerminalFromID(id dagger.TerminalID) *dagger.Terminal {
	client := initClient()
	return client.LoadTerminalFromID(id)
}

// Load a TestSplit from its ID.
func LoadTestSplitFromID(id dagger.TestSplitID) *dagger.TestSplit {
	client := initClient()
	return client.LoadTestSplitFromID(id)
}

// Load a TypeDef from its ID.
func LoadTypeDefFromID(id dagger.TypeDefID) *dagger.TypeDef {
	client := initClient()
	return client.LoadTypeDefFromID(id)
}

// Load a TypescriptSdk from its ID.
func LoadTypescriptSDKFromID(id dagger.TypescriptSDKID) *dagger.TypescriptSDK {
	client := initClient()
	return client.LoadTypescriptSDKFromID(id)
}

// Create a new module.
func Module() *dagger.Module {
	client := initClient()
	return client.Module()
}

// Create a new module source instance from a source ref string
func ModuleSource(refString string, opts ...dagger.ModuleSourceOpts) *dagger.ModuleSource {
	client := initClient()
	return client.ModuleSource(refString, opts...)
}

// Develop the Dagger PHP SDK (experimental)
func PhpSDK(opts ...dagger.PhpSDKOpts) *dagger.PhpSDK {
	client := initClient()
	return client.PhpSDK(opts...)
}

func PythonSDK(opts ...dagger.PythonSDKOpts) *dagger.PythonSDK {
	client := initClient()
	return client.PythonSDK(opts...)
}

func Release() *dagger.Release {
	client := initClient()
	return client.Release()
}

func RustSDK(opts ...dagger.RustSDKOpts) *dagger.RustSDK {
	client := initClient()
	return client.RustSDK(opts...)
}

func Sdks() *dagger.Sdks {
	client := initClient()
	return client.Sdks()
}

// Creates a new secret.
func Secret(uri string, opts ...dagger.SecretOpts) *dagger.Secret {
	client := initClient()
	return client.Secret(uri, opts...)
}

func Security() *dagger.Security {
	client := initClient()
	return client.Security()
}

// Sets a secret given a user defined name to its plaintext and returns the secret.
//
// The plaintext value is limited to a size of 128000 bytes.
func SetSecret(name string, plaintext string) *dagger.Secret {
	client := initClient()
	return client.SetSecret(name, plaintext)
}

// Creates source map metadata.
func SourceMap(filename string, line int, column int) *dagger.SourceMap {
	client := initClient()
	return client.SourceMap(filename, line, column)
}

func TestSplit() *dagger.TestSplit {
	client := initClient()
	return client.TestSplit()
}

// Create a new TypeDef.
func TypeDef() *dagger.TypeDef {
	client := initClient()
	return client.TypeDef()
}

func TypescriptSDK(opts ...dagger.TypescriptSDKOpts) *dagger.TypescriptSDK {
	client := initClient()
	return client.TypescriptSDK(opts...)
}

// Get the current Dagger Engine version.
func Version(ctx context.Context) (string, error) {
	client := initClient()
	return client.Version(ctx)
}
