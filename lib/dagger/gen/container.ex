# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.Container do
  @moduledoc "An OCI-compatible container, also known as a docker container."
  use Dagger.QueryBuilder
  defstruct [:selection, :client]

  def build(container, opts) do
    selection = select(container.selection, "build")
    selection = arg(selection, to_string(:context), Keyword.fetch!(opts, :context))

    {_opts, selection} =
      [:dockerfile, :build_args, :target]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def default_args(container) do
    selection = select(container.selection, "defaultArgs")
    execute(selection, container.client)
  end

  def directory(container, opts) do
    selection = select(container.selection, "directory")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.Directory{selection: selection, client: container.client}
  end

  def endpoint(container, opts) do
    selection = select(container.selection, "endpoint")

    {_opts, selection} =
      [:port, :scheme]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    execute(selection, container.client)
  end

  def entrypoint(container) do
    selection = select(container.selection, "entrypoint")
    execute(selection, container.client)
  end

  def env_variable(container, opts) do
    selection = select(container.selection, "envVariable")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    execute(selection, container.client)
  end

  def env_variables(container) do
    selection = select(container.selection, "envVariables")
    execute(selection, container.client)
  end

  def exec(container, opts) do
    selection = select(container.selection, "exec")

    {_opts, selection} =
      [:args, :stdin, :redirect_stdout, :redirect_stderr, :experimental_privileged_nesting]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def exit_code(container) do
    selection = select(container.selection, "exitCode")
    execute(selection, container.client)
  end

  def export(container, opts) do
    selection = select(container.selection, "export")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))

    {_opts, selection} =
      [:platform_variants]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    execute(selection, container.client)
  end

  def exposed_ports(container) do
    selection = select(container.selection, "exposedPorts")
    execute(selection, container.client)
  end

  def file(container, opts) do
    selection = select(container.selection, "file")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.File{selection: selection, client: container.client}
  end

  def from(container, opts) do
    selection = select(container.selection, "from")
    selection = arg(selection, to_string(:address), Keyword.fetch!(opts, :address))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def fs(container) do
    selection = select(container.selection, "fs")
    %Dagger.Directory{selection: selection, client: container.client}
  end

  def hostname(container) do
    selection = select(container.selection, "hostname")
    execute(selection, container.client)
  end

  def id(container) do
    selection = select(container.selection, "id")
    execute(selection, container.client)
  end

  def image_ref(container) do
    selection = select(container.selection, "imageRef")
    execute(selection, container.client)
  end

  def label(container, opts) do
    selection = select(container.selection, "label")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    execute(selection, container.client)
  end

  def labels(container) do
    selection = select(container.selection, "labels")
    execute(selection, container.client)
  end

  def mounts(container) do
    selection = select(container.selection, "mounts")
    execute(selection, container.client)
  end

  def pipeline(container, opts) do
    selection = select(container.selection, "pipeline")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))

    {_opts, selection} =
      [:description, :labels]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def platform(container) do
    selection = select(container.selection, "platform")
    execute(selection, container.client)
  end

  def publish(container, opts) do
    selection = select(container.selection, "publish")
    selection = arg(selection, to_string(:address), Keyword.fetch!(opts, :address))

    {_opts, selection} =
      [:platform_variants]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    execute(selection, container.client)
  end

  def rootfs(container) do
    selection = select(container.selection, "rootfs")
    %Dagger.Directory{selection: selection, client: container.client}
  end

  def stderr(container) do
    selection = select(container.selection, "stderr")
    execute(selection, container.client)
  end

  def stdout(container) do
    selection = select(container.selection, "stdout")
    execute(selection, container.client)
  end

  def user(container) do
    selection = select(container.selection, "user")
    execute(selection, container.client)
  end

  def with_default_args(container, opts) do
    selection = select(container.selection, "withDefaultArgs")

    {_opts, selection} =
      [:args]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_directory(container, opts) do
    selection = select(container.selection, "withDirectory")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:directory), Keyword.fetch!(opts, :directory))

    {_opts, selection} =
      [:exclude, :include]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_entrypoint(container, opts) do
    selection = select(container.selection, "withEntrypoint")
    selection = arg(selection, to_string(:args), Keyword.fetch!(opts, :args))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_env_variable(container, opts) do
    selection = select(container.selection, "withEnvVariable")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    selection = arg(selection, to_string(:value), Keyword.fetch!(opts, :value))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_exec(container, opts) do
    selection = select(container.selection, "withExec")
    selection = arg(selection, to_string(:args), Keyword.fetch!(opts, :args))

    {_opts, selection} =
      [
        :stdin,
        :redirect_stdout,
        :redirect_stderr,
        :experimental_privileged_nesting,
        :insecure_root_capabilities
      ]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_exposed_port(container, opts) do
    selection = select(container.selection, "withExposedPort")
    selection = arg(selection, to_string(:port), Keyword.fetch!(opts, :port))

    {_opts, selection} =
      [:protocol, :description]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_fs(container, opts) do
    selection = select(container.selection, "withFs")
    selection = arg(selection, to_string(:id), Keyword.fetch!(opts, :id))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_file(container, opts) do
    selection = select(container.selection, "withFile")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:source), Keyword.fetch!(opts, :source))

    {_opts, selection} =
      [:permissions]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_label(container, opts) do
    selection = select(container.selection, "withLabel")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    selection = arg(selection, to_string(:value), Keyword.fetch!(opts, :value))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_mounted_cache(container, opts) do
    selection = select(container.selection, "withMountedCache")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:cache), Keyword.fetch!(opts, :cache))

    {_opts, selection} =
      [:source, :sharing]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_mounted_directory(container, opts) do
    selection = select(container.selection, "withMountedDirectory")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:source), Keyword.fetch!(opts, :source))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_mounted_file(container, opts) do
    selection = select(container.selection, "withMountedFile")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:source), Keyword.fetch!(opts, :source))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_mounted_secret(container, opts) do
    selection = select(container.selection, "withMountedSecret")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:source), Keyword.fetch!(opts, :source))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_mounted_temp(container, opts) do
    selection = select(container.selection, "withMountedTemp")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_new_file(container, opts) do
    selection = select(container.selection, "withNewFile")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))

    {_opts, selection} =
      [:contents, :permissions]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_registry_auth(container, opts) do
    selection = select(container.selection, "withRegistryAuth")
    selection = arg(selection, to_string(:address), Keyword.fetch!(opts, :address))
    selection = arg(selection, to_string(:username), Keyword.fetch!(opts, :username))
    selection = arg(selection, to_string(:secret), Keyword.fetch!(opts, :secret))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_rootfs(container, opts) do
    selection = select(container.selection, "withRootfs")
    selection = arg(selection, to_string(:id), Keyword.fetch!(opts, :id))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_secret_variable(container, opts) do
    selection = select(container.selection, "withSecretVariable")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    selection = arg(selection, to_string(:secret), Keyword.fetch!(opts, :secret))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_service_binding(container, opts) do
    selection = select(container.selection, "withServiceBinding")
    selection = arg(selection, to_string(:alias), Keyword.fetch!(opts, :alias))
    selection = arg(selection, to_string(:service), Keyword.fetch!(opts, :service))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_unix_socket(container, opts) do
    selection = select(container.selection, "withUnixSocket")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    selection = arg(selection, to_string(:source), Keyword.fetch!(opts, :source))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_user(container, opts) do
    selection = select(container.selection, "withUser")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def with_workdir(container, opts) do
    selection = select(container.selection, "withWorkdir")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_env_variable(container, opts) do
    selection = select(container.selection, "withoutEnvVariable")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_exposed_port(container, opts) do
    selection = select(container.selection, "withoutExposedPort")
    selection = arg(selection, to_string(:port), Keyword.fetch!(opts, :port))

    {_opts, selection} =
      [:protocol]
      |> Enum.reduce({opts, selection}, fn arg, {opts, selection} ->
        if not is_nil(opts[arg]) do
          {opts, arg(selection, to_string(arg), opts[arg])}
        else
          {opts, selection}
        end
      end)

    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_label(container, opts) do
    selection = select(container.selection, "withoutLabel")
    selection = arg(selection, to_string(:name), Keyword.fetch!(opts, :name))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_mount(container, opts) do
    selection = select(container.selection, "withoutMount")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_registry_auth(container, opts) do
    selection = select(container.selection, "withoutRegistryAuth")
    selection = arg(selection, to_string(:address), Keyword.fetch!(opts, :address))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def without_unix_socket(container, opts) do
    selection = select(container.selection, "withoutUnixSocket")
    selection = arg(selection, to_string(:path), Keyword.fetch!(opts, :path))
    %Dagger.Container{selection: selection, client: container.client}
  end

  def workdir(container) do
    selection = select(container.selection, "workdir")
    execute(selection, container.client)
  end
end
