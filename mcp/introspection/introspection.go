package introspection

import (
	_ "embed"
	"fmt"
	"io"
	"iter"
	"regexp"
	"sort"
	"strings"

	"github.com/koron-go/prefixw"
)

// Query is the query generated by graphiql to determine type information
//
//go:embed query.graphql
var Query string

// Response is the introspection query response
type Response struct {
	Schema        *Schema `json:"__schema"`
	SchemaVersion string  `json:"__schemaVersion"`
}

type Schema struct {
	QueryType struct {
		Name string `json:"name,omitempty"`
	} `json:"queryType,omitempty"`
	MutationType *struct {
		Name string `json:"name,omitempty"`
	} `json:"mutationType,omitempty"`
	SubscriptionType *struct {
		Name string `json:"name,omitempty"`
	} `json:"subscriptionType,omitempty"`

	Types      Types `json:"types"`
	Directives any   `json:"directives"`
}

func (s *Schema) RenderSDL(w io.Writer) {
	// Write schema definition if any root types have non-default names
	needSchemaDefinition := false
	defaultNames := map[string]string{
		s.QueryType.Name: "Query",
	}
	if s.MutationType != nil {
		defaultNames[s.MutationType.Name] = "Mutation"
	}
	if s.SubscriptionType != nil {
		defaultNames[s.SubscriptionType.Name] = "Subscription"
	}

	for typeName, defaultName := range defaultNames {
		if typeName != "" && typeName != defaultName {
			needSchemaDefinition = true
			break
		}
	}

	if needSchemaDefinition {
		fmt.Fprintln(w, "schema {")
		if s.QueryType.Name != "" {
			fmt.Fprintf(w, "  query: %s\n", s.QueryType.Name)
		}
		if s.MutationType != nil && s.MutationType.Name != "" {
			fmt.Fprintf(w, "  mutation: %s\n", s.MutationType.Name)
		}
		if s.SubscriptionType != nil && s.SubscriptionType.Name != "" {
			fmt.Fprintf(w, "  subscription: %s\n", s.SubscriptionType.Name)
		}
		fmt.Fprintln(w, "}")
		fmt.Fprintln(w) // Add blank line after schema definition
	}

	// Sort types by kind and name for consistent output
	sortedTypes := make([]*Type, len(s.Types))
	copy(sortedTypes, s.Types)
	sort.Slice(sortedTypes, func(i, j int) bool {
		if sortedTypes[i].Kind != sortedTypes[j].Kind {
			return sortedTypes[i].Kind < sortedTypes[j].Kind
		}
		return sortedTypes[i].Name < sortedTypes[j].Name
	})

	// Write all types
	for i, t := range sortedTypes {
		// Skip built-in types
		if isBuiltinType(t.Name) {
			continue
		}

		// Add blank line between types
		if i > 0 {
			fmt.Fprintln(w)
		}

		t.RenderSDL(w)
		fmt.Fprintln(w)
	}
}

// isBuiltinType returns true if the type name is a GraphQL built-in
func isBuiltinType(name string) bool {
	builtins := map[string]bool{
		"Boolean":             true,
		"Float":               true,
		"ID":                  true,
		"Int":                 true,
		"String":              true,
		"__Schema":            true,
		"__Type":              true,
		"__TypeKind":          true,
		"__Field":             true,
		"__InputValue":        true,
		"__EnumValue":         true,
		"__Directive":         true,
		"__DirectiveLocation": true,
	}
	return builtins[name]
}

func (s *Schema) Query() *Type {
	return s.Types.Get(s.QueryType.Name)
}

func (s *Schema) Mutation() *Type {
	if s.MutationType == nil {
		return nil
	}
	return s.Types.Get(s.MutationType.Name)
}

func (s *Schema) Subscription() *Type {
	if s.SubscriptionType == nil {
		return nil
	}
	return s.Types.Get(s.SubscriptionType.Name)
}

// Remove all occurrences of a type from the schema, including
// any fields, input fields, and enum values that reference it.
func (s *Schema) ScrubType(typeName string) {
	filteredTypes := make(Types, 0, len(s.Types))
	for _, t := range s.Types {
		if t.ScrubType(typeName) {
			continue
		}
		filteredTypes = append(filteredTypes, t)
	}
	s.Types = filteredTypes
}

func (s *Schema) OnlyType(typeName string) {
	allTypes := s.Types

	requestedType := s.Types.Get(typeName)
	if requestedType == nil {
		// filter all out so this is noticeable
		s.Types = nil
		return
	}

	filteredTypes := make(Types, 0, len(s.Types))
	filteredTypes = append(filteredTypes, requestedType)
	for t := range requestedType.NamedTypes(allTypes) {
		// don't include other object types; only dependent inputs etc.
		if t.Kind != TypeKindObject {
			filteredTypes = append(filteredTypes, t)
		}
	}
	s.Types = filteredTypes
}

type TypeKind string

const (
	TypeKindScalar      = TypeKind("SCALAR")
	TypeKindObject      = TypeKind("OBJECT")
	TypeKindInterface   = TypeKind("INTERFACE")
	TypeKindUnion       = TypeKind("UNION")
	TypeKindEnum        = TypeKind("ENUM")
	TypeKindInputObject = TypeKind("INPUT_OBJECT")
	TypeKindList        = TypeKind("LIST")
	TypeKindNonNull     = TypeKind("NON_NULL")
)

type Scalar string

const (
	ScalarInt     = Scalar("Int")
	ScalarFloat   = Scalar("Float")
	ScalarString  = Scalar("String")
	ScalarBoolean = Scalar("Boolean")
	ScalarVoid    = Scalar("Void")
)

type Type struct {
	Kind        TypeKind     `json:"kind"`
	Name        string       `json:"name"`
	Description string       `json:"description,omitempty"`
	Fields      []*Field     `json:"fields,omitempty"`
	InputFields []InputValue `json:"inputFields,omitempty"`
	EnumValues  []EnumValue  `json:"enumValues,omitempty"`
	Interfaces  []*Type      `json:"interfaces"`
	Directives  Directives   `json:"directives"`
}

func (v *Type) RenderSDL(w io.Writer) {
	// Write description if present
	if v.Description != "" {
		fmt.Fprintln(w, `"""`)
		fmt.Fprintln(w, v.Description)
		fmt.Fprintln(w, `"""`)
	}

	// Write type kind (type, input, enum, etc) and name
	switch v.Kind {
	case TypeKindInputObject:
		fmt.Fprintf(w, "input %s", v.Name)
	case TypeKindEnum:
		fmt.Fprintf(w, "enum %s", v.Name)
	case TypeKindInterface:
		fmt.Fprintf(w, "interface %s", v.Name)
	case TypeKindScalar:
		fmt.Fprintf(w, "scalar %s", v.Name)
	case TypeKindUnion:
		fmt.Fprintf(w, "union %s", v.Name)
	default:
		fmt.Fprintf(w, "type %s", v.Name)
	}

	// Write implemented interfaces if any
	if len(v.Interfaces) > 0 {
		fmt.Fprint(w, " implements")
		for i, iface := range v.Interfaces {
			if i > 0 {
				fmt.Fprint(w, " &")
			}
			fmt.Fprintf(w, " %s", iface.Name)
		}
	}

	// Write directives if any
	if len(v.Directives) > 0 {
		v.Directives.RenderSDL(w)
	}

	if v.Kind == TypeKindScalar {
		return
	}

	fmt.Fprintln(w, " {")

	indentW := prefixw.New(w, "  ")

	// Render appropriate fields based on type kind
	switch v.Kind {
	case TypeKindEnum:
		for i, ev := range v.EnumValues {
			if i > 0 {
				fmt.Fprintln(indentW)
			}
			ev.RenderSDL(indentW)
			fmt.Fprintln(indentW)
		}
	case TypeKindInputObject:
		for i, f := range v.InputFields {
			if i > 0 {
				fmt.Fprintln(indentW)
			}
			f.RenderSDL(indentW)
			fmt.Fprintln(indentW)
		}
	default:
		for i, f := range v.Fields {
			if i > 0 {
				fmt.Fprintln(indentW)
			}
			f.RenderSDL(indentW)
			fmt.Fprintln(indentW)
		}
	}

	indentW.Close()

	fmt.Fprintln(w, "}")
}

// Remove all occurrences of a type from the schema, including
// any fields, input fields, and enum values that reference it.
// Returns true if this type should be removed, whether because
// it is the type being scrubbed, or because it is now empty after
// scrubbing its references.
func (t *Type) ScrubType(typeName string) bool {
	if t.Kind == TypeKindScalar {
		return t.Name == typeName
	}

	filteredFields := make([]*Field, 0, len(t.Fields))
	for _, f := range t.Fields {
		if f.TypeRef.ReferencesType(typeName) {
			continue
		}
		filteredFields = append(filteredFields, f)
	}
	t.Fields = filteredFields

	filteredInputFields := make([]InputValue, 0, len(t.InputFields))
	for _, f := range t.InputFields {
		if f.Name == typeName {
			continue
		}
		if f.TypeRef.ReferencesType(typeName) {
			continue
		}
		filteredInputFields = append(filteredInputFields, f)
	}
	t.InputFields = filteredInputFields

	filteredEnumValues := make([]EnumValue, 0, len(t.EnumValues))
	for _, e := range t.EnumValues {
		if e.Name == typeName {
			continue
		}
		filteredEnumValues = append(filteredEnumValues, e)
	}
	t.EnumValues = filteredEnumValues

	// check if we removed everything from it, in which case it should
	// be removed itself
	isEmpty := len(t.Fields) == 0 && len(t.InputFields) == 0 && len(t.EnumValues) == 0
	return t.Name == typeName || isEmpty
}

func (t *Type) NamedTypes(types Types) iter.Seq[*Type] {
	return func(yield func(*Type) bool) {
		alreadyNamed := map[string]*Type{}
		walk := func(name string) bool {
			if _, named := alreadyNamed[name]; !named {
				t := types.Get(name)
				alreadyNamed[name] = t
				return yield(t)
			}
			return true
		}
		for _, f := range t.Fields {
			walk(f.TypeRef.NamedType())
			for _, arg := range f.Args {
				walk(arg.TypeRef.NamedType())
			}
		}
	}
}

type Types []*Type

func (t Types) Get(name string) *Type {
	for _, i := range t {
		if i.Name == name {
			return i
		}
	}
	return nil
}

type Field struct {
	Name              string      `json:"name"`
	Description       string      `json:"description"`
	TypeRef           *TypeRef    `json:"type"`
	Args              InputValues `json:"args"`
	IsDeprecated      bool        `json:"isDeprecated"`
	DeprecationReason string      `json:"deprecationReason"`
	Directives        Directives  `json:"directives"`
}

func (t Directives) RenderSDL(w io.Writer) {
	indentW := prefixw.New(w, "  ")
	for _, d := range t {
		d.RenderSDL(indentW)
	}
	indentW.Close()
}

func (v *Field) RenderSDL(w io.Writer) {
	// Write description if present
	if v.Description != "" {
		fmt.Fprintln(w, `"""`)
		fmt.Fprintln(w, v.Description)
		fmt.Fprintln(w, `"""`)
	}

	// Write field name
	fmt.Fprint(w, v.Name)

	// Write arguments if present
	if len(v.Args) > 0 {
		fmt.Fprintln(w, "(")
		indentW := prefixw.New(w, "  ")
		for i, arg := range v.Args {
			if i > 0 {
				fmt.Fprintln(indentW)
			}
			arg.RenderSDL(indentW)
			fmt.Fprintln(indentW)
		}
		indentW.Close()
		fmt.Fprint(w, ")")
	}

	// Write field type
	fmt.Fprintf(w, ": %s", v.TypeRef)

	// Write directives if present
	if len(v.Directives) > 0 {
		v.Directives.RenderSDL(w)
	}

	// Write deprecation directive if deprecated
	if v.IsDeprecated {
		fmt.Fprint(w, " @deprecated")
		if v.DeprecationReason != "" {
			fmt.Fprintf(w, `(reason: %q)`, v.DeprecationReason)
		}
	}
}

func (f *Field) ReferencesType(typeName string) bool {
	// check return
	if f.TypeRef.ReferencesType(typeName) {
		return true
	}
	// check args
	for _, arg := range f.Args {
		if arg.TypeRef.ReferencesType(typeName) {
			return true
		}
	}
	return false
}

type TypeRef struct {
	Kind   TypeKind `json:"kind"`
	Name   string   `json:"name,omitempty"`
	OfType *TypeRef `json:"ofType,omitempty"`
}

func (r TypeRef) IsOptional() bool {
	return r.Kind != TypeKindNonNull
}

func (r TypeRef) IsScalar() bool {
	ref := r
	if r.Kind == TypeKindNonNull {
		ref = *ref.OfType
	}
	if ref.Kind == TypeKindScalar {
		return true
	}
	if ref.Kind == TypeKindEnum {
		return true
	}
	return false
}

func (r TypeRef) IsObject() bool {
	ref := r
	if r.Kind == TypeKindNonNull {
		ref = *ref.OfType
	}
	if ref.Kind == TypeKindObject {
		return true
	}
	return false
}

func (r TypeRef) IsList() bool {
	ref := r
	if r.Kind == TypeKindNonNull {
		ref = *ref.OfType
	}
	if ref.Kind == TypeKindList {
		return true
	}
	return false
}

func (r TypeRef) IsVoid() bool {
	ref := r
	if r.Kind == TypeKindNonNull {
		ref = *ref.OfType
	}
	return ref.Kind == TypeKindScalar && ref.Name == string(ScalarVoid)
}

func (r TypeRef) ReferencesType(typeName string) bool {
	if r.OfType != nil {
		return r.OfType.ReferencesType(typeName)
	}
	return r.Name == typeName
}

func (r TypeRef) NamedType() string {
	if r.OfType != nil {
		return r.OfType.NamedType()
	}
	return r.Name
}

func (r TypeRef) String() string {
	switch r.Kind {
	case TypeKindList:
		return "[" + r.OfType.String() + "]"
	case TypeKindNonNull:
		return r.OfType.String() + "!"
	default:
		return r.Name
	}
}

type InputValues []InputValue

func (i InputValues) HasOptionals() bool {
	for _, v := range i {
		if v.IsOptional() {
			return true
		}
	}
	return false
}

type InputValue struct {
	Name         string     `json:"name"`
	Description  string     `json:"description"`
	DefaultValue *string    `json:"defaultValue"`
	TypeRef      *TypeRef   `json:"type"`
	Directives   Directives `json:"directives"`
}

func (v InputValue) IsOptional() bool {
	return v.DefaultValue != nil || (v.TypeRef != nil && v.TypeRef.IsOptional())
}

func (v InputValue) RenderSDL(w io.Writer) {
	if v.Description != "" {
		fmt.Fprintln(w, `"""`)
		fmt.Fprintln(w, v.Description)
		fmt.Fprintln(w, `"""`)
	}
	fmt.Fprintf(w, "%s: %s", v.Name, v.TypeRef)
	if v.DefaultValue != nil {
		fmt.Fprintf(w, " = %s", *v.DefaultValue)
	}
	v.Directives.RenderSDL(w)
}

type EnumValue struct {
	Name              string     `json:"name"`
	Description       string     `json:"description"`
	IsDeprecated      bool       `json:"isDeprecated"`
	DeprecationReason string     `json:"deprecationReason"`
	Directives        Directives `json:"directives"`
}

func (v *EnumValue) RenderSDL(w io.Writer) {
	// Write description if present
	if v.Description != "" {
		fmt.Fprintln(w, `"""`)
		fmt.Fprintln(w, v.Description)
		fmt.Fprintln(w, `"""`)
	}

	// Write enum value name
	fmt.Fprint(w, v.Name)

	// Write directives if present
	if len(v.Directives) > 0 {
		v.Directives.RenderSDL(w)
	}

	// Write deprecation directive if deprecated
	if v.IsDeprecated {
		fmt.Fprint(w, " @deprecated")
		if v.DeprecationReason != "" {
			fmt.Fprintf(w, `(reason: %q)`, v.DeprecationReason)
		}
	}
}

type Directives []*Directive

func (t Directives) Directive(name string) *Directive {
	for _, i := range t {
		if i.Name == name {
			return i
		}
	}
	return nil
}

type SourceMap struct {
	Module   string
	Filename string
	Line     string
	Column   string
}

func (sourceMap *SourceMap) Filelink() string {
	return fmt.Sprintf("%s:%s:%s", sourceMap.Filename, sourceMap.Line, sourceMap.Column)
}

func (t *Directives) SourceMap() *SourceMap {
	d := t.Directive("sourceMap")
	if d == nil {
		return nil
	}
	return &SourceMap{
		Module:   *d.Arg("module").Value,
		Filename: *d.Arg("filename").Value,
		Line:     *d.Arg("line").Value,
		Column:   *d.Arg("column").Value,
	}
}

type Directive struct {
	Name string          `json:"name"`
	Args []*DirectiveArg `json:"args"`
}

func (t Directive) Arg(name string) *DirectiveArg {
	for _, i := range t.Args {
		if i.Name == name {
			return i
		}
	}
	return nil
}

func (t *Directive) RenderSDL(w io.Writer) {
	fmt.Fprintf(w, "@%s", t.Name)
	if len(t.Args) > 0 {
		fmt.Fprint(w, "(")
		for i, arg := range t.Args {
			if i > 0 {
				fmt.Fprint(w, ", ")
			}
			fmt.Fprintf(w, "%s: %q", arg.Name, *arg.Value)
		}
		fmt.Fprint(w, ")")
	}
}

type DirectiveArg struct {
	Name  string  `json:"name"`
	Value *string `json:"value"`
}

// Splits a SDL format schema definition and groups it by type name.
func ParseGraphQLSchema(sdl string) map[string]string {
	definitions := make(map[string]string)

	// Match the start of type definitions, including any preceding comments
	typeStartRegex := regexp.MustCompile(`(?m)(?:(?:#[^\n]*\n|"""\s*(?s).*?\s*"""\n)*)\s*(type|input|enum|interface)\s+(\w+)(?:\s+implements\s+[\w\s&]+)?\s*{`)

	var currentPos int
	for {
		// Find next type definition start
		match := typeStartRegex.FindStringSubmatchIndex(sdl[currentPos:])
		if match == nil {
			break
		}

		// Get the type name and definition start position, including preceding comments
		defStart := currentPos + match[0]
		typeName := sdl[currentPos+match[4] : currentPos+match[5]]

		// Find matching closing brace
		braceCount := 1
		pos := currentPos + match[1]

		for braceCount > 0 && pos < len(sdl) {
			// Handle string literals and block comments to avoid counting braces inside them
			switch sdl[pos] {
			case '"':
				// Skip string literals
				if pos+2 < len(sdl) && sdl[pos:pos+3] == `"""` {
					pos += 3
					for pos < len(sdl) {
						if pos+2 < len(sdl) && sdl[pos:pos+3] == `"""` {
							pos += 3
							break
						}
						pos++
					}
					continue
				}
				// Skip regular string literals
				pos++
				for pos < len(sdl) && sdl[pos] != '"' {
					if sdl[pos] == '\\' {
						pos += 2
						continue
					}
					pos++
				}
			case '{':
				braceCount++
			case '}':
				braceCount--
			}
			pos++
		}

		if braceCount == 0 {
			// Extract the full definition including comments and braces
			fullDef := strings.TrimSpace(sdl[defStart:pos])
			definitions[typeName] = fullDef
		}

		currentPos = pos
	}

	return definitions
}
