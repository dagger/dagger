"""
A Dagger module for docusaurus, a documentation website builder. https://docusaurus.io
"""
type Docusaurus {
  """
  Scan all docusaurus sites, and ensure they are configured to build properly in Dagger.
  """
  pub optimizeConfig(ws: Workspace!): Changeset! @generate {
    let root = ws.directory(".")
    let combined = root.changes(root)
    for (site in sites(ws)) {
      combined = combined.withChangeset(site.optimizeConfig(ws))
    }
    combined
  }

  """
  Scan all docusaurus sites, and ensure that they build.
  """
  pub checkBuild(ws: Workspace!): Void @check {
    let builds = directory
    for (site in sites(ws)) {
      builds = builds.withDirectory(site.path, site.build(ws))
    }
    builds.sync
    null
  }

  pub sites(ws: Workspace!): [Site!]! {
    ws
      .directory(".", include: [
        "**/docusaurus.config.ts",
        "**/docusaurus.config.js",
      ])
      .glob("**/docusaurus.config.*")
      .map { configPath =>
        let path = configPath
          .trimSuffix("docusaurus.config.ts")
          .trimSuffix("docusaurus.config.js")
          .trimSuffix("/")
        let path = if (path == "") { "." } else { path }
        let pkgDir = ws.directory(path, include: ["package.json"])
        let pkgJson = if (pkgDir.stat("package.json") != null) {
          pkgDir.file("package.json").asJSON
        } else {
          null
        }
        Site(path: path, packageJson: PackageJson(json: pkgJson))
      }
  }

  """
  Return one docusaurus site by its workspace-relative path.
  """
  pub site(ws: Workspace!, path: String!): Site! {
    let selected = null
    let matches = 0
    for (candidate in sites(ws)) {
      if (candidate.path == path) {
        selected = candidate
        matches = matches + 1
      }
    }

    if (matches == 0) {
      raise "docusaurus site not found: " + path
    }
    if (matches > 1) {
      raise "duplicate docusaurus site path: " + path
    }
    if (selected == null) {
      raise "docusaurus site selection failed: " + path
    }

    selected
  }
}

"""
A Docusaurus site.
"""

"""
Package.json helpers.
"""
type PackageJson {
  let json: JSONValue

  let hasField(obj: JSONValue!, key: String!): Boolean! {
    obj.fields.filter { field => field == key }.length > 0
  }

  """
  The package manager command (read from package.json "packageManager" field).
  """
  pub packageManager: String! {
    if (json == null) {
      "npm"
    } else if (hasField(json, "packageManager") == false) {
      "npm"
    } else {
      let pmField = json.field(["packageManager"])
      # packageManager field is like "pnpm@8.15.0" â€” take the name before @
      pmField.asString.split("@")[0] ?? "npm"
    }
  }

  """
  Optional source include paths from package.json "docusaurus.include".
  """
  pub include: [String!]! {
    if (json == null) {
      [] :: [String!]!
    } else if (hasField(json, "docusaurus") == false) {
      [] :: [String!]!
    } else {
      let docusaurus = json.field(["docusaurus"])
      if (hasField(docusaurus, "include") == false) {
        [] :: [String!]!
      } else {
        let include = docusaurus.field(["include"])
        include.asArray.{asString}.map { item => item.asString }
      }
    }
  }

  """
  Source exclude paths from package.json "docusaurus.exclude".
  """
  pub exclude: [String!]! {
    if (json == null) {
      [] :: [String!]!
    } else if (hasField(json, "docusaurus") == false) {
      [] :: [String!]!
    } else {
      let docusaurus = json.field(["docusaurus"])
      if (hasField(docusaurus, "exclude") == false) {
        [] :: [String!]!
      } else {
        let exclude = docusaurus.field(["exclude"])
        exclude.asArray.{asString}.map { item => item.asString }
      }
    }
  }

  """
  Whether package.json "docusaurus.nginxConfig" is explicitly set.
  """
  pub hasNginxConfig: Boolean! {
    if (json == null) {
      false
    } else if (hasField(json, "docusaurus") == false) {
      false
    } else {
      let docusaurus = json.field(["docusaurus"])
      hasField(docusaurus, "nginxConfig")
    }
  }

  """
  Path to nginx config from package.json "docusaurus.nginxConfig".
  Defaults to "./nginx.conf" when the field is not set.
  """
  pub nginxConfig: String! {
    if (hasNginxConfig == false) {
      "./nginx.conf"
    } else {
      json.field(["docusaurus", "nginxConfig"]).asString ?? "./nginx.conf"
    }
  }
}

type Site {
  """
  Path of the site directory in the workspace
  """
  pub path: String!

  """
  Parsed package.json helpers for the site.
  """
  let packageJson: PackageJson!

  """
  The package manager command.
  """
  let pm: String! {
    packageJson.packageManager
  }

  """
  Path to the nginx config file in the workspace.
  """
  let nginxConfigPath: String! {
    let cfgPath = packageJson.nginxConfig.trimPrefix("./")
    if (path == ".") {
      cfgPath
    } else {
      path + "/" + cfgPath
    }
  }

  """
  The install command for the package manager.
  """
  let installCmd(ws: Workspace!): [String!]! {
    case (pm) {
      "yarn" => ["yarn", "install", "--frozen-lockfile"]
      "pnpm" => ["pnpm", "install", "--frozen-lockfile"]
      else => ["npm", "install"]
    }
  }

  """
  Include globs for files under the site path.
  """
  let siteOnlyIncludes: [String!]! {
    if (path == ".") {
      ["**"] :: [String!]!
    } else {
      [path + "/**"] :: [String!]!
    }
  }

  """
  Include globs for source and known local dependencies.
  """
  let sourceIncludes: [String!]! {
    siteOnlyIncludes + packageJson.include.map { inc =>
      if (path == ".") { inc } else { path + "/" + inc }
    }
  }

  """
  Exclude globs for source selection.
  """
  let sourceExcludes: [String!]! {
    [
      "node_modules/",
      ".docusaurus/",
      "build/",
      ".git/",
    ] + packageJson.exclude.map { exc =>
      if (path == ".") { exc } else { path + "/" + exc }
    }
  }

  """
  The Docusaurus site source files.
  """
  pub source(ws: Workspace!): Directory! {
    ws.directory(
      ".",
      include: sourceIncludes,
      exclude: sourceExcludes,
    )
  }

  """
  Base container for docusaurus.
  """
  let base: Container! {
    container
      .from("node:lts-alpine")
      .withoutEntrypoint
      .withWorkdir("/app")
      .withExec(["corepack", "enable"])
      .withMountedCache(
        "/root/.npm/_cacache",
        cacheVolume("npm-cache"),
      )
      .withMountedCache(
        "/usr/local/share/.cache/yarn",
        cacheVolume("yarn-cache"),
      )
      .withMountedCache(
        "/root/.local/share/pnpm/store",
        cacheVolume("pnpm-cache"),
      )
  }

  let workspaceRootPath: String! = "/workspace"
  let docusaurusBuildCmd: [String!]! = ["./node_modules/.bin/docusaurus", "build"]

  let workspaceSitePath: String! {
    if (path == ".") {
      workspaceRootPath
    } else {
      workspaceRootPath + "/" + path
    }
  }

  """
  Site-specific build sandbox.
  """
  pub sandbox: Sandbox! {
    let initialCtr = base
      .withDirectory(workspaceRootPath, directory)
      .withWorkdir(workspaceSitePath)
      .withMountedCache(
        "./node_modules/.cache",
        cacheVolume("docusaurus-cache-" + path),
        sharing: CacheSharingMode.PRIVATE,
      )

    Sandbox(
      site: Site(path: path, packageJson: packageJson),
      ctr: initialCtr,
      nesting: false,
      workspaceExcludes: [] :: [String!]!,
      justInTimeWorkspace: false,
    )
  }

  """
  Deterministically discover local paths outside of the site dir that are
  accessed by a docusaurus build run.
  Returned paths are relative to the site path, sorted, and deduplicated.
  """
  pub runtimeExternalPaths(ws: Workspace!): [String!]! {
    if (path == ".") {
      [] :: [String!]!
    } else {
      let traced = sandbox
        .withWorkspaceExcludes(sourceExcludes)
        .withWorkspaceFiles(
          ws,
          siteOnlyIncludes,
          [] :: [String!]!,
        )
        .withJustInTimeWorkspace(true)
        .withNesting(true)
        .withExec(
          ws,
          installCmd(ws),
          ReturnType.SUCCESS,
        )
        .withExec(
          ws,
          docusaurusBuildCmd,
          ReturnType.ANY,
        )

      traced.justInTimeWorkspaceLog
    }
  }

  """
  Build the static site.
  """
  pub build(ws: Workspace!): Directory! {
    sandbox
      .withWorkspaceExcludes(sourceExcludes)
      .withWorkspaceFiles(
        ws,
        sourceIncludes,
        [] :: [String!]!,
      )
      .withExec(
        ws,
        installCmd(ws),
        ReturnType.SUCCESS,
      )
      .withExec(
        ws,
        docusaurusBuildCmd,
        ReturnType.SUCCESS,
      )
      .container
      .directory("build")
  }

  let inferredIncludes(ws: Workspace!): JSONValue! {
    json.withContents(toJSON(runtimeExternalPaths(ws)) :: JSON!)
  }

  """
  Make sure the site is configured optimally for use with Dagger
  """
  pub optimizeConfig(ws: Workspace!): Changeset! {
    let packageJsonPath = path + "/package.json"
    let before = ws.directory("/", include: [packageJsonPath])
    let updatedPackageJson = json
      .withContents(toJSON(
        before
          .file(packageJsonPath)
          .asJSON
          .withField(["docusaurus", "include"], inferredIncludes(ws))
          .contents(pretty: true),
      ) :: JSON!)
      .asString
    before
      .withNewFile(
        packageJsonPath,
        updatedPackageJson,
      )
      .changes(before)
  }

  """
  Serve the static site with nginx.
  """
  pub server(ws: Workspace!): Service! {
    let ctr = container
      .from("nginx:alpine")
      .withDirectory("/usr/share/nginx/html", build(ws))

    if (packageJson.hasNginxConfig) {
      ctr = ctr.withFile(
        "/etc/nginx/conf.d/default.conf",
        ws.file(nginxConfigPath),
      )
    } else {
      let defaultConfig = ws
        .directory(path, include: ["nginx.conf"])
        .stat("nginx.conf")
      if (defaultConfig != null) {
        ctr = ctr.withFile(
          "/etc/nginx/conf.d/default.conf",
          ws.file(nginxConfigPath),
        )
      }
    }

    ctr
      .withExposedPort(80)
      .asService
  }
}

type Sandbox {
  let site: Site!
  let ctr: Container!
  let nesting: Boolean!
  let workspaceExcludes: [String!]!
  let justInTimeWorkspace: Boolean!

  let workspaceRootPath: String! = "/workspace"
  let jitWorkspaceLogDir: String! = "/tmp/docusaurus-jit-workspace"

  let siteWorkspacePath: String! {
    if (site.path == ".") {
      workspaceRootPath
    } else {
      workspaceRootPath + "/" + site.path
    }
  }

  let withContainer(nextCtr: Container!): Sandbox! {
    Sandbox(
      site: site,
      ctr: nextCtr,
      nesting: nesting,
      workspaceExcludes: workspaceExcludes,
      justInTimeWorkspace: justInTimeWorkspace,
    )
  }

  let withState(
    nextCtr: Container!,
    nextNesting: Boolean!,
    nextExcludes: [String!]!,
    nextJustInTimeWorkspace: Boolean!,
  ): Sandbox! {
    Sandbox(
      site: site,
      ctr: nextCtr,
      nesting: nextNesting,
      workspaceExcludes: nextExcludes,
      justInTimeWorkspace: nextJustInTimeWorkspace,
    )
  }

  let workspaceExcludesJSON: String! {
    toJSON(workspaceExcludes)
  }

  let withRuntimeTrace(ws: Workspace!): Container! {
    let workspaceID = json
      .withContents(toJSON(ws.id) :: JSON!)
      .asString

    ctr
      .withFile(
        "/jit-workspace-hook.cjs",
        currentModule.source.file("jit-workspace-hook.cjs"),
      )
      .withFile(
        "/jit-workspace-hydrate.cjs",
        currentModule.source.file("jit-workspace-hydrate.cjs"),
      )
      .withFile(
        "/jit-workspace-log.cjs",
        currentModule.source.file("jit-workspace-log.cjs"),
      )
      .withEnvVariable("CI", "1")
      .withEnvVariable("TZ", "UTC")
      .withEnvVariable("LANG", "C")
      .withEnvVariable("LC_ALL", "C")
      .withEnvVariable("DAGGER_JIT_WORKSPACE_LOG_DIR", jitWorkspaceLogDir)
      .withEnvVariable("DAGGER_JIT_WORKSPACE_ROOT", workspaceRootPath)
      .withEnvVariable("DAGGER_JIT_WORKSPACE_SITE_ROOT", siteWorkspacePath)
      .withEnvVariable("DAGGER_JIT_WORKSPACE_ID", workspaceID)
      .withEnvVariable("DAGGER_JIT_WORKSPACE_EXCLUDES_JSON", workspaceExcludesJSON)
      .withEnvVariable("DAGGER_JIT_WORKSPACE_HYDRATE_HELPER", "/jit-workspace-hydrate.cjs")
      .withEnvVariable("NODE_OPTIONS", "--require=/jit-workspace-hook.cjs")
  }

  """
  Return the underlying container.
  """
  pub container: Container! {
    ctr
  }

  """
  Toggle nested Dagger access in future exec steps.
  """
  pub withNesting(enabled: Boolean!): Sandbox! {
    withState(
      ctr,
      enabled,
      workspaceExcludes,
      justInTimeWorkspace,
    )
  }

  """
  Add sticky workspace exclude paths.
  """
  pub withWorkspaceExcludes(exclude: [String!]!): Sandbox! {
    withState(
      ctr,
      nesting,
      workspaceExcludes + exclude,
      justInTimeWorkspace,
    )
  }

  """
  Copy workspace files into /workspace.
  """
  pub withWorkspaceFiles(
    ws: Workspace!,
    include: [String!]!,
    exclude: [String!]!,
  ): Sandbox! {
    let copied = ws.directory(
      ".",
      include: include,
      exclude: workspaceExcludes + exclude,
    )
    let merged = ctr
      .directory(workspaceRootPath)
      .withDirectory("/", copied)
    withContainer(ctr.withDirectory(workspaceRootPath, merged))
  }

  """
  Toggle JIT workspace hydration for future exec steps.
  """
  pub withJustInTimeWorkspace(enabled: Boolean!): Sandbox! {
    withState(
      ctr,
      nesting,
      workspaceExcludes,
      enabled,
    )
  }

  """
  Execute a command in the sandbox container.
  """
  pub withExec(
    ws: Workspace!,
    cmd: [String!]!,
    expect: ReturnType!,
  ): Sandbox! {
    let execBase = if (justInTimeWorkspace) {
      withRuntimeTrace(ws)
    } else {
      ctr.withEnvVariable("NODE_OPTIONS", "")
    }

    let nextCtr = if (nesting) {
      execBase.withExec(
        cmd,
        expect: expect,
        experimentalPrivilegedNesting: true,
      )
    } else {
      execBase.withExec(
        cmd,
        expect: expect,
      )
    }

    withContainer(nextCtr)
  }

  """
  Paths hydrated on-demand from the workspace so far.
  """
  pub justInTimeWorkspaceLog: [String!]! {
    if (justInTimeWorkspace == false) {
      [] :: [String!]!
    } else {
      let pathsRaw = ctr
        .withFile(
          "/jit-workspace-log.cjs",
          currentModule.source.file("jit-workspace-log.cjs"),
        )
        .withEnvVariable("DAGGER_JIT_WORKSPACE_LOG_DIR", jitWorkspaceLogDir)
        .withEnvVariable("DAGGER_JIT_WORKSPACE_ROOT", workspaceRootPath)
        .withEnvVariable("DAGGER_JIT_WORKSPACE_SITE_ROOT", siteWorkspacePath)
        .withEnvVariable("DAGGER_JIT_WORKSPACE_COLLECT_MODE", "hydrated")
        .withEnvVariable("NODE_OPTIONS", "")
        .withEnvVariable("DAGGER_JIT_WORKSPACE_DISABLE_HYDRATE", "1")
        .withExec(["node", "/jit-workspace-log.cjs"])
        .stdout

      json
        .withContents(pathsRaw :: JSON!)
        .asArray
        .{asString}
        .map { item => item.asString }
    }
  }
}
