// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/evals/internal/dagger"
	"dagger/evals/internal/querybuilder"
	"dagger/evals/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Evals) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Docs *dagger.File
	}
	concrete.Docs = r.Docs
	return json.Marshal(&concrete)
}

func (r *Evals) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Docs *dagger.File
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Docs = concrete.Docs
	return nil
}

func (r Writable) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Writable) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r ReadImplicitVars) MarshalJSON() ([]byte, error) {
	var concrete struct {
		WeirdText string
	}
	concrete.WeirdText = r.WeirdText
	return json.Marshal(&concrete)
}

func (r *ReadImplicitVars) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		WeirdText string
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.WeirdText = concrete.WeirdText
	return nil
}

func (r BuildMultiStatic) MarshalJSON() ([]byte, error) {
	var concrete struct {
		BuildMulti *BuildMulti
	}
	concrete.BuildMulti = r.BuildMulti
	return json.Marshal(&concrete)
}

func (r *BuildMultiStatic) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		BuildMulti *BuildMulti
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.BuildMulti = concrete.BuildMulti
	return nil
}

func (r UndoChanges) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *UndoChanges) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r ModuleDependencies) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *ModuleDependencies) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r WorkspacePattern) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *WorkspacePattern) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r NestedObjects) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *NestedObjects) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r Responses) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Responses) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r Basic) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Basic) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r ModelContextProtocol) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *ModelContextProtocol) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r CoreAPI) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *CoreAPI) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r BuildMulti) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *BuildMulti) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r EnvPropagation) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *EnvPropagation) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r LifeAlert) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *LifeAlert) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r BuildMultiNoVar) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *BuildMultiNoVar) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Basic":
		switch fnName {
		case "Name":
			var parent Basic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Basic).Name(&parent), nil
		case "Prompt":
			var parent Basic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*Basic).Prompt(&parent, base), nil
		case "Check":
			var parent Basic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*Basic).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "BuildMulti":
		switch fnName {
		case "Name":
			var parent BuildMulti
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*BuildMulti).Name(&parent), nil
		case "Prompt":
			var parent BuildMulti
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*BuildMulti).Prompt(&parent, base), nil
		case "Check":
			var parent BuildMulti
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*BuildMulti).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "BuildMultiNoVar":
		switch fnName {
		case "Name":
			var parent BuildMultiNoVar
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*BuildMultiNoVar).Name(&parent), nil
		case "Prompt":
			var parent BuildMultiNoVar
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*BuildMultiNoVar).Prompt(&parent, base), nil
		case "Check":
			var parent BuildMultiNoVar
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*BuildMultiNoVar).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "BuildMultiStatic":
		switch fnName {
		case "Name":
			var parent BuildMultiStatic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*BuildMultiStatic).Name(&parent), nil
		case "Prompt":
			var parent BuildMultiStatic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*BuildMultiStatic).Prompt(&parent, base), nil
		case "Check":
			var parent BuildMultiStatic
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*BuildMultiStatic).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "CoreAPI":
		switch fnName {
		case "Name":
			var parent CoreAPI
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*CoreAPI).Name(&parent), nil
		case "Prompt":
			var parent CoreAPI
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*CoreAPI).Prompt(&parent, base), nil
		case "Check":
			var parent CoreAPI
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*CoreAPI).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "EnvPropagation":
		switch fnName {
		case "Name":
			var parent EnvPropagation
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EnvPropagation).Name(&parent), nil
		case "Prompt":
			var parent EnvPropagation
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*EnvPropagation).Prompt(&parent, ctx, base)
		case "Check":
			var parent EnvPropagation
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*EnvPropagation).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Evals":
		switch fnName {
		case "Writable":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).Writable(&parent), nil
		case "Check":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var evals []string
			if inputArgs["evals"] != nil {
				err = json.Unmarshal([]byte(inputArgs["evals"]), &evals)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg evals", err))
				}
			}
			var models []string
			if inputArgs["models"] != nil {
				err = json.Unmarshal([]byte(inputArgs["models"]), &models)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg models", err))
				}
			}
			return nil, (*Evals).Check(&parent, ctx, evals, models)
		case "ReadImplicitVars":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).ReadImplicitVars(&parent), nil
		case "BuildMultiStatic":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).BuildMultiStatic(&parent), nil
		case "UndoChanges":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).UndoChanges(&parent), nil
		case "ModuleDependencies":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).ModuleDependencies(&parent), nil
		case "WorkspacePattern":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).WorkspacePattern(&parent), nil
		case "NestedObjects":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).NestedObjects(&parent), nil
		case "Responses":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).Responses(&parent), nil
		case "Basic":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).Basic(&parent), nil
		case "ModelContextProtocol":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).ModelContextProtocol(&parent), nil
		case "CoreAPI":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).CoreAPI(&parent), nil
		case "BuildMulti":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).BuildMulti(&parent), nil
		case "EnvPropagation":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).EnvPropagation(&parent), nil
		case "LifeAlert":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).LifeAlert(&parent), nil
		case "BuildMultiNoVar":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evals).BuildMultiNoVar(&parent), nil
		case "":
			var parent Evals
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var docs *dagger.File
			if inputArgs["docs"] != nil {
				err = json.Unmarshal([]byte(inputArgs["docs"]), &docs)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg docs", err))
				}
			}
			return New(docs), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "LifeAlert":
		switch fnName {
		case "Name":
			var parent LifeAlert
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*LifeAlert).Name(&parent), nil
		case "Prompt":
			var parent LifeAlert
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*LifeAlert).Prompt(&parent, base), nil
		case "Check":
			var parent LifeAlert
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*LifeAlert).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "ModelContextProtocol":
		switch fnName {
		case "Name":
			var parent ModelContextProtocol
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*ModelContextProtocol).Name(&parent), nil
		case "Prompt":
			var parent ModelContextProtocol
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*ModelContextProtocol).Prompt(&parent, base), nil
		case "Check":
			var parent ModelContextProtocol
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*ModelContextProtocol).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "ModuleDependencies":
		switch fnName {
		case "Name":
			var parent ModuleDependencies
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*ModuleDependencies).Name(&parent), nil
		case "Prompt":
			var parent ModuleDependencies
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*ModuleDependencies).Prompt(&parent, ctx, base)
		case "Check":
			var parent ModuleDependencies
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*ModuleDependencies).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "NestedObjects":
		switch fnName {
		case "Name":
			var parent NestedObjects
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*NestedObjects).Name(&parent), nil
		case "Prompt":
			var parent NestedObjects
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*NestedObjects).Prompt(&parent, base), nil
		case "Check":
			var parent NestedObjects
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*NestedObjects).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "ReadImplicitVars":
		switch fnName {
		case "Name":
			var parent ReadImplicitVars
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*ReadImplicitVars).Name(&parent), nil
		case "Prompt":
			var parent ReadImplicitVars
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*ReadImplicitVars).Prompt(&parent, base), nil
		case "Check":
			var parent ReadImplicitVars
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*ReadImplicitVars).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Responses":
		switch fnName {
		case "Name":
			var parent Responses
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Responses).Name(&parent), nil
		case "Prompt":
			var parent Responses
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*Responses).Prompt(&parent, base), nil
		case "Check":
			var parent Responses
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*Responses).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "UndoChanges":
		switch fnName {
		case "Name":
			var parent UndoChanges
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*UndoChanges).Name(&parent), nil
		case "Prompt":
			var parent UndoChanges
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*UndoChanges).Prompt(&parent, base), nil
		case "Check":
			var parent UndoChanges
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*UndoChanges).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "WorkspacePattern":
		switch fnName {
		case "Name":
			var parent WorkspacePattern
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*WorkspacePattern).Name(&parent), nil
		case "Prompt":
			var parent WorkspacePattern
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*WorkspacePattern).Prompt(&parent, base), nil
		case "Check":
			var parent WorkspacePattern
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*WorkspacePattern).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Writable":
		switch fnName {
		case "Name":
			var parent Writable
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Writable).Name(&parent), nil
		case "Prompt":
			var parent Writable
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.LLM
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			return (*Writable).Prompt(&parent, base), nil
		case "Check":
			var parent Writable
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt *dagger.LLM
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return nil, (*Writable).Check(&parent, ctx, prompt)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
