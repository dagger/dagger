// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/botsbuildingbots/internal/dagger"
	"dagger/botsbuildingbots/internal/querybuilder"
	"dagger/botsbuildingbots/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Evaluator) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Docs                       *dagger.File
		SystemPrompt               *dagger.File
		DisableDefaultSystemPrompt bool
		EvaluatorModel             string
		Evals                      []*dagger.WorkspaceEval
	}
	concrete.Docs = r.Docs
	concrete.SystemPrompt = r.SystemPrompt
	concrete.DisableDefaultSystemPrompt = r.DisableDefaultSystemPrompt
	concrete.EvaluatorModel = r.EvaluatorModel
	concrete.Evals = r.Evals
	return json.Marshal(&concrete)
}

func (r *Evaluator) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Docs                       *dagger.File
		SystemPrompt               *dagger.File
		DisableDefaultSystemPrompt bool
		EvaluatorModel             string
		Evals                      []*dagger.WorkspaceEval
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Docs = concrete.Docs
	r.SystemPrompt = concrete.SystemPrompt
	r.DisableDefaultSystemPrompt = concrete.DisableDefaultSystemPrompt
	r.EvaluatorModel = concrete.EvaluatorModel
	r.Evals = concrete.Evals
	return nil
}

type evalImpl struct {
	query *querybuilder.Selection
	id    *EvalID
	name  *string
}

type EvalID string

func LoadEvalFromID(r *dagger.Client, id EvalID) Eval {
	q := querybuilder.Query().Client(r.GraphQLClient())
	q = q.Select("loadEvaluatorEvalFromID")
	q = q.Arg("id", id)
	return &evalImpl{query: q}
}

func (r *evalImpl) WithGraphQLQuery(q *querybuilder.Selection) Eval {
	return &evalImpl{query: q}
}

func (r *evalImpl) XXX_GraphQLType() string {
	return "Eval"
}

func (r *evalImpl) XXX_GraphQLIDType() string {
	return "EvalID"
}

func (r *evalImpl) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

func (r *evalImpl) MarshalJSON() ([]byte, error) {
	if r == nil {
		return []byte("\"\""), nil
	}
	id, err := r.ID(marshalCtx)
	if err != nil {
		return nil, err
	}
	return json.Marshal(id)
}

func (r *evalImpl) UnmarshalJSON(bs []byte) error {
	var id EvalID
	err := json.Unmarshal(bs, &id)
	if err != nil {
		return err
	}
	*r = *LoadEvalFromID(dag, id).(*evalImpl)
	return nil
}

func (r *evalImpl) toIface() Eval {
	if r == nil {
		return nil
	}
	return r
}

func (r *evalImpl) ID(ctx context.Context) (EvalID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.query.Select("id")
	var response EvalID
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *evalImpl) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.query.Select("name")
	var response string
	q = q.Bind(&response)
	return response, q.Execute(ctx)
}

func (r *evalImpl) Prompt(base *dagger.LLM) *dagger.LLM {
	q := r.query.Select("prompt")
	q = q.Arg("base", base)

	return (&dagger.LLM{}).WithGraphQLQuery(q)
}

func (r *evalImpl) Check(ctx context.Context, prompt *dagger.LLM) error {
	q := r.query.Select("check")
	q = q.Arg("prompt", prompt)

	var response dagger.Void
	q = q.Bind(&response)
	return q.Execute(ctx)
}

func (r EvalsAcrossModels) MarshalJSON() ([]byte, error) {
	var concrete struct {
		TraceID      string
		ModelResults []ModelResult
		Evaluator    *Evaluator
	}
	concrete.TraceID = r.TraceID
	concrete.ModelResults = r.ModelResults
	concrete.Evaluator = r.Evaluator
	return json.Marshal(&concrete)
}

func (r *EvalsAcrossModels) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		TraceID      string
		ModelResults []ModelResult
		Evaluator    *Evaluator
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.TraceID = concrete.TraceID
	r.ModelResults = concrete.ModelResults
	r.Evaluator = concrete.Evaluator
	return nil
}

func (r ModelResult) MarshalJSON() ([]byte, error) {
	var concrete struct {
		ModelName   string
		SpanID      string
		EvalReports []EvalResult
	}
	concrete.ModelName = r.ModelName
	concrete.SpanID = r.SpanID
	concrete.EvalReports = r.EvalReports
	return json.Marshal(&concrete)
}

func (r *ModelResult) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		ModelName   string
		SpanID      string
		EvalReports []EvalResult
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.ModelName = concrete.ModelName
	r.SpanID = concrete.SpanID
	r.EvalReports = concrete.EvalReports
	return nil
}

func (r EvalResult) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name          string
		SpanID        string
		Error         string
		Report        string
		SuccessRate   float64
		TotalAttempts int
		InputTokens   int
		OutputTokens  int
	}
	concrete.Name = r.Name
	concrete.SpanID = r.SpanID
	concrete.Error = r.Error
	concrete.Report = r.Report
	concrete.SuccessRate = r.SuccessRate
	concrete.TotalAttempts = r.TotalAttempts
	concrete.InputTokens = r.InputTokens
	concrete.OutputTokens = r.OutputTokens
	return json.Marshal(&concrete)
}

func (r *EvalResult) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name          string
		SpanID        string
		Error         string
		Report        string
		SuccessRate   float64
		TotalAttempts int
		InputTokens   int
		OutputTokens  int
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.SpanID = concrete.SpanID
	r.Error = concrete.Error
	r.Report = concrete.Report
	r.SuccessRate = concrete.SuccessRate
	r.TotalAttempts = concrete.TotalAttempts
	r.InputTokens = concrete.InputTokens
	r.OutputTokens = concrete.OutputTokens
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "EvalResult":
		switch fnName {
		case "Check":
			var parent EvalResult
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*EvalResult).Check(&parent)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "EvalsAcrossModels":
		switch fnName {
		case "AnalyzeAndGenerateSystemPrompt":
			var parent EvalsAcrossModels
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EvalsAcrossModels).AnalyzeAndGenerateSystemPrompt(&parent, ctx)
		case "CSV":
			var parent EvalsAcrossModels
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var noHeader bool
			if inputArgs["noHeader"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noHeader"]), &noHeader)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noHeader", err))
				}
			}
			return (*EvalsAcrossModels).CSV(&parent, noHeader), nil
		case "Check":
			var parent EvalsAcrossModels
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*EvalsAcrossModels).Check(&parent)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Evaluator":
		switch fnName {
		case "Compare":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var before *dagger.File
			if inputArgs["before"] != nil {
				err = json.Unmarshal([]byte(inputArgs["before"]), &before)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg before", err))
				}
			}
			var after *dagger.File
			if inputArgs["after"] != nil {
				err = json.Unmarshal([]byte(inputArgs["after"]), &after)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg after", err))
				}
			}
			return (*Evaluator).Compare(&parent, ctx, before, after)
		case "EvalsAcrossModels":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var evals []string
			if inputArgs["evals"] != nil {
				err = json.Unmarshal([]byte(inputArgs["evals"]), &evals)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg evals", err))
				}
			}
			var models []string
			if inputArgs["models"] != nil {
				err = json.Unmarshal([]byte(inputArgs["models"]), &models)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg models", err))
				}
			}
			var attempts int
			if inputArgs["attempts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["attempts"]), &attempts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg attempts", err))
				}
			}
			return (*Evaluator).EvalsAcrossModels(&parent, ctx, evals, models, attempts)
		case "Explore":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evaluator).Explore(&parent, ctx)
		case "GenerateSystemPrompt":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evaluator).GenerateSystemPrompt(&parent, ctx)
		case "Iterate":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evaluator).Iterate(&parent, ctx)
		case "WithDocs":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt string
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return (*Evaluator).WithDocs(&parent, prompt), nil
		case "WithDocsFile":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *dagger.File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			return (*Evaluator).WithDocsFile(&parent, file), nil
		case "WithEval":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var eval *evalImpl
			if inputArgs["eval"] != nil {
				err = json.Unmarshal([]byte(inputArgs["eval"]), &eval)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg eval", err))
				}
			}
			return (*Evaluator).WithEval(&parent, ctx, eval.toIface())
		case "WithEvals":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var evals []*evalImpl
			if inputArgs["evals"] != nil {
				err = json.Unmarshal([]byte(inputArgs["evals"]), &evals)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg evals", err))
				}
			}
			return (*Evaluator).WithEvals(&parent, ctx, convertSlice(evals, (*evalImpl).toIface))
		case "WithSystemPrompt":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var prompt string
			if inputArgs["prompt"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prompt"]), &prompt)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prompt", err))
				}
			}
			return (*Evaluator).WithSystemPrompt(&parent, prompt), nil
		case "WithSystemPromptFile":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var file *dagger.File
			if inputArgs["file"] != nil {
				err = json.Unmarshal([]byte(inputArgs["file"]), &file)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg file", err))
				}
			}
			return (*Evaluator).WithSystemPromptFile(&parent, file), nil
		case "WithoutDefaultSystemPrompt":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Evaluator).WithoutDefaultSystemPrompt(&parent), nil
		case "":
			var parent Evaluator
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var model string
			if inputArgs["model"] != nil {
				err = json.Unmarshal([]byte(inputArgs["model"]), &model)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg model", err))
				}
			}
			return New(model), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "ModelResult":
		switch fnName {
		case "Check":
			var parent ModelResult
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*ModelResult).Check(&parent)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
