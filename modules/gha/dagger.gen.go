// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/dagger/dagger/modules/gha/internal/dagger"
	"github.com/dagger/dagger/modules/gha/internal/querybuilder"
	"github.com/dagger/dagger/modules/gha/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Gha) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Workflows        []*Workflow
		JobDefaults      *Job
		WorkflowDefaults *Workflow
	}
	concrete.Workflows = r.Workflows
	concrete.JobDefaults = r.JobDefaults
	concrete.WorkflowDefaults = r.WorkflowDefaults
	return json.Marshal(&concrete)
}

func (r *Gha) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Workflows        []*Workflow
		JobDefaults      *Job
		WorkflowDefaults *Workflow
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Workflows = concrete.Workflows
	r.JobDefaults = concrete.JobDefaults
	r.WorkflowDefaults = concrete.WorkflowDefaults
	return nil
}

func (r Workflow) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name                   string
		Jobs                   []*Job
		Triggers               WorkflowTriggers
		PullRequestConcurrency string
		Permissions            []Permission
	}
	concrete.Name = r.Name
	concrete.Jobs = r.Jobs
	concrete.Triggers = r.Triggers
	concrete.PullRequestConcurrency = r.PullRequestConcurrency
	concrete.Permissions = r.Permissions
	return json.Marshal(&concrete)
}

func (r *Workflow) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name                   string
		Jobs                   []*Job
		Triggers               WorkflowTriggers
		PullRequestConcurrency string
		Permissions            []Permission
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Jobs = concrete.Jobs
	r.Triggers = concrete.Triggers
	r.PullRequestConcurrency = concrete.PullRequestConcurrency
	r.Permissions = concrete.Permissions
	return nil
}

func (r Job) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name             string
		Command          string
		Condition        string
		SetupCommands    []string
		TeardownCommands []string
		TimeoutMinutes   int
		Debug            bool
		Secrets          []string
		Env              []string
		Runner           []string
		Module           string
		DaggerVersion    string
		PublicToken      string
		CloudEngine      bool
		StopEngine       bool
	}
	concrete.Name = r.Name
	concrete.Command = r.Command
	concrete.Condition = r.Condition
	concrete.SetupCommands = r.SetupCommands
	concrete.TeardownCommands = r.TeardownCommands
	concrete.TimeoutMinutes = r.TimeoutMinutes
	concrete.Debug = r.Debug
	concrete.Secrets = r.Secrets
	concrete.Env = r.Env
	concrete.Runner = r.Runner
	concrete.Module = r.Module
	concrete.DaggerVersion = r.DaggerVersion
	concrete.PublicToken = r.PublicToken
	concrete.CloudEngine = r.CloudEngine
	concrete.StopEngine = r.StopEngine
	return json.Marshal(&concrete)
}

func (r *Job) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name             string
		Command          string
		Condition        string
		SetupCommands    []string
		TeardownCommands []string
		TimeoutMinutes   int
		Debug            bool
		Secrets          []string
		Env              []string
		Runner           []string
		Module           string
		DaggerVersion    string
		PublicToken      string
		CloudEngine      bool
		StopEngine       bool
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Command = concrete.Command
	r.Condition = concrete.Condition
	r.SetupCommands = concrete.SetupCommands
	r.TeardownCommands = concrete.TeardownCommands
	r.TimeoutMinutes = concrete.TimeoutMinutes
	r.Debug = concrete.Debug
	r.Secrets = concrete.Secrets
	r.Env = concrete.Env
	r.Runner = concrete.Runner
	r.Module = concrete.Module
	r.DaggerVersion = concrete.DaggerVersion
	r.PublicToken = concrete.PublicToken
	r.CloudEngine = concrete.CloudEngine
	r.StopEngine = concrete.StopEngine
	return nil
}

func (r Permission) IsEnum() {}

func (r Permission) Name() string {
	switch r {
	case ReadActions:
		return "ReadActions"
	case ReadChecks:
		return "ReadChecks"
	case ReadContents:
		return "ReadContents"
	case ReadDeployments:
		return "ReadDeployments"
	case ReadDiscussions:
		return "ReadDiscussions"
	case ReadIDToken:
		return "ReadIDToken"
	case ReadIssues:
		return "ReadIssues"
	case ReadMetadata:
		return "ReadMetadata"
	case ReadPackages:
		return "ReadPackages"
	case ReadPages:
		return "ReadPages"
	case ReadPullRequests:
		return "ReadPullRequests"
	case ReadRepositoryProjects:
		return "ReadRepositoryProjects"
	case ReadStatuses:
		return "ReadStatuses"
	case WriteActions:
		return "WriteActions"
	case WriteChecks:
		return "WriteChecks"
	case WriteContents:
		return "WriteContents"
	case WriteDeployments:
		return "WriteDeployments"
	case WriteDiscussions:
		return "WriteDiscussions"
	case WriteIDToken:
		return "WriteIDToken"
	case WriteIssues:
		return "WriteIssues"
	case WriteMetadata:
		return "WriteMetadata"
	case WritePackages:
		return "WritePackages"
	case WritePages:
		return "WritePages"
	case WritePullRequests:
		return "WritePullRequests"
	case WriteRepositoryProjects:
		return "WriteRepositoryProjects"
	case WriteStatuses:
		return "WriteStatuses"
	}
	return ""
}

func (r Permission) Value() string {
	return string(r)
}

func (r Permission) MarshalJSON() ([]byte, error) {
	if r == "" {
		return []byte("\"\""), nil
	}
	name := r.Name()
	if name == "" {
		return nil, fmt.Errorf("invalid enum value %q", r)
	}
	return json.Marshal(name)
}

func (r *Permission) UnmarshalJSON(bs []byte) error {
	var s string
	err := json.Unmarshal(bs, &s)
	if err != nil {
		return err
	}
	switch s {
	case "":
		*r = ""
	case "ReadContents":
		*r = ReadContents
	case "ReadIssues":
		*r = ReadIssues
	case "ReadActions":
		*r = ReadActions
	case "ReadPackages":
		*r = ReadPackages
	case "ReadDeployments":
		*r = ReadDeployments
	case "ReadPullRequests":
		*r = ReadPullRequests
	case "ReadPages":
		*r = ReadPages
	case "ReadIDToken":
		*r = ReadIDToken
	case "ReadRepositoryProjects":
		*r = ReadRepositoryProjects
	case "ReadStatuses":
		*r = ReadStatuses
	case "ReadMetadata":
		*r = ReadMetadata
	case "ReadChecks":
		*r = ReadChecks
	case "ReadDiscussions":
		*r = ReadDiscussions
	case "WriteContents":
		*r = WriteContents
	case "WriteIssues":
		*r = WriteIssues
	case "WriteActions":
		*r = WriteActions
	case "WritePackages":
		*r = WritePackages
	case "WriteDeployments":
		*r = WriteDeployments
	case "WritePullRequests":
		*r = WritePullRequests
	case "WritePages":
		*r = WritePages
	case "WriteIDToken":
		*r = WriteIDToken
	case "WriteRepositoryProjects":
		*r = WriteRepositoryProjects
	case "WriteStatuses":
		*r = WriteStatuses
	case "WriteMetadata":
		*r = WriteMetadata
	case "WriteChecks":
		*r = WriteChecks
	case "WriteDiscussions":
		*r = WriteDiscussions
	default:
		return fmt.Errorf("invalid enum value %q", s)
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Gha":
		switch fnName {
		case "Generate":
			var parent Gha
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var directory *dagger.Directory
			if inputArgs["directory"] != nil {
				err = json.Unmarshal([]byte(inputArgs["directory"]), &directory)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg directory", err))
				}
			}
			var asJson bool
			if inputArgs["asJSON"] != nil {
				err = json.Unmarshal([]byte(inputArgs["asJSON"]), &asJson)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg asJSON", err))
				}
			}
			var fileExtension string
			if inputArgs["fileExtension"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fileExtension"]), &fileExtension)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fileExtension", err))
				}
			}
			return (*Gha).Generate(&parent, directory, asJson, fileExtension), nil
		case "Job":
			var parent Gha
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var command string
			if inputArgs["command"] != nil {
				err = json.Unmarshal([]byte(inputArgs["command"]), &command)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg command", err))
				}
			}
			var condition string
			if inputArgs["condition"] != nil {
				err = json.Unmarshal([]byte(inputArgs["condition"]), &condition)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg condition", err))
				}
			}
			var setupCommands []string
			if inputArgs["setupCommands"] != nil {
				err = json.Unmarshal([]byte(inputArgs["setupCommands"]), &setupCommands)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg setupCommands", err))
				}
			}
			var teardownCommands []string
			if inputArgs["teardownCommands"] != nil {
				err = json.Unmarshal([]byte(inputArgs["teardownCommands"]), &teardownCommands)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg teardownCommands", err))
				}
			}
			var publicToken string
			if inputArgs["publicToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["publicToken"]), &publicToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg publicToken", err))
				}
			}
			var stopEngine bool
			if inputArgs["stopEngine"] != nil {
				err = json.Unmarshal([]byte(inputArgs["stopEngine"]), &stopEngine)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg stopEngine", err))
				}
			}
			var timeoutMinutes int
			if inputArgs["timeoutMinutes"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeoutMinutes"]), &timeoutMinutes)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeoutMinutes", err))
				}
			}
			var debug bool
			if inputArgs["debug"] != nil {
				err = json.Unmarshal([]byte(inputArgs["debug"]), &debug)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg debug", err))
				}
			}
			var secrets []string
			if inputArgs["secrets"] != nil {
				err = json.Unmarshal([]byte(inputArgs["secrets"]), &secrets)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg secrets", err))
				}
			}
			var env []string
			if inputArgs["env"] != nil {
				err = json.Unmarshal([]byte(inputArgs["env"]), &env)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg env", err))
				}
			}
			var runner []string
			if inputArgs["runner"] != nil {
				err = json.Unmarshal([]byte(inputArgs["runner"]), &runner)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg runner", err))
				}
			}
			var module string
			if inputArgs["module"] != nil {
				err = json.Unmarshal([]byte(inputArgs["module"]), &module)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg module", err))
				}
			}
			var daggerVersion string
			if inputArgs["daggerVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["daggerVersion"]), &daggerVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg daggerVersion", err))
				}
			}
			var cloudEngine bool
			if inputArgs["cloudEngine"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cloudEngine"]), &cloudEngine)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cloudEngine", err))
				}
			}
			return (*Gha).Job(&parent, name, command, condition, setupCommands, teardownCommands, publicToken, stopEngine, timeoutMinutes, debug, secrets, env, runner, module, daggerVersion, cloudEngine), nil
		case "WithWorkflow":
			var parent Gha
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var workflow *Workflow
			if inputArgs["workflow"] != nil {
				err = json.Unmarshal([]byte(inputArgs["workflow"]), &workflow)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg workflow", err))
				}
			}
			return (*Gha).WithWorkflow(&parent, workflow), nil
		case "Workflow":
			var parent Gha
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var pullRequestConcurrency string
			if inputArgs["pullRequestConcurrency"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pullRequestConcurrency"]), &pullRequestConcurrency)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pullRequestConcurrency", err))
				}
			}
			var noDispatch bool
			if inputArgs["noDispatch"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noDispatch"]), &noDispatch)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noDispatch", err))
				}
			}
			var permissions Permissions
			if inputArgs["permissions"] != nil {
				err = json.Unmarshal([]byte(inputArgs["permissions"]), &permissions)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg permissions", err))
				}
			}
			var onIssueComment bool
			if inputArgs["onIssueComment"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onIssueComment"]), &onIssueComment)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onIssueComment", err))
				}
			}
			var onIssueCommentCreated bool
			if inputArgs["onIssueCommentCreated"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onIssueCommentCreated"]), &onIssueCommentCreated)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onIssueCommentCreated", err))
				}
			}
			var onIssueCommentEdited bool
			if inputArgs["onIssueCommentEdited"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onIssueCommentEdited"]), &onIssueCommentEdited)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onIssueCommentEdited", err))
				}
			}
			var onIssueCommentDeleted bool
			if inputArgs["onIssueCommentDeleted"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onIssueCommentDeleted"]), &onIssueCommentDeleted)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onIssueCommentDeleted", err))
				}
			}
			var onPullRequest bool
			if inputArgs["onPullRequest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequest"]), &onPullRequest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequest", err))
				}
			}
			var onPullRequestBranches []string
			if inputArgs["onPullRequestBranches"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestBranches"]), &onPullRequestBranches)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestBranches", err))
				}
			}
			var onPullRequestPaths []string
			if inputArgs["onPullRequestPaths"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestPaths"]), &onPullRequestPaths)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestPaths", err))
				}
			}
			var onPullRequestAssigned bool
			if inputArgs["onPullRequestAssigned"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestAssigned"]), &onPullRequestAssigned)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestAssigned", err))
				}
			}
			var onPullRequestUnassigned bool
			if inputArgs["onPullRequestUnassigned"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestUnassigned"]), &onPullRequestUnassigned)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestUnassigned", err))
				}
			}
			var onPullRequestLabeled bool
			if inputArgs["onPullRequestLabeled"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestLabeled"]), &onPullRequestLabeled)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestLabeled", err))
				}
			}
			var onPullRequestUnlabeled bool
			if inputArgs["onPullRequestUnlabeled"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestUnlabeled"]), &onPullRequestUnlabeled)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestUnlabeled", err))
				}
			}
			var onPullRequestOpened bool
			if inputArgs["onPullRequestOpened"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestOpened"]), &onPullRequestOpened)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestOpened", err))
				}
			}
			var onPullRequestEdited bool
			if inputArgs["onPullRequestEdited"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestEdited"]), &onPullRequestEdited)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestEdited", err))
				}
			}
			var onPullRequestClosed bool
			if inputArgs["onPullRequestClosed"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestClosed"]), &onPullRequestClosed)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestClosed", err))
				}
			}
			var onPullRequestReopened bool
			if inputArgs["onPullRequestReopened"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestReopened"]), &onPullRequestReopened)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestReopened", err))
				}
			}
			var onPullRequestSynchronize bool
			if inputArgs["onPullRequestSynchronize"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestSynchronize"]), &onPullRequestSynchronize)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestSynchronize", err))
				}
			}
			var onPullRequestConvertedToDraft bool
			if inputArgs["onPullRequestConvertedToDraft"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestConvertedToDraft"]), &onPullRequestConvertedToDraft)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestConvertedToDraft", err))
				}
			}
			var onPullRequestLocked bool
			if inputArgs["onPullRequestLocked"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestLocked"]), &onPullRequestLocked)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestLocked", err))
				}
			}
			var onPullRequestUnlocked bool
			if inputArgs["onPullRequestUnlocked"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestUnlocked"]), &onPullRequestUnlocked)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestUnlocked", err))
				}
			}
			var onPullRequestEnqueued bool
			if inputArgs["onPullRequestEnqueued"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestEnqueued"]), &onPullRequestEnqueued)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestEnqueued", err))
				}
			}
			var onPullRequestDequeued bool
			if inputArgs["onPullRequestDequeued"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestDequeued"]), &onPullRequestDequeued)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestDequeued", err))
				}
			}
			var onPullRequestMilestoned bool
			if inputArgs["onPullRequestMilestoned"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestMilestoned"]), &onPullRequestMilestoned)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestMilestoned", err))
				}
			}
			var onPullRequestDemilestoned bool
			if inputArgs["onPullRequestDemilestoned"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestDemilestoned"]), &onPullRequestDemilestoned)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestDemilestoned", err))
				}
			}
			var onPullRequestReadyForReview bool
			if inputArgs["onPullRequestReadyForReview"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestReadyForReview"]), &onPullRequestReadyForReview)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestReadyForReview", err))
				}
			}
			var onPullRequestReviewRequested bool
			if inputArgs["onPullRequestReviewRequested"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestReviewRequested"]), &onPullRequestReviewRequested)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestReviewRequested", err))
				}
			}
			var onPullRequestReviewRequestRemoved bool
			if inputArgs["onPullRequestReviewRequestRemoved"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestReviewRequestRemoved"]), &onPullRequestReviewRequestRemoved)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestReviewRequestRemoved", err))
				}
			}
			var onPullRequestAutoMergeEnabled bool
			if inputArgs["onPullRequestAutoMergeEnabled"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestAutoMergeEnabled"]), &onPullRequestAutoMergeEnabled)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestAutoMergeEnabled", err))
				}
			}
			var onPullRequestAutoMergeDisabled bool
			if inputArgs["onPullRequestAutoMergeDisabled"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPullRequestAutoMergeDisabled"]), &onPullRequestAutoMergeDisabled)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPullRequestAutoMergeDisabled", err))
				}
			}
			var onPush bool
			if inputArgs["onPush"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPush"]), &onPush)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPush", err))
				}
			}
			var onPushTags []string
			if inputArgs["onPushTags"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPushTags"]), &onPushTags)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPushTags", err))
				}
			}
			var onPushBranches []string
			if inputArgs["onPushBranches"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPushBranches"]), &onPushBranches)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPushBranches", err))
				}
			}
			var onPushPaths []string
			if inputArgs["onPushPaths"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onPushPaths"]), &onPushPaths)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onPushPaths", err))
				}
			}
			var onSchedule []string
			if inputArgs["onSchedule"] != nil {
				err = json.Unmarshal([]byte(inputArgs["onSchedule"]), &onSchedule)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg onSchedule", err))
				}
			}
			return (*Gha).Workflow(&parent, name, pullRequestConcurrency, noDispatch, permissions, onIssueComment, onIssueCommentCreated, onIssueCommentEdited, onIssueCommentDeleted, onPullRequest, onPullRequestBranches, onPullRequestPaths, onPullRequestAssigned, onPullRequestUnassigned, onPullRequestLabeled, onPullRequestUnlabeled, onPullRequestOpened, onPullRequestEdited, onPullRequestClosed, onPullRequestReopened, onPullRequestSynchronize, onPullRequestConvertedToDraft, onPullRequestLocked, onPullRequestUnlocked, onPullRequestEnqueued, onPullRequestDequeued, onPullRequestMilestoned, onPullRequestDemilestoned, onPullRequestReadyForReview, onPullRequestReviewRequested, onPullRequestReviewRequestRemoved, onPullRequestAutoMergeEnabled, onPullRequestAutoMergeDisabled, onPush, onPushTags, onPushBranches, onPushPaths, onSchedule), nil
		case "":
			var parent Gha
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var jobDefaults *Job
			if inputArgs["jobDefaults"] != nil {
				err = json.Unmarshal([]byte(inputArgs["jobDefaults"]), &jobDefaults)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg jobDefaults", err))
				}
			}
			var workflowDefaults *Workflow
			if inputArgs["workflowDefaults"] != nil {
				err = json.Unmarshal([]byte(inputArgs["workflowDefaults"]), &workflowDefaults)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg workflowDefaults", err))
				}
			}
			return New(jobDefaults, workflowDefaults), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Workflow":
		switch fnName {
		case "Check":
			var parent Workflow
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var repo *dagger.Directory
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return nil, (*Workflow).Check(&parent, ctx, repo)
		case "WithJob":
			var parent Workflow
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var job *Job
			if inputArgs["job"] != nil {
				err = json.Unmarshal([]byte(inputArgs["job"]), &job)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg job", err))
				}
			}
			return (*Workflow).WithJob(&parent, job), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
