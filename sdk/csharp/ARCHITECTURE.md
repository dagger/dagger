# C# SDK Architecture

## Module Structure

When a user creates a C# Dagger module, they get this structure:

```
my-module/
├── Main.cs                  # User's module class
├── Program.cs               # Bootstrap entrypoint (from template)
├── MyModule.csproj          # Project file (named after module in PascalCase)
├── dagger.json              # Module metadata (name: "my-module")
└── sdk/                     # Generated SDK source code (auto-generated, do not edit)
    ├── Dagger.SDK.csproj    # Clean project file (no ProjectReferences)
    ├── Dagger.SDK.g.cs      # Generated Dagger API from introspection
    ├── Client.cs            # SDK source files
    ├── QueryExecutor.cs
    ├── GraphQL/
    ├── Attributes/
    ├── Module/              # CRITICAL: Module runtime infrastructure
    │   ├── ModuleRuntime.cs # Handles registration and function execution
    │   └── ModuleTypeInfo.cs
    ├── analyzers/
    │   └── dotnet/cs/
    │       └── Dagger.SDK.Analyzers.dll # Pre-built analyzer for IDE support
    |       |-- Dagger.SDK.CodeFixes.dll # Pre-built code fixes DLL 
    └── ... (all SDK source files)
```

**Project File Naming:** The `.csproj` file is automatically named to match your module name in PascalCase. For example, if your `dagger.json` has `"name": "my-awesome-module"`, the project file will be `MyAwesomeModule.csproj`. This creates a cohesive naming convention where the project file clearly identifies ownership.

**Important:** The `sdk/` folder is automatically generated by `dagger develop`. Do not manually edit files in this directory—they will be overwritten.

## Execution Flow

```
┌─────────────────────────────────────────────────────────────────┐
│ 1. Dagger Engine calls:                                         │
│    dotnet run --no-build -c Release -- [--register]             │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│ 2. Program.cs (user's file, from template):                     │
│    using Dagger;                                     │
│    return await ModuleRuntime.RunAsync(args);                   │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│ 3. ModuleRuntime.cs (in SDK - Dagger.SDK.Module):              │
│    - Discovers [Object] classes                           │
│    - Discovers [Function] methods                         │
│    - If --register: Returns schema to Dagger                    │
│    - Else: Listens for function calls and executes them         │
└──────────────────────┬──────────────────────────────────────────┘
                       │
                       ▼
┌─────────────────────────────────────────────────────────────────┐
│ 4. User's Module (Main.cs):                                     │
│    using Dagger;                                                │
│    [Object]                                                     │
│    public class MyModule                                        │
│    {                                                            │
│        [Function]                                               │
│        public Container Echo(string msg) { ... }                │
│    }                                                            │
└─────────────────────────────────────────────────────────────────┘
```

## Key Files

### Template Files (Copied to User's Module)

**Program.cs** - Simple bootstrap, calls into SDK:
```csharp
return await ModuleRuntime.RunAsync(args);
```

**Main.cs** - User's module definition:
```csharp
[Object]
public class DaggerModule
{
    [Function]
    public Container ContainerEcho(string stringArg) { ... }
}
```

**DaggerModule.csproj** - Includes the SDK source:
```xml
<Compile Include="**/*.cs" Exclude="**/obj/**;**/bin/**" />
<!-- Includes all .cs files, including sdk/**/*.cs -->
```

### SDK Files (Generated and Copied to User's sdk/ Folder)der)

**Dagger.SDK.g.cs** - Generated Dagger API from GraphQL introspection:
- All Dagger types (Container, Directory, File, etc.)
- Type-safe query methods
- Fluent API with IntelliSense

**ModuleRuntime.cs** (Module/) - The runtime logic:
- Module discovery via reflection ([Object] attributes)
- Schema generation for `--register`
- Function execution for normal mode

## SDK Distribution (Source Vendoring)

The C# SDK uses **source vendoring** (similar to Python SDK):

1. **Full SDK source** is copied to `<module>/sdk/`
2. **Generated API** (`Dagger.SDK.g.cs`) is injected from GraphQL introspection
3. **Clean `.csproj`** is generated without ProjectReferences that don't exist in user modules
4. **Analyzer DLLs** are pre-built and placed at `sdk/analyzers/dotnet/cs/`
5. **Module/ directory** is included (contains critical runtime infrastructure)

User modules compile against SDK source via:
```xml
<Compile Include="**/*.cs" Exclude="**/obj/**;**/bin/**" />  <!-- Includes sdk/**/*.cs -->
<Analyzer Include="sdk/analyzers/dotnet/cs/Dagger.SDK.Analyzers.dll" />
<Analyzer Include="sdk/analyzers/dotnet/cs/Dagger.SDK.CodeFixes.dll" />
```

### Why Source Vendoring?

**Advantages:**
- ✅ Simple generated code integration (just a file, no DLL rebuild)
- ✅ Users can debug into SDK source
- ✅ Version isolation per module (each module has its own SDK copy)
- ✅ Matches proven Python SDK pattern
- ✅ Works with `dagger develop` regeneration flow

**The Clean .csproj Fix:**

The original `Dagger.SDK.csproj` contains:
```xml
<ProjectReference Include="..\Dagger.SDK.Analyzers\..." />
<ProjectReference Include="..\Dagger.SDK.CodeGen\..." />
```

These paths don't exist in user modules, they only exist in the SDK repository when in development.
For this purpose, the runtime version provided to the user is a clean version:

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <RootNamespace>Dagger</RootNamespace>
  </PropertyGroup>
  <ItemGroup>
    <!-- TODO: We might be able to remove this? -->
    <PackageReference Include="System.Collections.Immutable" Version="10.0.0" />
  </ItemGroup>
</Project>
```

This ensures user modules build successfully without broken references.

## Comparison with Other SDKs

| SDK        | User's Entrypoint | Calls Into          | SDK Runtime         |
|------------|-------------------|---------------------|---------------------|
| Python     | `runtime.py`      | `→`                 | `dagger.mod.cli.app()` |
| PHP        | `entrypoint.php`  | `→`                 | `EntrypointCommand` |
| TypeScript | (implicit)        | `→`                 | `entrypoint()`      |
| **C#**     | **`Program.cs`**  | **`→`**             | **`ModuleRuntime`** |

All SDKs follow the same pattern:
1. User gets a simple bootstrap file in their module
2. Bootstrap calls into the SDK's runtime implementation
3. SDK runtime handles discovery, registration, and execution
