defmodule Dagger.Codegen.ElixirGeneratorTest do
  use ExUnit.Case, async: true

  alias Dagger.Codegen.ElixirGenerator
  alias Dagger.Codegen.Introspection.Types.{Schema, Type, TypeRef, InputValue, Field}

  test "source file name" do
    schema = %Schema{
      types: [
        %Type{
          description: "A global cache volume identifier.",
          enum_values: nil,
          fields: nil,
          input_fields: nil,
          interfaces: nil,
          kind: "SCALAR",
          name: "CacheVolumeID",
          possible_types: nil
        }
      ]
    }

    assert [[{"cache_volume_id.ex", _}], [], [], []] = ElixirGenerator.generate(schema)
  end

  test "scalar type" do
    schema = %Schema{
      types: [
        %Type{
          description: "A global cache volume identifier.",
          enum_values: nil,
          fields: nil,
          input_fields: nil,
          interfaces: nil,
          kind: "SCALAR",
          name: "CacheVolumeID",
          possible_types: nil
        }
      ]
    }

    assert [[{_, source}], [], [], []] = ElixirGenerator.generate(schema)

    assert format!(source) ==
             """
             # This file generated by `dagger_codegen`. Please DO NOT EDIT.
             defmodule Dagger.CacheVolumeID do
               @moduledoc \"A global cache volume identifier.\"

               @type t() :: String.t()
             end
             """
             |> format!()
  end

  test "object type chainable" do
    schema = %Schema{
      types: [
        %Type{
          description: "",
          enum_values: nil,
          input_fields: nil,
          interfaces: [],
          kind: "OBJECT",
          name: "Query",
          possible_types: nil,
          fields: [
            %Field{
              args: [
                %InputValue{
                  default_value: nil,
                  description:
                    "A string identifier to target this cache volume (e.g., \"modules-cache\").",
                  name: "key",
                  type: %TypeRef{
                    kind: "NON_NULL",
                    name: nil,
                    of_type: %TypeRef{
                      kind: "SCALAR",
                      name: "String",
                      of_type: nil
                    }
                  }
                }
              ],
              deprecation_reason: nil,
              description: "Constructs a cache volume for a given cache key.",
              is_deprecated: false,
              name: "cacheVolume",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{
                  kind: "OBJECT",
                  name: "CacheVolume",
                  of_type: nil
                }
              }
            }
          ]
        }
      ]
    }

    assert [[], [], [{_, source}], []] = ElixirGenerator.generate(schema)

    assert format!(source) ==
             """
             # This file generated by `dagger_codegen`. Please DO NOT EDIT.
             defmodule Dagger.Client do
               @moduledoc \"Dagger.Client\"

               use Dagger.Core.QueryBuilder

               defstruct [:selection, :client]

               @type t() :: %__MODULE__{}

               @doc \"Constructs a cache volume for a given cache key.\"
               @spec cache_volume(t(), String.t()) :: Dagger.CacheVolume.t()
               def cache_volume(%__MODULE__{} = client, key) do
                 selection = 
                   client.selection |> select(\"cacheVolume\") |> put_arg(\"key\", key)

                 %Dagger.CacheVolume{
                   selection: selection, 
                   client: client.client
                 }
               end
             end
             """
             |> format!()
  end

  test "object type execute" do
    schema = %Schema{
      types: [
        %Type{
          description: "",
          enum_values: nil,
          input_fields: nil,
          interfaces: [],
          kind: "OBJECT",
          name: "Query",
          possible_types: nil,
          fields: [
            %Field{
              args: [
                %InputValue{
                  default_value: nil,
                  description: "Dummy argument",
                  name: "dummy",
                  type: %TypeRef{
                    kind: "NON_NULL",
                    name: nil,
                    of_type: %TypeRef{
                      kind: "SCALAR",
                      name: "String",
                      of_type: nil
                    }
                  }
                }
              ],
              deprecation_reason: nil,
              description:
                "The output stream of the last executed command.\n\nWill execute default command if none is set, or error if there's no default.",
              is_deprecated: false,
              name: "stdout",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{kind: "SCALAR", name: "String", of_type: nil}
              }
            }
          ]
        }
      ]
    }

    assert [[], [], [{_, source}], []] = ElixirGenerator.generate(schema)

    assert format!(source) ==
             """
             # This file generated by `dagger_codegen`. Please DO NOT EDIT.
             defmodule Dagger.Client do
               @moduledoc \"Dagger.Client\"

               use Dagger.Core.QueryBuilder

               defstruct [:selection, :client]

               @type t() :: %__MODULE__{}

               @doc \"\"\"
               The output stream of the last executed command.

               Will execute default command if none is set, or error if there's no default.
               \"\"\"
               @spec stdout(t(), String.t()) :: {:ok, String.t()} | {:error, term()} 
               def stdout(%__MODULE__{} = client, dummy) do
                 selection = 
                   client.selection |> select(\"stdout\") |> put_arg(\"dummy\", dummy)

                 execute(selection, client.client)
               end
             end
             """
             |> format!()
  end

  test "object type execute list" do
    schema = %Schema{
      types: [
        %Type{
          description: "",
          enum_values: nil,
          input_fields: nil,
          interfaces: [],
          kind: "OBJECT",
          name: "Container",
          possible_types: nil,
          fields: [
            %Field{
              args: [
                %InputValue{
                  default_value: nil,
                  description: "Dummy argument",
                  name: "dummy",
                  type: %TypeRef{
                    kind: "NON_NULL",
                    name: nil,
                    of_type: %TypeRef{
                      kind: "SCALAR",
                      name: "String",
                      of_type: nil
                    }
                  }
                }
              ],
              deprecation_reason: nil,
              description: "Retrieves the list of environment variables passed to commands.",
              is_deprecated: false,
              name: "envVariables",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{
                  kind: "LIST",
                  name: nil,
                  of_type: %TypeRef{
                    kind: "NON_NULL",
                    name: nil,
                    of_type: %TypeRef{
                      kind: "OBJECT",
                      name: "EnvVariable",
                      of_type: nil
                    }
                  }
                }
              }
            }
          ]
        },
        %Type{
          description: "A simple key value object that represents an environment variable.",
          enum_values: nil,
          fields: [
            %Field{
              args: [],
              deprecation_reason: nil,
              description: "The environment variable name.",
              is_deprecated: false,
              name: "name",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{kind: "SCALAR", name: "String", of_type: nil}
              }
            },
            %Field{
              args: [],
              deprecation_reason: nil,
              description: "The environment variable value.",
              is_deprecated: false,
              name: "value",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{kind: "SCALAR", name: "String", of_type: nil}
              }
            }
          ],
          input_fields: nil,
          interfaces: [],
          kind: "OBJECT",
          name: "EnvVariable",
          possible_types: nil
        }
      ]
    }

    assert [[], [], [{"container.ex", source} | _], []] = ElixirGenerator.generate(schema)

    assert format!(source) ==
             """
             # This file generated by `dagger_codegen`. Please DO NOT EDIT.
             defmodule Dagger.Container do
               @moduledoc \"Dagger.Container\"

               use Dagger.Core.QueryBuilder

               defstruct [:selection, :client]

               @type t() :: %__MODULE__{}

               @doc \"Retrieves the list of environment variables passed to commands."
               @spec env_variables(t(), String.t()) :: {:ok, [Dagger.EnvVariable.t()]} | {:error, term()} 
               def env_variables(%__MODULE__{} = container, dummy) do
                 selection = 
                   container.selection |> select(\"envVariables\") |> put_arg(\"dummy\", dummy) |> select(\"id\")

                 with {:ok, items} <- execute(selection, container.client) do
                   {:ok,
                    for %{\"id\" => id} <- items do
                      %Dagger.EnvVariable{
                        selection: 
                          query()
                          |> select(\"loadEnvVariableFromID\")
                          |> arg(\"id\", id),
                        client: container.client
                      }
                    end}
                  end
               end
             end
             """
             |> format!()
  end

  test "id argument" do
    schema = %Schema{
      types: [
        %Type{
          description: "",
          enum_values: nil,
          input_fields: nil,
          interfaces: [],
          kind: "OBJECT",
          name: "Container",
          possible_types: nil,
          fields: [
            %Field{
              args: [
                %InputValue{
                  default_value: nil,
                  description: "Identifier of the service container",
                  name: "service",
                  type: %TypeRef{
                    kind: "NON_NULL",
                    name: nil,
                    of_type: %TypeRef{
                      kind: "SCALAR",
                      name: "ServiceID",
                      of_type: nil
                    }
                  }
                }
              ],
              deprecation_reason: nil,
              description: "...",
              is_deprecated: false,
              name: "withServiceBinding",
              type: %TypeRef{
                kind: "NON_NULL",
                name: nil,
                of_type: %TypeRef{
                  kind: "OBJECT",
                  name: "Container",
                  of_type: nil
                }
              }
            }
          ]
        }
      ]
    }

    assert [[], [], [{_, source} | _], []] = ElixirGenerator.generate(schema)

    assert format!(source) ==
             """
             # This file generated by `dagger_codegen`. Please DO NOT EDIT.
             defmodule Dagger.Container do
               @moduledoc \"Dagger.Container\"

               use Dagger.Core.QueryBuilder

               defstruct [:selection, :client]

               @type t() :: %__MODULE__{}

               @doc \"...\"
               @spec with_service_binding(t(), Dagger.Service.t()) :: Dagger.Container.t()
               def with_service_binding(%__MODULE__{} = container, service) do
                 selection = 
                   container.selection |> select(\"withServiceBinding\") |> put_arg(\"service\", Dagger.ID.id!(service))

                 %Dagger.Container{
                   selection: selection,
                   client: container.client
                 }
               end
             end
             """
             |> format!()
  end

  test "ignore primitive scalar type" do
    schema = %Schema{
      types:
        Enum.map(["String", "Float", "Int", "Boolean", "DateTime", "ID"], fn name ->
          %Type{
            description: "",
            enum_values: nil,
            fields: nil,
            input_fields: nil,
            interfaces: nil,
            kind: "SCALAR",
            name: name,
            possible_types: nil
          }
        end)
    }

    assert [[], [], [], []] = ElixirGenerator.generate(schema)
  end

  defp format!(source) do
    Code.format_string!(source)
    |> IO.iodata_to_binary()
  end
end
