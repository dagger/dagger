# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.Changeset do
  @moduledoc """
  A comparison between two directories representing changes that can be applied.
  """

  use Dagger.Core.Base, kind: :object, name: "Changeset"

  alias Dagger.Core.Client
  alias Dagger.Core.QueryBuilder, as: QB

  @derive Dagger.ID
  @derive Dagger.Sync
  defstruct [:query_builder, :client]

  @type t() :: %__MODULE__{}

  @doc """
  Files and directories that were added in the newer directory.
  """
  @spec added_paths(t()) :: {:ok, [String.t()]} | {:error, term()}
  def added_paths(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("addedPaths")

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  The newer/upper snapshot.
  """
  @spec after_(t()) :: Dagger.Directory.t()
  def after_(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("after")

    %Dagger.Directory{
      query_builder: query_builder,
      client: changeset.client
    }
  end

  @doc """
  Return a Git-compatible patch of the changes
  """
  @spec as_patch(t()) :: Dagger.File.t()
  def as_patch(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("asPatch")

    %Dagger.File{
      query_builder: query_builder,
      client: changeset.client
    }
  end

  @doc """
  The older/lower snapshot to compare against.
  """
  @spec before(t()) :: Dagger.Directory.t()
  def before(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("before")

    %Dagger.Directory{
      query_builder: query_builder,
      client: changeset.client
    }
  end

  @doc """
  Applies the diff represented by this changeset to a path on the host.
  """
  @spec export(t(), String.t()) :: {:ok, String.t()} | {:error, term()}
  def export(%__MODULE__{} = changeset, path) do
    query_builder =
      changeset.query_builder |> QB.select("export") |> QB.put_arg("path", path)

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  A unique identifier for this Changeset.
  """
  @spec id(t()) :: {:ok, Dagger.ChangesetID.t()} | {:error, term()}
  def id(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("id")

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  Returns true if the changeset is empty (i.e. there are no changes).
  """
  @spec empty?(t()) :: {:ok, boolean()} | {:error, term()}
  def empty?(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("isEmpty")

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  Return a snapshot containing only the created and modified files
  """
  @spec layer(t()) :: Dagger.Directory.t()
  def layer(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("layer")

    %Dagger.Directory{
      query_builder: query_builder,
      client: changeset.client
    }
  end

  @doc """
  Files and directories that existed before and were updated in the newer directory.
  """
  @spec modified_paths(t()) :: {:ok, [String.t()]} | {:error, term()}
  def modified_paths(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("modifiedPaths")

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  Files and directories that were removed. Directories are indicated by a trailing slash, and their child paths are not included.
  """
  @spec removed_paths(t()) :: {:ok, [String.t()]} | {:error, term()}
  def removed_paths(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("removedPaths")

    Client.execute(changeset.client, query_builder)
  end

  @doc """
  Force evaluation in the engine.
  """
  @spec sync(t()) :: {:ok, Dagger.Changeset.t()} | {:error, term()}
  def sync(%__MODULE__{} = changeset) do
    query_builder =
      changeset.query_builder |> QB.select("sync")

    with {:ok, id} <- Client.execute(changeset.client, query_builder) do
      {:ok,
       %Dagger.Changeset{
         query_builder:
           QB.query()
           |> QB.select("loadChangesetFromID")
           |> QB.put_arg("id", id),
         client: changeset.client
       }}
    end
  end
end

defimpl Jason.Encoder, for: Dagger.Changeset do
  def encode(changeset, opts) do
    {:ok, id} = Dagger.Changeset.id(changeset)
    Jason.Encode.string(id, opts)
  end
end

defimpl Nestru.Decoder, for: Dagger.Changeset do
  def decode_fields_hint(_struct, _context, id) do
    {:ok, Dagger.Client.load_changeset_from_id(Dagger.Global.dag(), id)}
  end
end
