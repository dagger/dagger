# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.Client do
  @moduledoc "Query"
  use Dagger.QueryBuilder
  @type t() :: %__MODULE__{}
  defstruct [:selection, :client]

  (
    @doc "Constructs a cache volume for a given cache key.\n\n## Required Arguments\n\n* `key` - A string identifier to target this cache volume (e.g., \"modules-cache\")."
    @spec cache_volume(t(), Dagger.String.t()) :: Dagger.CacheVolume.t()
    def cache_volume(%__MODULE__{} = query, key) do
      selection = select(query.selection, "cacheVolume")
      selection = arg(selection, "key", key)
      %Dagger.CacheVolume{selection: selection, client: query.client}
    end
  )

  (
    @doc "Checks if the current Dagger Engine is compatible with an SDK's required version.\n\n## Required Arguments\n\n* `version` - The SDK's required version."
    @spec check_version_compatibility(t(), Dagger.String.t()) ::
            {:ok, Dagger.Boolean.t()} | {:error, term()}
    def check_version_compatibility(%__MODULE__{} = query, version) do
      selection = select(query.selection, "checkVersionCompatibility")
      selection = arg(selection, "version", version)
      execute(selection, query.client)
    end
  )

  (
    @doc "Creates a scratch container or loads one by ID.\n\nOptional platform argument initializes new containers to execute and publish\nas that platform. Platform defaults to that of the builder's host.\n\n\n\n## Optional Arguments\n\n* `id` - \n* `platform` -"
    @spec container(t(), keyword()) :: Dagger.Container.t()
    def container(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "container")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:id])
          arg(selection, "id", id)
        end

      selection =
        if is_nil(optional_args[:platform]) do
          selection
        else
          arg(selection, "platform", optional_args[:platform])
        end

      %Dagger.Container{selection: selection, client: query.client}
    end
  )

  (
    @doc "The FunctionCall context that the SDK caller is currently executing in.\nIf the caller is not currently executing in a function, this will return\nan error."
    @spec current_function_call(t()) :: Dagger.FunctionCall.t()
    def current_function_call(%__MODULE__{} = query) do
      selection = select(query.selection, "currentFunctionCall")
      %Dagger.FunctionCall{selection: selection, client: query.client}
    end
  )

  (
    @doc "The module currently being served in the session, if any."
    @spec current_module(t()) :: {:ok, Dagger.Module.t() | nil} | {:error, term()}
    def current_module(%__MODULE__{} = query) do
      selection = select(query.selection, "currentModule")

      case execute(selection, query.client) do
        {:ok, nil} -> {:ok, nil}
        {:ok, data} -> Nestru.decode_from_map(data, Dagger.Module)
        error -> error
      end
    end
  )

  (
    @doc "The default platform of the builder."
    @spec default_platform(t()) :: {:ok, Dagger.Platform.t()} | {:error, term()}
    def default_platform(%__MODULE__{} = query) do
      selection = select(query.selection, "defaultPlatform")
      execute(selection, query.client)
    end
  )

  (
    @doc "Creates an empty directory or loads one by ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec directory(t(), keyword()) :: Dagger.Directory.t()
    def directory(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "directory")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Directory.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Directory{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a file by ID.\n\n## Required Arguments\n\n* `id` -"
    @deprecated "Use `load_file_from_id` instead"
    @spec file(t(), Dagger.FileID.t()) :: {:ok, Dagger.File.t() | nil} | {:error, term()}
    def file(%__MODULE__{} = query, file) do
      selection = select(query.selection, "file")
      selection = arg(selection, "id", file)
      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Create a function.\n\n## Required Arguments\n\n* `name` - \n* `return_type` -"
    @spec function(t(), Dagger.String.t(), Dagger.TypeDef.t()) :: Dagger.Function.t()
    def function(%__MODULE__{} = query, name, return_type) do
      selection = select(query.selection, "function")
      selection = arg(selection, "name", name)
      selection = arg(selection, "returnType", return_type)
      %Dagger.Function{selection: selection, client: query.client}
    end
  )

  (
    @doc "Create a code generation result, given a directory containing the generated\ncode.\n\n## Required Arguments\n\n* `code` -"
    @spec generated_code(t(), Dagger.Directory.t()) :: Dagger.GeneratedCode.t()
    def generated_code(%__MODULE__{} = query, code) do
      selection = select(query.selection, "generatedCode")

      (
        {:ok, id} = Dagger.Directory.id(code)
        selection = arg(selection, "code", id)
      )

      %Dagger.GeneratedCode{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries a git repository.\n\n## Required Arguments\n\n* `url` - Url of the git repository.\nCan be formatted as https://{host}/{owner}/{repo}, git@{host}:{owner}/{repo}\nSuffix \".git\" is optional.\n\n## Optional Arguments\n\n* `keep_git_dir` - Set to true to keep .git directory.\n* `ssh_known_hosts` - Set SSH known hosts\n* `ssh_auth_socket` - Set SSH auth socket\n* `experimental_service_host` - A service which must be started before the repo is fetched."
    @spec git(t(), Dagger.String.t(), keyword()) :: Dagger.GitRepository.t()
    def git(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "git")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:keep_git_dir]) do
          selection
        else
          arg(selection, "keepGitDir", optional_args[:keep_git_dir])
        end

      selection =
        if is_nil(optional_args[:ssh_known_hosts]) do
          selection
        else
          arg(selection, "sshKnownHosts", optional_args[:ssh_known_hosts])
        end

      selection =
        if is_nil(optional_args[:ssh_auth_socket]) do
          selection
        else
          {:ok, id} = Dagger.Socket.id(optional_args[:ssh_auth_socket])
          arg(selection, "sshAuthSocket", id)
        end

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Service.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.GitRepository{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries the host environment."
    @spec host(t()) :: Dagger.Host.t()
    def host(%__MODULE__{} = query) do
      selection = select(query.selection, "host")
      %Dagger.Host{selection: selection, client: query.client}
    end
  )

  (
    @doc "Returns a file containing an http remote url content.\n\n## Required Arguments\n\n* `url` - HTTP url to get the content from (e.g., \"https://docs.dagger.io\").\n\n## Optional Arguments\n\n* `experimental_service_host` - A service which must be started before the URL is fetched."
    @spec http(t(), Dagger.String.t(), keyword()) :: Dagger.File.t()
    def http(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "http")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Service.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a CacheVolume from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_cache_volume_from_id(t(), Dagger.CacheVolume.t()) :: Dagger.CacheVolume.t()
    def load_cache_volume_from_id(%__MODULE__{} = query, cache_volume) do
      selection = select(query.selection, "loadCacheVolumeFromID")

      (
        {:ok, id} = Dagger.CacheVolume.id(cache_volume)
        selection = arg(selection, "id", id)
      )

      %Dagger.CacheVolume{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a container from an ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_container_from_id(t(), Dagger.Container.t()) :: Dagger.Container.t()
    def load_container_from_id(%__MODULE__{} = query, container) do
      selection = select(query.selection, "loadContainerFromID")

      (
        {:ok, id} = Dagger.Container.id(container)
        selection = arg(selection, "id", id)
      )

      %Dagger.Container{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a Directory from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_directory_from_id(t(), Dagger.Directory.t()) :: Dagger.Directory.t()
    def load_directory_from_id(%__MODULE__{} = query, directory) do
      selection = select(query.selection, "loadDirectoryFromID")

      (
        {:ok, id} = Dagger.Directory.id(directory)
        selection = arg(selection, "id", id)
      )

      %Dagger.Directory{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a File from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_file_from_id(t(), Dagger.File.t()) :: Dagger.File.t()
    def load_file_from_id(%__MODULE__{} = query, file) do
      selection = select(query.selection, "loadFileFromID")

      (
        {:ok, id} = Dagger.File.id(file)
        selection = arg(selection, "id", id)
      )

      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a function argument by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_function_arg_from_id(t(), Dagger.FunctionArg.t()) :: Dagger.FunctionArg.t()
    def load_function_arg_from_id(%__MODULE__{} = query, id) do
      selection = select(query.selection, "loadFunctionArgFromID")
      selection = arg(selection, "id", id)
      %Dagger.FunctionArg{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a function by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_function_from_id(t(), Dagger.Function.t()) :: Dagger.Function.t()
    def load_function_from_id(%__MODULE__{} = query, id) do
      selection = select(query.selection, "loadFunctionFromID")
      selection = arg(selection, "id", id)
      %Dagger.Function{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a GeneratedCode by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_generated_code_from_id(t(), Dagger.GeneratedCode.t()) :: Dagger.GeneratedCode.t()
    def load_generated_code_from_id(%__MODULE__{} = query, id) do
      selection = select(query.selection, "loadGeneratedCodeFromID")
      selection = arg(selection, "id", id)
      %Dagger.GeneratedCode{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a module by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_module_from_id(t(), Dagger.Module.t()) :: Dagger.Module.t()
    def load_module_from_id(%__MODULE__{} = query, id) do
      selection = select(query.selection, "loadModuleFromID")
      selection = arg(selection, "id", id)
      %Dagger.Module{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a Secret from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_secret_from_id(t(), Dagger.Secret.t()) :: Dagger.Secret.t()
    def load_secret_from_id(%__MODULE__{} = query, secret) do
      selection = select(query.selection, "loadSecretFromID")

      (
        {:ok, id} = Dagger.Secret.id(secret)
        selection = arg(selection, "id", id)
      )

      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a service from ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_service_from_id(t(), Dagger.Service.t()) :: Dagger.Service.t()
    def load_service_from_id(%__MODULE__{} = query, service) do
      selection = select(query.selection, "loadServiceFromID")

      (
        {:ok, id} = Dagger.Service.id(service)
        selection = arg(selection, "id", id)
      )

      %Dagger.Service{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a Socket from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_socket_from_id(t(), Dagger.Socket.t()) :: Dagger.Socket.t()
    def load_socket_from_id(%__MODULE__{} = query, socket) do
      selection = select(query.selection, "loadSocketFromID")

      (
        {:ok, id} = Dagger.Socket.id(socket)
        selection = arg(selection, "id", id)
      )

      %Dagger.Socket{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a TypeDef by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec load_type_def_from_id(t(), Dagger.TypeDef.t()) :: Dagger.TypeDef.t()
    def load_type_def_from_id(%__MODULE__{} = query, id) do
      selection = select(query.selection, "loadTypeDefFromID")
      selection = arg(selection, "id", id)
      %Dagger.TypeDef{selection: selection, client: query.client}
    end
  )

  (
    @doc "Create a new module."
    @spec module(t()) :: Dagger.Module.t()
    def module(%__MODULE__{} = query) do
      selection = select(query.selection, "module")
      %Dagger.Module{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load the static configuration for a module from the given source directory and optional subpath.\n\n## Required Arguments\n\n* `source_directory` - \n\n## Optional Arguments\n\n* `subpath` -"
    @spec module_config(t(), Dagger.Directory.t(), keyword()) :: Dagger.ModuleConfig.t()
    def module_config(%__MODULE__{} = query, source_directory, optional_args \\ []) do
      selection = select(query.selection, "moduleConfig")

      (
        {:ok, id} = Dagger.Directory.id(source_directory)
        selection = arg(selection, "sourceDirectory", id)
      )

      selection =
        if is_nil(optional_args[:subpath]) do
          selection
        else
          arg(selection, "subpath", optional_args[:subpath])
        end

      execute(selection, query.client)
    end
  )

  (
    @doc "Creates a named sub-pipeline.\n\n## Required Arguments\n\n* `name` - Pipeline name.\n\n## Optional Arguments\n\n* `description` - Pipeline description.\n* `labels` - Pipeline labels."
    @spec pipeline(t(), Dagger.String.t(), keyword()) :: Dagger.Client.t()
    def pipeline(%__MODULE__{} = query, name, optional_args \\ []) do
      selection = select(query.selection, "pipeline")
      selection = arg(selection, "name", name)

      selection =
        if is_nil(optional_args[:description]) do
          selection
        else
          arg(selection, "description", optional_args[:description])
        end

      selection =
        if is_nil(optional_args[:labels]) do
          selection
        else
          arg(selection, "labels", optional_args[:labels])
        end

      %Dagger.Client{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a secret from its ID.\n\n## Required Arguments\n\n* `id` -"
    @deprecated "Use `load_secret_from_id` instead"
    @spec secret(t(), Dagger.SecretID.t()) :: Dagger.Secret.t()
    def secret(%__MODULE__{} = query, secret) do
      selection = select(query.selection, "secret")
      selection = arg(selection, "id", secret)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Sets a secret given a user defined name to its plaintext and returns the secret.\nThe plaintext value is limited to a size of 128000 bytes.\n\n## Required Arguments\n\n* `name` - The user defined name for this secret\n* `plaintext` - The plaintext of the secret"
    @spec set_secret(t(), Dagger.String.t(), Dagger.String.t()) :: Dagger.Secret.t()
    def set_secret(%__MODULE__{} = query, name, plaintext) do
      selection = select(query.selection, "setSecret")
      selection = arg(selection, "name", name)
      selection = arg(selection, "plaintext", plaintext)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a socket by its ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @deprecated "Use `load_socket_from_id` instead"
    @spec socket(t(), keyword()) :: Dagger.Socket.t()
    def socket(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "socket")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Socket.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Socket{selection: selection, client: query.client}
    end
  )

  (
    @doc "Create a new TypeDef."
    @spec type_def(t()) :: Dagger.TypeDef.t()
    def type_def(%__MODULE__{} = query) do
      selection = select(query.selection, "typeDef")
      %Dagger.TypeDef{selection: selection, client: query.client}
    end
  )
end
