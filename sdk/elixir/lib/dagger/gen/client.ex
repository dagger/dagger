# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.Client do
  @moduledoc "Query"
  use Dagger.QueryBuilder
  @type t() :: %__MODULE__{}
  defstruct [:selection, :client]

  (
    @doc "Constructs a cache volume for a given cache key.\n\n## Required Arguments\n\n* `key` - A string identifier to target this cache volume (e.g., \"modules-cache\")."
    @spec cache_volume(t(), Dagger.String.t()) :: Dagger.CacheVolume.t()
    def cache_volume(%__MODULE__{} = query, key) do
      selection = select(query.selection, "cacheVolume")
      selection = arg(selection, "key", key)
      %Dagger.CacheVolume{selection: selection, client: query.client}
    end
  )

  (
    @doc "Checks if the current Dagger Engine is compatible with an SDK's required version.\n\n## Required Arguments\n\n* `version` - The SDK's required version."
    @spec check_version_compatibility(t(), Dagger.String.t()) ::
            {:ok, Dagger.Boolean.t()} | {:error, term()}
    def check_version_compatibility(%__MODULE__{} = query, version) do
      selection = select(query.selection, "checkVersionCompatibility")
      selection = arg(selection, "version", version)
      execute(selection, query.client)
    end
  )

  (
    @doc "Loads a container from ID.\n\nNull ID returns an empty container (scratch).\nOptional platform argument initializes new containers to execute and publish as that platform.\nPlatform defaults to that of the builder's host.\n\n\n\n## Optional Arguments\n\n* `id` - \n* `platform` -"
    @spec container(t(), keyword()) :: Dagger.Container.t()
    def container(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "container")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:id])
          arg(selection, "id", id)
        end

      selection =
        if is_nil(optional_args[:platform]) do
          selection
        else
          arg(selection, "platform", optional_args[:platform])
        end

      %Dagger.Container{selection: selection, client: query.client}
    end
  )

  (
    @doc "The FunctionCall context that the SDK caller is currently executing in.\nIf the caller is not currently executing in a function, this will return\nan error."
    @spec current_function_call(t()) :: Dagger.FunctionCall.t()
    def current_function_call(%__MODULE__{} = query) do
      selection = select(query.selection, "currentFunctionCall")
      %Dagger.FunctionCall{selection: selection, client: query.client}
    end
  )

  (
    @doc "The module currently being served in the session, if any."
    @spec current_module(t()) :: {:ok, Dagger.Module.t() | nil} | {:error, term()}
    def current_module(%__MODULE__{} = query) do
      selection = select(query.selection, "currentModule")

      case execute(selection, query.client) do
        {:ok, nil} -> {:ok, nil}
        {:ok, data} -> Nestru.decode_from_map(data, Dagger.Module)
        error -> error
      end
    end
  )

  (
    @doc "The default platform of the builder."
    @spec default_platform(t()) :: {:ok, Dagger.Platform.t()} | {:error, term()}
    def default_platform(%__MODULE__{} = query) do
      selection = select(query.selection, "defaultPlatform")
      execute(selection, query.client)
    end
  )

  (
    @doc "Load a directory by ID. No argument produces an empty directory.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec directory(t(), keyword()) :: Dagger.Directory.t()
    def directory(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "directory")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Directory.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Directory{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a file by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec file(t(), Dagger.FileID.t()) :: {:ok, Dagger.File.t() | nil} | {:error, term()}
    def file(%__MODULE__{} = query, file) do
      selection = select(query.selection, "file")
      selection = arg(selection, "id", file)
      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a function by ID\n\n## Required Arguments\n\n* `id` -"
    @spec function(t(), Dagger.Function.t()) :: Dagger.Function.t()
    def function(%__MODULE__{} = query, id) do
      selection = select(query.selection, "function")
      selection = arg(selection, "id", id)
      %Dagger.Function{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load GeneratedCode by ID, or create a new one if id is unset.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec generated_code(t(), keyword()) :: Dagger.GeneratedCode.t()
    def generated_code(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "generatedCode")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          arg(selection, "id", optional_args[:id])
        end

      %Dagger.GeneratedCode{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries a git repository.\n\n## Required Arguments\n\n* `url` - Url of the git repository.\nCan be formatted as https://{host}/{owner}/{repo}, git@{host}/{owner}/{repo}\nSuffix \".git\" is optional.\n\n## Optional Arguments\n\n* `keep_git_dir` - Set to true to keep .git directory.\n* `experimental_service_host` - A service which must be started before the repo is fetched."
    @spec git(t(), Dagger.String.t(), keyword()) :: Dagger.GitRepository.t()
    def git(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "git")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:keep_git_dir]) do
          selection
        else
          arg(selection, "keepGitDir", optional_args[:keep_git_dir])
        end

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.GitRepository{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries the host environment."
    @spec host(t()) :: Dagger.Host.t()
    def host(%__MODULE__{} = query) do
      selection = select(query.selection, "host")
      %Dagger.Host{selection: selection, client: query.client}
    end
  )

  (
    @doc "Returns a file containing an http remote url content.\n\n## Required Arguments\n\n* `url` - HTTP url to get the content from (e.g., \"https://docs.dagger.io\").\n\n## Optional Arguments\n\n* `experimental_service_host` - A service which must be started before the URL is fetched."
    @spec http(t(), Dagger.String.t(), keyword()) :: Dagger.File.t()
    def http(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "http")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a module by ID, or create a new one if id is unset.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec module(t(), keyword()) :: Dagger.Module.t()
    def module(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "module")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          arg(selection, "id", optional_args[:id])
        end

      %Dagger.Module{selection: selection, client: query.client}
    end
  )

  (
    @doc "Create a new function from the provided definition.\n\n## Required Arguments\n\n* `name` - \n* `return_type` -"
    @spec new_function(t(), Dagger.String.t(), Dagger.TypeDef.t()) :: Dagger.Function.t()
    def new_function(%__MODULE__{} = query, name, return_type) do
      selection = select(query.selection, "newFunction")
      selection = arg(selection, "name", name)
      selection = arg(selection, "returnType", return_type)
      %Dagger.Function{selection: selection, client: query.client}
    end
  )

  (
    @doc "Creates a named sub-pipeline.\n\n## Required Arguments\n\n* `name` - Pipeline name.\n\n## Optional Arguments\n\n* `description` - Pipeline description.\n* `labels` - Pipeline labels."
    @spec pipeline(t(), Dagger.String.t(), keyword()) :: Dagger.Client.t()
    def pipeline(%__MODULE__{} = query, name, optional_args \\ []) do
      selection = select(query.selection, "pipeline")
      selection = arg(selection, "name", name)

      selection =
        if is_nil(optional_args[:description]) do
          selection
        else
          arg(selection, "description", optional_args[:description])
        end

      selection =
        if is_nil(optional_args[:labels]) do
          selection
        else
          arg(selection, "labels", optional_args[:labels])
        end

      %Dagger.Client{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a secret from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec secret(t(), Dagger.SecretID.t()) :: Dagger.Secret.t()
    def secret(%__MODULE__{} = query, secret) do
      selection = select(query.selection, "secret")
      selection = arg(selection, "id", secret)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Sets a secret given a user defined name to its plaintext and returns the secret.\nThe plaintext value is limited to a size of 128000 bytes.\n\n## Required Arguments\n\n* `name` - The user defined name for this secret\n* `plaintext` - The plaintext of the secret"
    @spec set_secret(t(), Dagger.String.t(), Dagger.String.t()) :: Dagger.Secret.t()
    def set_secret(%__MODULE__{} = query, name, plaintext) do
      selection = select(query.selection, "setSecret")
      selection = arg(selection, "name", name)
      selection = arg(selection, "plaintext", plaintext)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a socket by its ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec socket(t(), keyword()) :: Dagger.Socket.t()
    def socket(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "socket")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Socket.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Socket{selection: selection, client: query.client}
    end
  )

  (
    @doc "## Optional Arguments\n\n* `id` -"
    @spec type_def(t(), keyword()) :: Dagger.TypeDef.t()
    def type_def(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "typeDef")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          arg(selection, "id", optional_args[:id])
        end

      %Dagger.TypeDef{selection: selection, client: query.client}
    end
  )
end
