# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.Client do
  @moduledoc "Query"
  use Dagger.QueryBuilder
  @type t() :: %__MODULE__{}
  defstruct [:selection, :client]

  (
    @doc "Constructs a cache volume for a given cache key.\n\n## Required Arguments\n\n* `key` - A string identifier to target this cache volume (e.g., \"modules-cache\")."
    @spec cache_volume(t(), Dagger.String.t()) :: Dagger.CacheVolume.t()
    def cache_volume(%__MODULE__{} = query, key) do
      selection = select(query.selection, "cacheVolume")
      selection = arg(selection, "key", key)
      %Dagger.CacheVolume{selection: selection, client: query.client}
    end
  )

  (
    @doc "Checks if the current Dagger Engine is compatible with an SDK's required version.\n\n## Required Arguments\n\n* `version` - The SDK's required version."
    @spec check_version_compatibility(t(), Dagger.String.t()) ::
            {:ok, Dagger.Boolean.t()} | {:error, term()}
    def check_version_compatibility(%__MODULE__{} = query, version) do
      selection = select(query.selection, "checkVersionCompatibility")
      selection = arg(selection, "version", version)
      execute(selection, query.client)
    end
  )

  (
    @doc "Loads a container from ID.\n\nNull ID returns an empty container (scratch).\nOptional platform argument initializes new containers to execute and publish as that platform.\nPlatform defaults to that of the builder's host.\n\n\n\n## Optional Arguments\n\n* `id` - \n* `platform` -"
    @spec container(t(), keyword()) :: Dagger.Container.t()
    def container(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "container")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:id])
          arg(selection, "id", id)
        end

      selection =
        if is_nil(optional_args[:platform]) do
          selection
        else
          arg(selection, "platform", optional_args[:platform])
        end

      %Dagger.Container{selection: selection, client: query.client}
    end
  )

  (
    @doc "The default platform of the builder."
    @spec default_platform(t()) :: {:ok, Dagger.Platform.t()} | {:error, term()}
    def default_platform(%__MODULE__{} = query) do
      selection = select(query.selection, "defaultPlatform")
      execute(selection, query.client)
    end
  )

  (
    @doc "Load a directory by ID. No argument produces an empty directory.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec directory(t(), keyword()) :: Dagger.Directory.t()
    def directory(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "directory")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Directory.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Directory{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a file by ID.\n\n## Required Arguments\n\n* `id` -"
    @spec file(t(), Dagger.FileID.t()) :: {:ok, Dagger.File.t() | nil} | {:error, term()}
    def file(%__MODULE__{} = query, file) do
      selection = select(query.selection, "file")
      selection = arg(selection, "id", file)
      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries a git repository.\n\n## Required Arguments\n\n* `url` - Url of the git repository.\nCan be formatted as https://{host}/{owner}/{repo}, git@{host}/{owner}/{repo}\nSuffix \".git\" is optional.\n\n## Optional Arguments\n\n* `keep_git_dir` - Set to true to keep .git directory.\n* `experimental_service_host` - A service which must be started before the repo is fetched."
    @spec git(t(), Dagger.String.t(), keyword()) :: Dagger.GitRepository.t()
    def git(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "git")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:keep_git_dir]) do
          selection
        else
          arg(selection, "keepGitDir", optional_args[:keep_git_dir])
        end

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.GitRepository{selection: selection, client: query.client}
    end
  )

  (
    @doc "Queries the host environment."
    @spec host(t()) :: Dagger.Host.t()
    def host(%__MODULE__{} = query) do
      selection = select(query.selection, "host")
      %Dagger.Host{selection: selection, client: query.client}
    end
  )

  (
    @doc "Returns a file containing an http remote url content.\n\n## Required Arguments\n\n* `url` - HTTP url to get the content from (e.g., \"https://docs.dagger.io\").\n\n## Optional Arguments\n\n* `experimental_service_host` - A service which must be started before the URL is fetched."
    @spec http(t(), Dagger.String.t(), keyword()) :: Dagger.File.t()
    def http(%__MODULE__{} = query, url, optional_args \\ []) do
      selection = select(query.selection, "http")
      selection = arg(selection, "url", url)

      selection =
        if is_nil(optional_args[:experimental_service_host]) do
          selection
        else
          {:ok, id} = Dagger.Container.id(optional_args[:experimental_service_host])
          arg(selection, "experimentalServiceHost", id)
        end

      %Dagger.File{selection: selection, client: query.client}
    end
  )

  (
    @doc "Creates a named sub-pipeline.\n\n## Required Arguments\n\n* `name` - Pipeline name.\n\n## Optional Arguments\n\n* `description` - Pipeline description.\n* `labels` - Pipeline labels."
    @spec pipeline(t(), Dagger.String.t(), keyword()) :: Dagger.Client.t()
    def pipeline(%__MODULE__{} = query, name, optional_args \\ []) do
      selection = select(query.selection, "pipeline")
      selection = arg(selection, "name", name)

      selection =
        if is_nil(optional_args[:description]) do
          selection
        else
          arg(selection, "description", optional_args[:description])
        end

      selection =
        if is_nil(optional_args[:labels]) do
          selection
        else
          arg(selection, "labels", optional_args[:labels])
        end

      %Dagger.Client{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a project from ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec project(t(), keyword()) :: Dagger.Project.t()
    def project(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "project")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Project.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Project{selection: selection, client: query.client}
    end
  )

  (
    @doc "Load a project command from ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec project_command(t(), keyword()) :: Dagger.ProjectCommand.t()
    def project_command(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "projectCommand")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.ProjectCommand.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.ProjectCommand{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a secret from its ID.\n\n## Required Arguments\n\n* `id` -"
    @spec secret(t(), Dagger.SecretID.t()) :: Dagger.Secret.t()
    def secret(%__MODULE__{} = query, secret) do
      selection = select(query.selection, "secret")
      selection = arg(selection, "id", secret)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Sets a secret given a user defined name to its plaintext and returns the secret.\nThe plaintext value is limited to a size of 128000 bytes.\n\n## Required Arguments\n\n* `name` - The user defined name for this secret\n* `plaintext` - The plaintext of the secret"
    @spec set_secret(t(), Dagger.String.t(), Dagger.String.t()) :: Dagger.Secret.t()
    def set_secret(%__MODULE__{} = query, name, plaintext) do
      selection = select(query.selection, "setSecret")
      selection = arg(selection, "name", name)
      selection = arg(selection, "plaintext", plaintext)
      %Dagger.Secret{selection: selection, client: query.client}
    end
  )

  (
    @doc "Loads a socket by its ID.\n\n\n\n## Optional Arguments\n\n* `id` -"
    @spec socket(t(), keyword()) :: Dagger.Socket.t()
    def socket(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "socket")

      selection =
        if is_nil(optional_args[:id]) do
          selection
        else
          {:ok, id} = Dagger.Socket.id(optional_args[:id])
          arg(selection, "id", id)
        end

      %Dagger.Socket{selection: selection, client: query.client}
    end
  )

  (
    @doc "Stops all resources, with an optional timeout.\n\nReturns true if all resources were stopped.\n\nExperimental. This should be called by the SDK prior to closing the\nunderlying connection. It helps ensure that the client receives progress for\neverything shutting down (e.g. services).\n\n\n\n## Optional Arguments\n\n* `timeout` - Seconds to wait before giving up."
    @spec stop(t(), keyword()) :: {:ok, Dagger.Boolean.t()} | {:error, term()}
    def stop(%__MODULE__{} = query, optional_args \\ []) do
      selection = select(query.selection, "stop")

      selection =
        if is_nil(optional_args[:timeout]) do
          selection
        else
          arg(selection, "timeout", optional_args[:timeout])
        end

      execute(selection, query.client)
    end
  )
end
