# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.Directory do
  @moduledoc "A directory."

  alias Dagger.Core.Client
  alias Dagger.Core.QueryBuilder, as: QB

  @derive Dagger.ID
  @derive Dagger.Sync
  defstruct [:query_builder, :client]

  @type t() :: %__MODULE__{}

  @doc "Load the directory as a Dagger module"
  @spec as_module(t(), [
          {:source_root_path, String.t() | nil},
          {:engine_version, String.t() | nil}
        ]) :: Dagger.Module.t()
  def as_module(%__MODULE__{} = directory, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("asModule")
      |> QB.maybe_put_arg("sourceRootPath", optional_args[:source_root_path])
      |> QB.maybe_put_arg("engineVersion", optional_args[:engine_version])

    %Dagger.Module{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Gets the difference between this directory and an another directory."
  @spec diff(t(), Dagger.Directory.t()) :: Dagger.Directory.t()
  def diff(%__MODULE__{} = directory, other) do
    query_builder =
      directory.query_builder |> QB.select("diff") |> QB.put_arg("other", Dagger.ID.id!(other))

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Return the directory's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine."
  @spec digest(t()) :: {:ok, String.t()} | {:error, term()}
  def digest(%__MODULE__{} = directory) do
    query_builder =
      directory.query_builder |> QB.select("digest")

    Client.execute(directory.client, query_builder)
  end

  @doc "Retrieves a directory at the given path."
  @spec directory(t(), String.t()) :: Dagger.Directory.t()
  def directory(%__MODULE__{} = directory, path) do
    query_builder =
      directory.query_builder |> QB.select("directory") |> QB.put_arg("path", path)

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Builds a new Docker container from this directory."
  @spec docker_build(t(), [
          {:platform, Dagger.Platform.t() | nil},
          {:dockerfile, String.t() | nil},
          {:target, String.t() | nil},
          {:build_args, [Dagger.BuildArg.t()]},
          {:secrets, [Dagger.SecretID.t()]}
        ]) :: Dagger.Container.t()
  def docker_build(%__MODULE__{} = directory, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("dockerBuild")
      |> QB.maybe_put_arg("platform", optional_args[:platform])
      |> QB.maybe_put_arg("dockerfile", optional_args[:dockerfile])
      |> QB.maybe_put_arg("target", optional_args[:target])
      |> QB.maybe_put_arg("buildArgs", optional_args[:build_args])
      |> QB.maybe_put_arg(
        "secrets",
        if(optional_args[:secrets],
          do: Enum.map(optional_args[:secrets], &Dagger.ID.id!/1),
          else: nil
        )
      )

    %Dagger.Container{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Returns a list of files and directories at the given path."
  @spec entries(t(), [{:path, String.t() | nil}]) :: {:ok, [String.t()]} | {:error, term()}
  def entries(%__MODULE__{} = directory, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("entries")
      |> QB.maybe_put_arg("path", optional_args[:path])

    Client.execute(directory.client, query_builder)
  end

  @doc "Writes the contents of the directory to a path on the host."
  @spec export(t(), String.t(), [{:wipe, boolean() | nil}]) ::
          {:ok, String.t()} | {:error, term()}
  def export(%__MODULE__{} = directory, path, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("export")
      |> QB.put_arg("path", path)
      |> QB.maybe_put_arg("wipe", optional_args[:wipe])

    Client.execute(directory.client, query_builder)
  end

  @doc "Retrieves a file at the given path."
  @spec file(t(), String.t()) :: Dagger.File.t()
  def file(%__MODULE__{} = directory, path) do
    query_builder =
      directory.query_builder |> QB.select("file") |> QB.put_arg("path", path)

    %Dagger.File{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Returns a list of files and directories that matche the given pattern."
  @spec glob(t(), String.t()) :: {:ok, [String.t()]} | {:error, term()}
  def glob(%__MODULE__{} = directory, pattern) do
    query_builder =
      directory.query_builder |> QB.select("glob") |> QB.put_arg("pattern", pattern)

    Client.execute(directory.client, query_builder)
  end

  @doc "A unique identifier for this Directory."
  @spec id(t()) :: {:ok, Dagger.DirectoryID.t()} | {:error, term()}
  def id(%__MODULE__{} = directory) do
    query_builder =
      directory.query_builder |> QB.select("id")

    Client.execute(directory.client, query_builder)
  end

  @doc "Force evaluation in the engine."
  @spec sync(t()) :: {:ok, Dagger.Directory.t()} | {:error, term()}
  def sync(%__MODULE__{} = directory) do
    query_builder =
      directory.query_builder |> QB.select("sync")

    with {:ok, id} <- Client.execute(directory.client, query_builder) do
      {:ok,
       %Dagger.Directory{
         query_builder:
           QB.query()
           |> QB.select("loadDirectoryFromID")
           |> QB.put_arg("id", id),
         client: directory.client
       }}
    end
  end

  @doc "Opens an interactive terminal in new container with this directory mounted inside."
  @spec terminal(t(), [
          {:cmd, [String.t()]},
          {:experimental_privileged_nesting, boolean() | nil},
          {:insecure_root_capabilities, boolean() | nil},
          {:container, Dagger.ContainerID.t() | nil}
        ]) :: Dagger.Directory.t()
  def terminal(%__MODULE__{} = directory, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("terminal")
      |> QB.maybe_put_arg("cmd", optional_args[:cmd])
      |> QB.maybe_put_arg(
        "experimentalPrivilegedNesting",
        optional_args[:experimental_privileged_nesting]
      )
      |> QB.maybe_put_arg("insecureRootCapabilities", optional_args[:insecure_root_capabilities])
      |> QB.maybe_put_arg("container", optional_args[:container])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory plus a directory written at the given path."
  @spec with_directory(t(), String.t(), Dagger.Directory.t(), [
          {:exclude, [String.t()]},
          {:include, [String.t()]}
        ]) :: Dagger.Directory.t()
  def with_directory(%__MODULE__{} = directory_, path, directory, optional_args \\ []) do
    query_builder =
      directory_.query_builder
      |> QB.select("withDirectory")
      |> QB.put_arg("path", path)
      |> QB.put_arg("directory", Dagger.ID.id!(directory))
      |> QB.maybe_put_arg("exclude", optional_args[:exclude])
      |> QB.maybe_put_arg("include", optional_args[:include])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory_.client
    }
  end

  @doc "Retrieves this directory plus the contents of the given file copied to the given path."
  @spec with_file(t(), String.t(), Dagger.File.t(), [{:permissions, integer() | nil}]) ::
          Dagger.Directory.t()
  def with_file(%__MODULE__{} = directory, path, source, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("withFile")
      |> QB.put_arg("path", path)
      |> QB.put_arg("source", Dagger.ID.id!(source))
      |> QB.maybe_put_arg("permissions", optional_args[:permissions])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory plus the contents of the given files copied to the given path."
  @spec with_files(t(), String.t(), [Dagger.FileID.t()], [{:permissions, integer() | nil}]) ::
          Dagger.Directory.t()
  def with_files(%__MODULE__{} = directory, path, sources, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("withFiles")
      |> QB.put_arg("path", path)
      |> QB.put_arg("sources", sources)
      |> QB.maybe_put_arg("permissions", optional_args[:permissions])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory plus a new directory created at the given path."
  @spec with_new_directory(t(), String.t(), [{:permissions, integer() | nil}]) ::
          Dagger.Directory.t()
  def with_new_directory(%__MODULE__{} = directory, path, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("withNewDirectory")
      |> QB.put_arg("path", path)
      |> QB.maybe_put_arg("permissions", optional_args[:permissions])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory plus a new file written at the given path."
  @spec with_new_file(t(), String.t(), String.t(), [{:permissions, integer() | nil}]) ::
          Dagger.Directory.t()
  def with_new_file(%__MODULE__{} = directory, path, contents, optional_args \\ []) do
    query_builder =
      directory.query_builder
      |> QB.select("withNewFile")
      |> QB.put_arg("path", path)
      |> QB.put_arg("contents", contents)
      |> QB.maybe_put_arg("permissions", optional_args[:permissions])

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory with all file/dir timestamps set to the given time."
  @spec with_timestamps(t(), integer()) :: Dagger.Directory.t()
  def with_timestamps(%__MODULE__{} = directory, timestamp) do
    query_builder =
      directory.query_builder |> QB.select("withTimestamps") |> QB.put_arg("timestamp", timestamp)

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory with the directory at the given path removed."
  @spec without_directory(t(), String.t()) :: Dagger.Directory.t()
  def without_directory(%__MODULE__{} = directory, path) do
    query_builder =
      directory.query_builder |> QB.select("withoutDirectory") |> QB.put_arg("path", path)

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory with the file at the given path removed."
  @spec without_file(t(), String.t()) :: Dagger.Directory.t()
  def without_file(%__MODULE__{} = directory, path) do
    query_builder =
      directory.query_builder |> QB.select("withoutFile") |> QB.put_arg("path", path)

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end

  @doc "Retrieves this directory with the files at the given paths removed."
  @spec without_files(t(), [String.t()]) :: Dagger.Directory.t()
  def without_files(%__MODULE__{} = directory, paths) do
    query_builder =
      directory.query_builder |> QB.select("withoutFiles") |> QB.put_arg("paths", paths)

    %Dagger.Directory{
      query_builder: query_builder,
      client: directory.client
    }
  end
end
