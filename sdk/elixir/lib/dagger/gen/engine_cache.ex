# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.EngineCache do
  @moduledoc """
  A cache storage for the Dagger engine
  """

  use Dagger.Core.Base, kind: :object, name: "EngineCache"

  alias Dagger.Core.Client
  alias Dagger.Core.QueryBuilder, as: QB

  @derive Dagger.ID

  defstruct [:query_builder, :client]

  @type t() :: %__MODULE__{}

  @doc """
  The current set of entries in the cache
  """
  @spec entry_set(t(), [{:key, String.t() | nil}]) :: Dagger.EngineCacheEntrySet.t()
  def entry_set(%__MODULE__{} = engine_cache, optional_args \\ []) do
    query_builder =
      engine_cache.query_builder
      |> QB.select("entrySet")
      |> QB.maybe_put_arg("key", optional_args[:key])

    %Dagger.EngineCacheEntrySet{
      query_builder: query_builder,
      client: engine_cache.client
    }
  end

  @doc """
  A unique identifier for this EngineCache.
  """
  @spec id(t()) :: {:ok, Dagger.EngineCacheID.t()} | {:error, term()}
  def id(%__MODULE__{} = engine_cache) do
    query_builder =
      engine_cache.query_builder |> QB.select("id")

    Client.execute(engine_cache.client, query_builder)
  end

  @doc """
  The maximum bytes to keep in the cache without pruning.
  """
  @spec max_used_space(t()) :: {:ok, integer()} | {:error, term()}
  def max_used_space(%__MODULE__{} = engine_cache) do
    query_builder =
      engine_cache.query_builder |> QB.select("maxUsedSpace")

    Client.execute(engine_cache.client, query_builder)
  end

  @doc """
  The target amount of free disk space the garbage collector will attempt to leave.
  """
  @spec min_free_space(t()) :: {:ok, integer()} | {:error, term()}
  def min_free_space(%__MODULE__{} = engine_cache) do
    query_builder =
      engine_cache.query_builder |> QB.select("minFreeSpace")

    Client.execute(engine_cache.client, query_builder)
  end

  @doc """
  Prune the cache of releaseable entries
  """
  @spec prune(t(), [{:use_default_policy, boolean() | nil}]) :: :ok | {:error, term()}
  def prune(%__MODULE__{} = engine_cache, optional_args \\ []) do
    query_builder =
      engine_cache.query_builder
      |> QB.select("prune")
      |> QB.maybe_put_arg("useDefaultPolicy", optional_args[:use_default_policy])

    case Client.execute(engine_cache.client, query_builder) do
      {:ok, _} -> :ok
      error -> error
    end
  end

  @doc """
  The minimum amount of disk space this policy is guaranteed to retain.
  """
  @spec reserved_space(t()) :: {:ok, integer()} | {:error, term()}
  def reserved_space(%__MODULE__{} = engine_cache) do
    query_builder =
      engine_cache.query_builder |> QB.select("reservedSpace")

    Client.execute(engine_cache.client, query_builder)
  end

  @doc """
  The target number of bytes to keep when pruning.
  """
  @spec target_space(t()) :: {:ok, integer()} | {:error, term()}
  def target_space(%__MODULE__{} = engine_cache) do
    query_builder =
      engine_cache.query_builder |> QB.select("targetSpace")

    Client.execute(engine_cache.client, query_builder)
  end
end

defimpl Jason.Encoder, for: Dagger.EngineCache do
  def encode(engine_cache, opts) do
    {:ok, id} = Dagger.EngineCache.id(engine_cache)
    Jason.Encode.string(id, opts)
  end
end

defimpl Nestru.Decoder, for: Dagger.EngineCache do
  def decode_fields_hint(_struct, _context, id) do
    {:ok, Dagger.Client.load_engine_cache_from_id(Dagger.Global.dag(), id)}
  end
end
