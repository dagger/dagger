# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.Function do
  @moduledoc "Function represents a resolver provided by a Module.\n\nA function always evaluates against a parent object and is given a set of\nnamed arguments."
  use Dagger.QueryBuilder
  @type t() :: %__MODULE__{}
  defstruct [:selection, :client]

  (
    @doc "Arguments accepted by this function, if any"
    @spec args(t()) :: {:ok, [Dagger.FunctionArg.t()] | nil} | {:error, term()}
    def args(%__MODULE__{} = function) do
      selection = select(function.selection, "args")
      execute(selection, function.client)
    end
  )

  (
    @doc "Execute this function using dynamic input+output types.\n\nTypically, it's preferable to invoke a function using a type\nsafe graphql query rather than using this call field. However,\ncall is useful for some advanced use cases where dynamically\nloading arbitrary modules and invoking functions in them is\nrequired.\n\n\n\n## Optional Arguments\n\n* `input` -"
    @spec call(t(), keyword()) :: {:ok, Dagger.JSON.t()} | {:error, term()}
    def call(%__MODULE__{} = function, optional_args \\ []) do
      selection = select(function.selection, "call")

      selection =
        if is_nil(optional_args[:input]) do
          selection
        else
          arg(selection, "input", optional_args[:input])
        end

      execute(selection, function.client)
    end
  )

  (
    @doc "A doc string for the function, if any"
    @spec description(t()) :: {:ok, Dagger.String.t() | nil} | {:error, term()}
    def description(%__MODULE__{} = function) do
      selection = select(function.selection, "description")
      execute(selection, function.client)
    end
  )

  (
    @doc "The ID of the function"
    @spec id(t()) :: {:ok, Dagger.FunctionID.t()} | {:error, term()}
    def id(%__MODULE__{} = function) do
      selection = select(function.selection, "id")
      execute(selection, function.client)
    end
  )

  (
    @doc "The name of the function"
    @spec name(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def name(%__MODULE__{} = function) do
      selection = select(function.selection, "name")
      execute(selection, function.client)
    end
  )

  (
    @doc "The type returned by this function"
    @spec return_type(t()) :: Dagger.TypeDef.t()
    def return_type(%__MODULE__{} = function) do
      selection = select(function.selection, "returnType")
      %Dagger.TypeDef{selection: selection, client: function.client}
    end
  )

  (
    @doc "Returns the function with the provided argument\n\n## Required Arguments\n\n* `name` - The name of the argument\n* `type_def` - The type of the argument\n\n## Optional Arguments\n\n* `description` - A doc string for the argument, if any\n* `default_value` - A default value to use for this argument if not explicitly set by the caller, if any"
    @spec with_arg(t(), Dagger.String.t(), Dagger.TypeDef.t(), keyword()) :: Dagger.Function.t()
    def with_arg(%__MODULE__{} = function, name, type_def, optional_args \\ []) do
      selection = select(function.selection, "withArg")
      selection = arg(selection, "name", name)
      selection = arg(selection, "typeDef", type_def)

      selection =
        if is_nil(optional_args[:description]) do
          selection
        else
          arg(selection, "description", optional_args[:description])
        end

      selection =
        if is_nil(optional_args[:default_value]) do
          selection
        else
          arg(selection, "defaultValue", optional_args[:default_value])
        end

      %Dagger.Function{selection: selection, client: function.client}
    end
  )

  (
    @doc "Returns the function with the doc string\n\n## Required Arguments\n\n* `description` -"
    @spec with_description(t(), Dagger.String.t()) :: Dagger.Function.t()
    def with_description(%__MODULE__{} = function, description) do
      selection = select(function.selection, "withDescription")
      selection = arg(selection, "description", description)
      %Dagger.Function{selection: selection, client: function.client}
    end
  )
end
