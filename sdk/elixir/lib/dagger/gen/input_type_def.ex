# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.InputTypeDef do
  @moduledoc """
  A graphql input type, which is essentially just a group of named args.
  This is currently only used to represent pre-existing usage of graphql input types
  in the core API. It is not used by user modules and shouldn't ever be as user
  module accept input objects via their id rather than graphql input types.
  """

  alias Dagger.Core.Client
  alias Dagger.Core.QueryBuilder, as: QB

  @derive Dagger.ID

  defstruct [:query_builder, :client]

  @type t() :: %__MODULE__{}

  @doc "Static fields defined on this input object, if any."
  @spec fields(t()) :: {:ok, [Dagger.FieldTypeDef.t()]} | {:error, term()}
  def fields(%__MODULE__{} = input_type_def) do
    query_builder =
      input_type_def.query_builder |> QB.select("fields") |> QB.select("id")

    with {:ok, items} <- Client.execute(input_type_def.client, query_builder) do
      {:ok,
       for %{"id" => id} <- items do
         %Dagger.FieldTypeDef{
           query_builder:
             QB.query()
             |> QB.select("loadFieldTypeDefFromID")
             |> QB.put_arg("id", id),
           client: input_type_def.client
         }
       end}
    end
  end

  @doc "A unique identifier for this InputTypeDef."
  @spec id(t()) :: {:ok, Dagger.InputTypeDefID.t()} | {:error, term()}
  def id(%__MODULE__{} = input_type_def) do
    query_builder =
      input_type_def.query_builder |> QB.select("id")

    Client.execute(input_type_def.client, query_builder)
  end

  @doc "The name of the input object."
  @spec name(t()) :: {:ok, String.t()} | {:error, term()}
  def name(%__MODULE__{} = input_type_def) do
    query_builder =
      input_type_def.query_builder |> QB.select("name")

    Client.execute(input_type_def.client, query_builder)
  end
end
