# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.Module do
  @moduledoc "A Dagger module."

  use Dagger.Core.QueryBuilder

  @derive Dagger.ID

  defstruct [:selection, :client]

  @type t() :: %__MODULE__{}

  @doc "Modules used by this module."
  @spec dependencies(t()) :: {:ok, [Dagger.Module.t()]} | {:error, term()}
  def dependencies(%__MODULE__{} = module) do
    selection =
      module.selection |> select("dependencies") |> select("id")

    with {:ok, items} <- execute(selection, module.client) do
      {:ok,
       for %{"id" => id} <- items do
         %Dagger.Module{
           selection:
             query()
             |> select("loadModuleFromID")
             |> arg("id", id),
           client: module.client
         }
       end}
    end
  end

  @doc "The dependencies as configured by the module."
  @spec dependency_config(t()) :: {:ok, [Dagger.ModuleDependency.t()]} | {:error, term()}
  def dependency_config(%__MODULE__{} = module) do
    selection =
      module.selection |> select("dependencyConfig") |> select("id")

    with {:ok, items} <- execute(selection, module.client) do
      {:ok,
       for %{"id" => id} <- items do
         %Dagger.ModuleDependency{
           selection:
             query()
             |> select("loadModuleDependencyFromID")
             |> arg("id", id),
           client: module.client
         }
       end}
    end
  end

  @doc "The doc string of the module, if any"
  @spec description(t()) :: {:ok, String.t()} | {:error, term()}
  def description(%__MODULE__{} = module) do
    selection =
      module.selection |> select("description")

    execute(selection, module.client)
  end

  @doc "The generated files and directories made on top of the module source's context directory."
  @spec generated_context_diff(t()) :: Dagger.Directory.t()
  def generated_context_diff(%__MODULE__{} = module) do
    selection =
      module.selection |> select("generatedContextDiff")

    %Dagger.Directory{
      selection: selection,
      client: module.client
    }
  end

  @doc "The module source's context plus any configuration and source files created by codegen."
  @spec generated_context_directory(t()) :: Dagger.Directory.t()
  def generated_context_directory(%__MODULE__{} = module) do
    selection =
      module.selection |> select("generatedContextDirectory")

    %Dagger.Directory{
      selection: selection,
      client: module.client
    }
  end

  @doc "A unique identifier for this Module."
  @spec id(t()) :: {:ok, Dagger.ModuleID.t()} | {:error, term()}
  def id(%__MODULE__{} = module) do
    selection =
      module.selection |> select("id")

    execute(selection, module.client)
  end

  @doc "Retrieves the module with the objects loaded via its SDK."
  @spec initialize(t()) :: Dagger.Module.t()
  def initialize(%__MODULE__{} = module) do
    selection =
      module.selection |> select("initialize")

    %Dagger.Module{
      selection: selection,
      client: module.client
    }
  end

  @doc "Interfaces served by this module."
  @spec interfaces(t()) :: {:ok, [Dagger.TypeDef.t()]} | {:error, term()}
  def interfaces(%__MODULE__{} = module) do
    selection =
      module.selection |> select("interfaces") |> select("id")

    with {:ok, items} <- execute(selection, module.client) do
      {:ok,
       for %{"id" => id} <- items do
         %Dagger.TypeDef{
           selection:
             query()
             |> select("loadTypeDefFromID")
             |> arg("id", id),
           client: module.client
         }
       end}
    end
  end

  @doc "The name of the module"
  @spec name(t()) :: {:ok, String.t()} | {:error, term()}
  def name(%__MODULE__{} = module) do
    selection =
      module.selection |> select("name")

    execute(selection, module.client)
  end

  @doc "Objects served by this module."
  @spec objects(t()) :: {:ok, [Dagger.TypeDef.t()]} | {:error, term()}
  def objects(%__MODULE__{} = module) do
    selection =
      module.selection |> select("objects") |> select("id")

    with {:ok, items} <- execute(selection, module.client) do
      {:ok,
       for %{"id" => id} <- items do
         %Dagger.TypeDef{
           selection:
             query()
             |> select("loadTypeDefFromID")
             |> arg("id", id),
           client: module.client
         }
       end}
    end
  end

  @doc "The container that runs the module's entrypoint. It will fail to execute if the module doesn't compile."
  @spec runtime(t()) :: Dagger.Container.t()
  def runtime(%__MODULE__{} = module) do
    selection =
      module.selection |> select("runtime")

    %Dagger.Container{
      selection: selection,
      client: module.client
    }
  end

  @doc "The SDK used by this module. Either a name of a builtin SDK or a module source ref string pointing to the SDK's implementation."
  @spec sdk(t()) :: {:ok, String.t()} | {:error, term()}
  def sdk(%__MODULE__{} = module) do
    selection =
      module.selection |> select("sdk")

    execute(selection, module.client)
  end

  @doc """
  Serve a module's API in the current session.

  Note: this can only be called once per session. In the future, it could return a stream or service to remove the side effect.
  """
  @spec serve(t()) :: {:ok, Dagger.Void.t() | nil} | {:error, term()}
  def serve(%__MODULE__{} = module) do
    selection =
      module.selection |> select("serve")

    execute(selection, module.client)
  end

  @doc "The source for the module."
  @spec source(t()) :: Dagger.ModuleSource.t()
  def source(%__MODULE__{} = module) do
    selection =
      module.selection |> select("source")

    %Dagger.ModuleSource{
      selection: selection,
      client: module.client
    }
  end

  @doc "Retrieves the module with the given description"
  @spec with_description(t(), String.t()) :: Dagger.Module.t()
  def with_description(%__MODULE__{} = module, description) do
    selection =
      module.selection |> select("withDescription") |> put_arg("description", description)

    %Dagger.Module{
      selection: selection,
      client: module.client
    }
  end

  @doc "This module plus the given Interface type and associated functions"
  @spec with_interface(t(), Dagger.TypeDef.t()) :: Dagger.Module.t()
  def with_interface(%__MODULE__{} = module, iface) do
    selection =
      module.selection |> select("withInterface") |> put_arg("iface", Dagger.ID.id!(iface))

    %Dagger.Module{
      selection: selection,
      client: module.client
    }
  end

  @doc "This module plus the given Object type and associated functions."
  @spec with_object(t(), Dagger.TypeDef.t()) :: Dagger.Module.t()
  def with_object(%__MODULE__{} = module, object) do
    selection =
      module.selection |> select("withObject") |> put_arg("object", Dagger.ID.id!(object))

    %Dagger.Module{
      selection: selection,
      client: module.client
    }
  end

  @doc "Retrieves the module with basic configuration loaded if present."
  @spec with_source(t(), Dagger.ModuleSource.t()) :: Dagger.Module.t()
  def with_source(%__MODULE__{} = module, source) do
    selection =
      module.selection |> select("withSource") |> put_arg("source", Dagger.ID.id!(source))

    %Dagger.Module{
      selection: selection,
      client: module.client
    }
  end
end
