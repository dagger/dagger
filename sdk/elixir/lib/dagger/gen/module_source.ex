# This file generated by `mix dagger.gen`. Please DO NOT EDIT.
defmodule Dagger.ModuleSource do
  @moduledoc "The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc."
  use Dagger.Core.QueryBuilder
  @type t() :: %__MODULE__{}
  defstruct [:selection, :client]

  (
    @doc "If the source is a of kind git, the git source representation of it."
    @spec as_git_source(t()) :: {:ok, Dagger.GitModuleSource.t() | nil} | {:error, term()}
    def as_git_source(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "asGitSource")

      case execute(selection, module_source.client) do
        {:ok, nil} -> {:ok, nil}
        {:ok, data} -> Nestru.decode_from_map(data, Dagger.GitModuleSource)
        error -> error
      end
    end
  )

  (
    @doc "If the source is of kind local, the local source representation of it."
    @spec as_local_source(t()) :: {:ok, Dagger.LocalModuleSource.t() | nil} | {:error, term()}
    def as_local_source(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "asLocalSource")

      case execute(selection, module_source.client) do
        {:ok, nil} -> {:ok, nil}
        {:ok, data} -> Nestru.decode_from_map(data, Dagger.LocalModuleSource)
        error -> error
      end
    end
  )

  (
    @doc "Load the source as a module. If this is a local source, the parent directory must have been provided during module source creation"
    @spec as_module(t()) :: Dagger.Module.t()
    def as_module(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "asModule")
      %Dagger.Module{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "A human readable ref string representation of this module source."
    @spec as_string(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def as_string(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "asString")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "Returns whether the module source has a configuration file."
    @spec config_exists(t()) :: {:ok, Dagger.Boolean.t()} | {:error, term()}
    def config_exists(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "configExists")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "The directory containing everything needed to load load and use the module."
    @spec context_directory(t()) :: Dagger.Directory.t()
    def context_directory(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "contextDirectory")
      %Dagger.Directory{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "The dependencies of the module source. Includes dependencies from the configuration and any extras from withDependencies calls."
    @spec dependencies(t()) :: {:ok, [Dagger.ModuleDependency.t()]} | {:error, term()}
    def dependencies(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "dependencies")
      selection = select(selection, "id name source")

      with {:ok, data} <- execute(selection, module_source.client) do
        {:ok,
         data
         |> Enum.map(fn value ->
           elem_selection = Dagger.Core.QueryBuilder.Selection.query()
           elem_selection = select(elem_selection, "loadModuleDependencyFromID")
           elem_selection = arg(elem_selection, "id", value["id"])
           %Dagger.ModuleDependency{selection: elem_selection, client: module_source.client}
         end)}
      end
    end
  )

  (
    @doc "The directory containing the module configuration and source code (source code may be in a subdir).\n\n## Required Arguments\n\n* `path` - The path from the source directory to select."
    @spec directory(t(), Dagger.String.t()) :: Dagger.Directory.t()
    def directory(%__MODULE__{} = module_source, path) do
      selection = select(module_source.selection, "directory")
      selection = arg(selection, "path", path)
      %Dagger.Directory{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "A unique identifier for this ModuleSource."
    @spec id(t()) :: {:ok, Dagger.ModuleSourceID.t()} | {:error, term()}
    def id(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "id")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "The kind of source (e.g. local, git, etc.)"
    @spec kind(t()) :: {:ok, Dagger.ModuleSourceKind.t()} | {:error, term()}
    def kind(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "kind")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "If set, the name of the module this source references, including any overrides at runtime by callers."
    @spec module_name(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def module_name(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "moduleName")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "The original name of the module this source references, as defined in the module configuration."
    @spec module_original_name(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def module_original_name(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "moduleOriginalName")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "The path to the module source's context directory on the caller's filesystem. Only valid for local sources."
    @spec resolve_context_path_from_caller(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def resolve_context_path_from_caller(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "resolveContextPathFromCaller")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "Resolve the provided module source arg as a dependency relative to this module source.\n\n## Required Arguments\n\n* `dep` - The dependency module source to resolve."
    @spec resolve_dependency(t(), Dagger.ModuleSource.t()) :: Dagger.ModuleSource.t()
    def resolve_dependency(%__MODULE__{} = module_source, dep) do
      selection = select(module_source.selection, "resolveDependency")
      selection = arg(selection, "dep", dep)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Load a directory from the caller optionally with a given view applied.\n\n## Required Arguments\n\n* `path` - The path on the caller's filesystem to load.\n\n## Optional Arguments\n\n* `view_name` - If set, the name of the view to apply to the path."
    @spec resolve_directory_from_caller(t(), Dagger.String.t(), keyword()) :: Dagger.Directory.t()
    def resolve_directory_from_caller(%__MODULE__{} = module_source, path, optional_args \\ []) do
      selection = select(module_source.selection, "resolveDirectoryFromCaller")
      selection = arg(selection, "path", path)

      selection =
        if is_nil(optional_args[:view_name]) do
          selection
        else
          arg(selection, "viewName", optional_args[:view_name])
        end

      %Dagger.Directory{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Load the source from its path on the caller's filesystem, including only needed+configured files and directories. Only valid for local sources."
    @spec resolve_from_caller(t()) :: Dagger.ModuleSource.t()
    def resolve_from_caller(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "resolveFromCaller")
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "The path relative to context of the root of the module source, which contains dagger.json. It also contains the module implementation source code, but that may or may not being a subdir of this root."
    @spec source_root_subpath(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def source_root_subpath(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "sourceRootSubpath")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "The path relative to context of the module implementation source code."
    @spec source_subpath(t()) :: {:ok, Dagger.String.t()} | {:error, term()}
    def source_subpath(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "sourceSubpath")
      execute(selection, module_source.client)
    end
  )

  (
    @doc "Retrieve a named view defined for this module source.\n\n## Required Arguments\n\n* `name` - The name of the view to retrieve."
    @spec view(t(), Dagger.String.t()) :: Dagger.ModuleSourceView.t()
    def view(%__MODULE__{} = module_source, name) do
      selection = select(module_source.selection, "view")
      selection = arg(selection, "name", name)
      %Dagger.ModuleSourceView{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "The named views defined for this module source, which are sets of directory filters that can be applied to directory arguments provided to functions."
    @spec views(t()) :: {:ok, [Dagger.ModuleSourceView.t()]} | {:error, term()}
    def views(%__MODULE__{} = module_source) do
      selection = select(module_source.selection, "views")
      selection = select(selection, "id name patterns")

      with {:ok, data} <- execute(selection, module_source.client) do
        {:ok,
         data
         |> Enum.map(fn value ->
           elem_selection = Dagger.Core.QueryBuilder.Selection.query()
           elem_selection = select(elem_selection, "loadModuleSourceViewFromID")
           elem_selection = arg(elem_selection, "id", value["id"])
           %Dagger.ModuleSourceView{selection: elem_selection, client: module_source.client}
         end)}
      end
    end
  )

  (
    @doc "Update the module source with a new context directory. Only valid for local sources.\n\n## Required Arguments\n\n* `dir` - The directory to set as the context directory."
    @spec with_context_directory(t(), Dagger.Directory.t()) :: Dagger.ModuleSource.t()
    def with_context_directory(%__MODULE__{} = module_source, dir) do
      selection = select(module_source.selection, "withContextDirectory")

      (
        {:ok, id} = Dagger.Directory.id(dir)
        selection = arg(selection, "dir", id)
      )

      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Append the provided dependencies to the module source's dependency list.\n\n## Required Arguments\n\n* `dependencies` - The dependencies to append."
    @spec with_dependencies(t(), [Dagger.ModuleDependencyID.t()]) :: Dagger.ModuleSource.t()
    def with_dependencies(%__MODULE__{} = module_source, dependencies) do
      selection = select(module_source.selection, "withDependencies")
      selection = arg(selection, "dependencies", dependencies)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Update the module source with a new name.\n\n## Required Arguments\n\n* `name` - The name to set."
    @spec with_name(t(), Dagger.String.t()) :: Dagger.ModuleSource.t()
    def with_name(%__MODULE__{} = module_source, name) do
      selection = select(module_source.selection, "withName")
      selection = arg(selection, "name", name)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Update the module source with a new SDK.\n\n## Required Arguments\n\n* `sdk` - The SDK to set."
    @spec with_sdk(t(), Dagger.String.t()) :: Dagger.ModuleSource.t()
    def with_sdk(%__MODULE__{} = module_source, sdk) do
      selection = select(module_source.selection, "withSDK")
      selection = arg(selection, "sdk", sdk)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Update the module source with a new source subpath.\n\n## Required Arguments\n\n* `path` - The path to set as the source subpath."
    @spec with_source_subpath(t(), Dagger.String.t()) :: Dagger.ModuleSource.t()
    def with_source_subpath(%__MODULE__{} = module_source, path) do
      selection = select(module_source.selection, "withSourceSubpath")
      selection = arg(selection, "path", path)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )

  (
    @doc "Update the module source with a new named view.\n\n## Required Arguments\n\n* `name` - The name of the view to set.\n* `patterns` - The patterns to set as the view filters."
    @spec with_view(t(), Dagger.String.t(), [Dagger.String.t()]) :: Dagger.ModuleSource.t()
    def with_view(%__MODULE__{} = module_source, name, patterns) do
      selection = select(module_source.selection, "withView")
      selection = arg(selection, "name", name)
      selection = arg(selection, "patterns", patterns)
      %Dagger.ModuleSource{selection: selection, client: module_source.client}
    end
  )
end
