# This file generated by `dagger_codegen`. Please DO NOT EDIT.
defmodule Dagger.TypeDef do
  @moduledoc "A definition of a parameter or return type in a Module."

  use Dagger.Core.QueryBuilder

  @derive Dagger.ID

  defstruct [:selection, :client]

  @type t() :: %__MODULE__{}

  @doc "If kind is INPUT, the input-specific type definition. If kind is not INPUT, this will be null."
  @spec as_input(t()) :: Dagger.InputTypeDef.t() | nil
  def as_input(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("asInput")

    %Dagger.InputTypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "If kind is INTERFACE, the interface-specific type definition. If kind is not INTERFACE, this will be null."
  @spec as_interface(t()) :: Dagger.InterfaceTypeDef.t() | nil
  def as_interface(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("asInterface")

    %Dagger.InterfaceTypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "If kind is LIST, the list-specific type definition. If kind is not LIST, this will be null."
  @spec as_list(t()) :: Dagger.ListTypeDef.t() | nil
  def as_list(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("asList")

    %Dagger.ListTypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "If kind is OBJECT, the object-specific type definition. If kind is not OBJECT, this will be null."
  @spec as_object(t()) :: Dagger.ObjectTypeDef.t() | nil
  def as_object(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("asObject")

    %Dagger.ObjectTypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "A unique identifier for this TypeDef."
  @spec id(t()) :: {:ok, Dagger.TypeDefID.t()} | {:error, term()}
  def id(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("id")

    execute(selection, type_def.client)
  end

  @doc "The kind of type this is (e.g. primitive, list, object)."
  @spec kind(t()) :: Dagger.TypeDefKind.t()
  def kind(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("kind")

    execute(selection, type_def.client)
  end

  @doc "Whether this type can be set to null. Defaults to false."
  @spec optional(t()) :: {:ok, boolean()} | {:error, term()}
  def optional(%__MODULE__{} = type_def) do
    selection =
      type_def.selection |> select("optional")

    execute(selection, type_def.client)
  end

  @doc "Adds a function for constructing a new instance of an Object TypeDef, failing if the type is not an object."
  @spec with_constructor(t(), Dagger.Function.t()) :: Dagger.TypeDef.t()
  def with_constructor(%__MODULE__{} = type_def, function) do
    selection =
      type_def.selection
      |> select("withConstructor")
      |> put_arg("function", Dagger.ID.id!(function))

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Adds a static field for an Object TypeDef, failing if the type is not an object."
  @spec with_field(t(), String.t(), Dagger.TypeDef.t(), [{:description, String.t() | nil}]) ::
          Dagger.TypeDef.t()
  def with_field(%__MODULE__{} = type_def, name, type_def, optional_args \\ []) do
    selection =
      type_def.selection
      |> select("withField")
      |> put_arg("name", name)
      |> put_arg("typeDef", Dagger.ID.id!(type_def))
      |> maybe_put_arg("description", optional_args[:description])

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Adds a function for an Object or Interface TypeDef, failing if the type is not one of those kinds."
  @spec with_function(t(), Dagger.Function.t()) :: Dagger.TypeDef.t()
  def with_function(%__MODULE__{} = type_def, function) do
    selection =
      type_def.selection |> select("withFunction") |> put_arg("function", Dagger.ID.id!(function))

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Returns a TypeDef of kind Interface with the provided name."
  @spec with_interface(t(), String.t(), [{:description, String.t() | nil}]) :: Dagger.TypeDef.t()
  def with_interface(%__MODULE__{} = type_def, name, optional_args \\ []) do
    selection =
      type_def.selection
      |> select("withInterface")
      |> put_arg("name", name)
      |> maybe_put_arg("description", optional_args[:description])

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Sets the kind of the type."
  @spec with_kind(t(), Dagger.TypeDefKind.t()) :: Dagger.TypeDef.t()
  def with_kind(%__MODULE__{} = type_def, kind) do
    selection =
      type_def.selection |> select("withKind") |> put_arg("kind", kind)

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Returns a TypeDef of kind List with the provided type for its elements."
  @spec with_list_of(t(), Dagger.TypeDef.t()) :: Dagger.TypeDef.t()
  def with_list_of(%__MODULE__{} = type_def, element_type) do
    selection =
      type_def.selection
      |> select("withListOf")
      |> put_arg("elementType", Dagger.ID.id!(element_type))

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc """
  Returns a TypeDef of kind Object with the provided name.

  Note that an object's fields and functions may be omitted if the intent is only to refer to an object. This is how functions are able to return their own object, or any other circular reference.
  """
  @spec with_object(t(), String.t(), [{:description, String.t() | nil}]) :: Dagger.TypeDef.t()
  def with_object(%__MODULE__{} = type_def, name, optional_args \\ []) do
    selection =
      type_def.selection
      |> select("withObject")
      |> put_arg("name", name)
      |> maybe_put_arg("description", optional_args[:description])

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end

  @doc "Sets whether this type can be set to null."
  @spec with_optional(t(), boolean()) :: Dagger.TypeDef.t()
  def with_optional(%__MODULE__{} = type_def, optional) do
    selection =
      type_def.selection |> select("withOptional") |> put_arg("optional", optional)

    %Dagger.TypeDef{
      selection: selection,
      client: type_def.client
    }
  end
end
