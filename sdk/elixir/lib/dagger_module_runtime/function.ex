defmodule Dagger.ModuleRuntime.Function do
  alias Dagger.ModuleRuntime.Helper

  @doc """
  Define a Dagger function.
  """
  def define(dag, {name, fun_def}) do
    args = fun_def[:args] || []
    return = Keyword.fetch!(fun_def, :return)

    # TODO: function doc by retrieving from `@doc`.
    dag
    |> Dagger.Client.function(Helper.camelize(name), define_type(dag, return))
    |> with_args(args, dag)
  end

  defp with_args(fun_def, args, dag) do
    args
    |> Enum.reduce(fun_def, fn {name, info}, fun_def ->
      type = Keyword.fetch!(info, :type)

      type_def =
        define_type(dag, type)
        |> then(fn type_def ->
          if info[:optional] do
            Dagger.TypeDef.with_optional(type_def, true)
          else
            type_def
          end
        end)

      fun_def
      |> Dagger.Function.with_arg(name, type_def)
    end)
  end

  defp define_type(dag, type) do
    type_def =
      dag
      |> Dagger.Client.type_def()

    case type do
      :string ->
        type_def
        |> Dagger.TypeDef.with_kind(Dagger.TypeDefKind.string_kind())

      module ->
        case Module.split(module) do
          # A module that generated by codegen.
          ["Dagger", name] ->
            type_def
            |> Dagger.TypeDef.with_object(name)

          [name] ->
            type_def
            |> Dagger.TypeDef.with_object(name)
        end
    end
  end
end
