package main

import (
	"context"
	"fmt"
	"strings"

	"github.com/dagger/dagger/engine/distconsts"
	"github.com/dagger/dagger/sdk/go/.dagger/internal/dagger"
	"go.opentelemetry.io/otel/codes"
	"golang.org/x/sync/errgroup"
)

func New(
	// +optional
	// +defaultPath="/"
	// +ignore=["*", "!sdk/go"]
	source *dagger.Directory,
) *GoSdk {
	return &GoSdk{
		Source: source,
	}
}

type GoSdk struct {
	Source *dagger.Directory // +private
}

// Lint the Go SDK
func (t GoSdk) Lint(ctx context.Context) (rerr error) {
	eg, ctx := errgroup.WithContext(ctx)
	eg.Go(func() (rerr error) {
		ctx, span := Tracer().Start(ctx, "lint the go source")
		defer func() {
			if rerr != nil {
				span.SetStatus(codes.Error, rerr.Error())
			}
			span.End()
		}()
		return dag.
			Go(t.Source).
			Lint(ctx, dagger.GoLintOpts{Packages: []string{"sdk/go"}})
	})
	eg.Go(func() (rerr error) {
		ctx, span := Tracer().Start(ctx, "check that the generated client library is up-to-date")
		defer func() {
			if rerr != nil {
				span.SetStatus(codes.Error, rerr.Error())
			}
			span.End()
		}()
		before := t.Source
		after, err := t.Generate(ctx)
		if err != nil {
			return err
		}
		return dag.Dirdiff().AssertEqual(ctx, before, after, []string{"sdk/go"})
	})
	return eg.Wait()
}

// Test the Go SDK
func (t GoSdk) Test(ctx context.Context) (rerr error) {
	_, err := t.Env().
		WithExec([]string{"go", "test", "-v", "-skip=TestProvision", "./..."}).
		Sync(ctx)
	return err
}

// Build an environment for developing the Go SDK
func (t GoSdk) Env() *dagger.Container {
	return dag.
		Go(t.Source).
		Env().
		WithWorkdir("sdk/go").
		With(dag.Engine().Bind)
}

// Regenerate the Go SDK API
func (t GoSdk) Generate(ctx context.Context) (*dagger.Directory, error) {
	generated := t.Env().
		WithExec([]string{"go", "generate", "-v", "./..."}).
		WithExec([]string{"go", "mod", "tidy"}).
		Directory(".")
	return dag.Directory().WithDirectory("sdk/go", generated), nil
}

// Test the publishing process
func (t GoSdk) TestPublish(ctx context.Context, tag string) error {
	return t.Publish(
		ctx,
		tag,
		true,
		"https://github.com/dagger/dagger-go-sdk.git",
		"https://github.com/dagger/dagger.git",
		"dagger-ci",
		"hello@dagger.io",
		nil,
	)
}

// Publish the Go SDK
func (t GoSdk) Publish(
	ctx context.Context,
	tag string,

	// +optional
	dryRun bool,

	// +optional
	// +default="https://github.com/dagger/dagger-go-sdk.git"
	gitRepo string,
	// +optional
	// +default="https://github.com/dagger/dagger.git"
	gitRepoSource string,
	// +optional
	// +default="dagger-ci"
	gitUserName string,
	// +optional
	// +default="hello@dagger.io"
	gitUserEmail string,

	// +optional
	githubToken *dagger.Secret,
) error {
	version, isVersioned := strings.CutPrefix(tag, "sdk/go/")

	if err := dag.SDK().GitPublish(ctx, dagger.SDKGitPublishOpts{
		Source:       gitRepoSource,
		SourceTag:    tag,
		SourcePath:   "sdk/go/",
		SourceFilter: "if [ -f go.mod ]; then go mod edit -dropreplace github.com/dagger/dagger; fi",
		SourceEnv:    dag.Go(t.Source).Env(),
		Dest:         gitRepo,
		DestTag:      version,
		Username:     gitUserName,
		Email:        gitUserEmail,
		GithubToken:  githubToken,
		DryRun:       dryRun,
	}); err != nil {
		return err
	}

	if isVersioned {
		if err := dag.SDK().GithubRelease(ctx, dagger.SDKGithubReleaseOpts{
			Tag:         tag,
			Notes:       dag.SDK().ChangeNotes(t.Source, version),
			GitRepo:     gitRepoSource,
			GithubToken: githubToken,
			DryRun:      dryRun,
		}); err != nil {
			return err
		}
	}

	return nil
}

// Bump the Go SDK's Engine dependency
func (t GoSdk) Bump(ctx context.Context, version string) (*dagger.Directory, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")

	versionFile := fmt.Sprintf(`// Code generated by dagger. DO NOT EDIT.

package engineconn

const CLIVersion = %q
`, version)

	// NOTE: if you change this path, be sure to update .github/workflows/publish.yml so that
	// provision tests run whenever this file changes.
	dir := dag.Directory().WithNewFile("sdk/go/internal/engineconn/version.gen.go", versionFile)
	return dir, nil
}

// Package the SDK to be embeded in the engine container as a builtin.
// The builtin container is converted to an OCI archive and copied into
// the engine container.
func (t GoSdk) Builtin(
	ctx context.Context,
	// +optional
	platform dagger.Platform,
) *dagger.Container {
	return dag.
		Container(dagger.ContainerOpts{Platform: platform}).
		From(distconsts.GolangImage).
		WithExec([]string{"apk", "add", "git"}).
		WithEnvVariable("GOTOOLCHAIN", "auto").
		WithFile("/usr/local/bin/codegen", dag.Codegen().Binary(dagger.CodegenBinaryOpts{
			Platform: platform,
		}))
}
