// Code generated by dagger. DO NOT EDIT.

package dagger

import (
	"context"

	"dagger.io/dagger/querybuilder"
	"github.com/Khan/genqlient/graphql"
)

// A global cache volume identifier.
type CacheID string

// A unique container identifier. Null designates an empty container (scratch).
type ContainerID string

// A content-addressed directory identifier.
type DirectoryID string

// A unique environment check identifier.
type EnvironmentCheckID string

// A unique environment command identifier.
type EnvironmentCommandID string

// A unique environment function identifier.
type EnvironmentFunctionID string

// A unique environment identifier.
type EnvironmentID string

// A unique environment shell identifier.
type EnvironmentShellID string

// A file identifier.
type FileID string

// The platform config OS and architecture in a Container.
//
// The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
type Platform string

// A unique identifier for a secret.
type SecretID string

// A content-addressed socket identifier.
type SocketID string

// Key value object that represents a build argument.
type BuildArg struct {
	// The build argument name.
	Name string `json:"name"`

	// The build argument value.
	Value string `json:"value"`
}

// Key value object that represents a Pipeline label.
type PipelineLabel struct {
	// Label name.
	Name string `json:"name"`

	// Label value.
	Value string `json:"value"`
}

type Apko struct {
	Q *querybuilder.Selection
	C graphql.Client
}

func (r *Apko) Alpine(packages []string) *Container {
	q := r.Q.Select("alpine")
	q = q.Arg("packages", packages)

	return &Container{
		Q: q,
		C: r.C,
	}
}

func (r *Apko) Wolfi(packages []string) *Container {
	q := r.Q.Select("wolfi")
	q = q.Arg("packages", packages)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// A directory whose contents persist across runs.
type CacheVolume struct {
	Q *querybuilder.Selection
	C graphql.Client

	id *CacheID
}

func (r *CacheVolume) ID(ctx context.Context) (CacheID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response CacheID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *CacheVolume) XXX_GraphQLType() string {
	return "CacheVolume"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *CacheVolume) XXX_GraphQLIDType() string {
	return "CacheID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *CacheVolume) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// An OCI-compatible container, also known as a docker container.
type Container struct {
	Q *querybuilder.Selection
	C graphql.Client

	endpoint      *string
	envVariable   *string
	export        *bool
	hostname      *string
	id            *ContainerID
	imageRef      *string
	label         *string
	platform      *Platform
	publish       *string
	shellEndpoint *string
	stderr        *string
	stdout        *string
	sync          *ContainerID
	user          *string
	workdir       *string
}
type WithContainerFunc func(r *Container) *Container

// With calls the provided function with current Container.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Container) With(f WithContainerFunc) *Container {
	return f(r)
}

// ContainerBuildOpts contains options for Container.Build
type ContainerBuildOpts struct {
	// Path to the Dockerfile to use.
	//
	// Default: './Dockerfile'.
	Dockerfile string
	// Additional build arguments.
	BuildArgs []BuildArg
	// Target build stage to build.
	Target string
	// Secrets to pass to the build.
	//
	// They will be mounted at /run/secrets/[secret-name].
	Secrets []*Secret
}

// Initializes this container from a Dockerfile build.
func (r *Container) Build(context *Directory, opts ...ContainerBuildOpts) *Container {
	q := r.Q.Select("build")
	for i := len(opts) - 1; i >= 0; i-- {
		// `dockerfile` optional argument
		if !querybuilder.IsZeroValue(opts[i].Dockerfile) {
			q = q.Arg("dockerfile", opts[i].Dockerfile)
		}
		// `buildArgs` optional argument
		if !querybuilder.IsZeroValue(opts[i].BuildArgs) {
			q = q.Arg("buildArgs", opts[i].BuildArgs)
		}
		// `target` optional argument
		if !querybuilder.IsZeroValue(opts[i].Target) {
			q = q.Arg("target", opts[i].Target)
		}
		// `secrets` optional argument
		if !querybuilder.IsZeroValue(opts[i].Secrets) {
			q = q.Arg("secrets", opts[i].Secrets)
		}
	}
	q = q.Arg("context", context)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves default arguments for future commands.
func (r *Container) DefaultArgs(ctx context.Context) ([]string, error) {
	q := r.Q.Select("defaultArgs")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves a directory at the given path.
//
// Mounts are included.
func (r *Container) Directory(path string) *Directory {
	q := r.Q.Select("directory")
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// ContainerEndpointOpts contains options for Container.Endpoint
type ContainerEndpointOpts struct {
	// The exposed port number for the endpoint
	Port int
	// Return a URL with the given scheme, eg. http for http://
	Scheme string
}

// Retrieves an endpoint that clients can use to reach this container.
//
// If no port is specified, the first exposed port is used. If none exist an error is returned.
//
// If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) Endpoint(ctx context.Context, opts ...ContainerEndpointOpts) (string, error) {
	if r.endpoint != nil {
		return *r.endpoint, nil
	}
	q := r.Q.Select("endpoint")
	for i := len(opts) - 1; i >= 0; i-- {
		// `port` optional argument
		if !querybuilder.IsZeroValue(opts[i].Port) {
			q = q.Arg("port", opts[i].Port)
		}
		// `scheme` optional argument
		if !querybuilder.IsZeroValue(opts[i].Scheme) {
			q = q.Arg("scheme", opts[i].Scheme)
		}
	}

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves entrypoint to be prepended to the arguments of all commands.
func (r *Container) Entrypoint(ctx context.Context) ([]string, error) {
	q := r.Q.Select("entrypoint")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves the value of the specified environment variable.
func (r *Container) EnvVariable(ctx context.Context, name string) (string, error) {
	if r.envVariable != nil {
		return *r.envVariable, nil
	}
	q := r.Q.Select("envVariable")
	q = q.Arg("name", name)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves the list of environment variables passed to commands.
func (r *Container) EnvVariables(ctx context.Context) ([]EnvVariable, error) {
	q := r.Q.Select("envVariables")

	q = q.Select("name value")

	type envVariables struct {
		Name  string
		Value string
	}

	convert := func(fields []envVariables) []EnvVariable {
		out := []EnvVariable{}

		for i := range fields {
			out = append(out, EnvVariable{name: &fields[i].Name, value: &fields[i].Value})
		}

		return out
	}
	var response []envVariables

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// ContainerExportOpts contains options for Container.Export
type ContainerExportOpts struct {
	// Identifiers for other platform specific containers.
	// Used for multi-platform image.
	PlatformVariants []*Container
	// Force each layer of the exported image to use the specified compression algorithm.
	// If this is unset, then if a layer already has a compressed blob in the engine's
	// cache, that will be used (this can result in a mix of compression algorithms for
	// different layers). If this is unset and a layer has no compressed blob in the
	// engine's cache, then it will be compressed using Gzip.
	ForcedCompression ImageLayerCompression
	// Use the specified media types for the exported image's layers. Defaults to OCI, which
	// is largely compatible with most recent container runtimes, but Docker may be needed
	// for older runtimes without OCI support.
	MediaTypes ImageMediaTypes
}

// Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.
//
// Return true on success.
// It can also publishes platform variants.
func (r *Container) Export(ctx context.Context, path string, opts ...ContainerExportOpts) (bool, error) {
	if r.export != nil {
		return *r.export, nil
	}
	q := r.Q.Select("export")
	for i := len(opts) - 1; i >= 0; i-- {
		// `platformVariants` optional argument
		if !querybuilder.IsZeroValue(opts[i].PlatformVariants) {
			q = q.Arg("platformVariants", opts[i].PlatformVariants)
		}
		// `forcedCompression` optional argument
		if !querybuilder.IsZeroValue(opts[i].ForcedCompression) {
			q = q.Arg("forcedCompression", opts[i].ForcedCompression)
		}
		// `mediaTypes` optional argument
		if !querybuilder.IsZeroValue(opts[i].MediaTypes) {
			q = q.Arg("mediaTypes", opts[i].MediaTypes)
		}
	}
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves the list of exposed ports.
//
// This includes ports already exposed by the image, even if not
// explicitly added with dagger.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) ExposedPorts(ctx context.Context) ([]Port, error) {
	q := r.Q.Select("exposedPorts")

	q = q.Select("description port protocol")

	type exposedPorts struct {
		Description string
		Port        int
		Protocol    NetworkProtocol
	}

	convert := func(fields []exposedPorts) []Port {
		out := []Port{}

		for i := range fields {
			out = append(out, Port{description: &fields[i].Description, port: &fields[i].Port, protocol: &fields[i].Protocol})
		}

		return out
	}
	var response []exposedPorts

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// Retrieves a file at the given path.
//
// Mounts are included.
func (r *Container) File(path string) *File {
	q := r.Q.Select("file")
	q = q.Arg("path", path)

	return &File{
		Q: q,
		C: r.C,
	}
}

// Initializes this container from a pulled base image.
func (r *Container) From(address string) *Container {
	q := r.Q.Select("from")
	q = q.Arg("address", address)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves a hostname which can be used by clients to reach this container.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) Hostname(ctx context.Context) (string, error) {
	if r.hostname != nil {
		return *r.hostname, nil
	}
	q := r.Q.Select("hostname")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A unique identifier for this container.
func (r *Container) ID(ctx context.Context) (ContainerID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response ContainerID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Container) XXX_GraphQLType() string {
	return "Container"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Container) XXX_GraphQLIDType() string {
	return "ContainerID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Container) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// The unique image reference which can only be retrieved immediately after the 'Container.From' call.
func (r *Container) ImageRef(ctx context.Context) (string, error) {
	if r.imageRef != nil {
		return *r.imageRef, nil
	}
	q := r.Q.Select("imageRef")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// ContainerImportOpts contains options for Container.Import
type ContainerImportOpts struct {
	// Identifies the tag to import from the archive, if the archive bundles
	// multiple tags.
	Tag string
}

// Reads the container from an OCI tarball.
//
// NOTE: this involves unpacking the tarball to an OCI store on the host at
// $XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.
func (r *Container) Import(source *File, opts ...ContainerImportOpts) *Container {
	q := r.Q.Select("import")
	for i := len(opts) - 1; i >= 0; i-- {
		// `tag` optional argument
		if !querybuilder.IsZeroValue(opts[i].Tag) {
			q = q.Arg("tag", opts[i].Tag)
		}
	}
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves the value of the specified label.
func (r *Container) Label(ctx context.Context, name string) (string, error) {
	if r.label != nil {
		return *r.label, nil
	}
	q := r.Q.Select("label")
	q = q.Arg("name", name)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves the list of labels passed to container.
func (r *Container) Labels(ctx context.Context) ([]Label, error) {
	q := r.Q.Select("labels")

	q = q.Select("name value")

	type labels struct {
		Name  string
		Value string
	}

	convert := func(fields []labels) []Label {
		out := []Label{}

		for i := range fields {
			out = append(out, Label{name: &fields[i].Name, value: &fields[i].Value})
		}

		return out
	}
	var response []labels

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// Retrieves the list of paths where a directory is mounted.
func (r *Container) Mounts(ctx context.Context) ([]string, error) {
	q := r.Q.Select("mounts")

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// ContainerPipelineOpts contains options for Container.Pipeline
type ContainerPipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline
func (r *Container) Pipeline(name string, opts ...ContainerPipelineOpts) *Container {
	q := r.Q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// The platform this container executes and publishes as.
func (r *Container) Platform(ctx context.Context) (Platform, error) {
	if r.platform != nil {
		return *r.platform, nil
	}
	q := r.Q.Select("platform")

	var response Platform

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// ContainerPublishOpts contains options for Container.Publish
type ContainerPublishOpts struct {
	// Identifiers for other platform specific containers.
	// Used for multi-platform image.
	PlatformVariants []*Container
	// Force each layer of the published image to use the specified compression algorithm.
	// If this is unset, then if a layer already has a compressed blob in the engine's
	// cache, that will be used (this can result in a mix of compression algorithms for
	// different layers). If this is unset and a layer has no compressed blob in the
	// engine's cache, then it will be compressed using Gzip.
	ForcedCompression ImageLayerCompression
	// Use the specified media types for the published image's layers. Defaults to OCI, which
	// is largely compatible with most recent registries, but Docker may be needed for older
	// registries without OCI support.
	MediaTypes ImageMediaTypes
}

// Publishes this container as a new image to the specified address.
//
// Publish returns a fully qualified ref.
// It can also publish platform variants.
func (r *Container) Publish(ctx context.Context, address string, opts ...ContainerPublishOpts) (string, error) {
	if r.publish != nil {
		return *r.publish, nil
	}
	q := r.Q.Select("publish")
	for i := len(opts) - 1; i >= 0; i-- {
		// `platformVariants` optional argument
		if !querybuilder.IsZeroValue(opts[i].PlatformVariants) {
			q = q.Arg("platformVariants", opts[i].PlatformVariants)
		}
		// `forcedCompression` optional argument
		if !querybuilder.IsZeroValue(opts[i].ForcedCompression) {
			q = q.Arg("forcedCompression", opts[i].ForcedCompression)
		}
		// `mediaTypes` optional argument
		if !querybuilder.IsZeroValue(opts[i].MediaTypes) {
			q = q.Arg("mediaTypes", opts[i].MediaTypes)
		}
	}
	q = q.Arg("address", address)

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves this container's root filesystem. Mounts are not included.
func (r *Container) Rootfs() *Directory {
	q := r.Q.Select("rootfs")

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Container) ShellEndpoint(ctx context.Context) (string, error) {
	if r.shellEndpoint != nil {
		return *r.shellEndpoint, nil
	}
	q := r.Q.Select("shellEndpoint")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The error stream of the last executed command.
//
// Will execute default command if none is set, or error if there's no default.
func (r *Container) Stderr(ctx context.Context) (string, error) {
	if r.stderr != nil {
		return *r.stderr, nil
	}
	q := r.Q.Select("stderr")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The output stream of the last executed command.
//
// Will execute default command if none is set, or error if there's no default.
func (r *Container) Stdout(ctx context.Context) (string, error) {
	if r.stdout != nil {
		return *r.stdout, nil
	}
	q := r.Q.Select("stdout")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Forces evaluation of the pipeline in the engine.
//
// It doesn't run the default command if no exec has been set.
func (r *Container) Sync(ctx context.Context) (*Container, error) {
	q := r.Q.Select("sync")

	return r, q.Execute(ctx, r.C)
}

// Retrieves the user to be set for all commands.
func (r *Container) User(ctx context.Context) (string, error) {
	if r.user != nil {
		return *r.user, nil
	}
	q := r.Q.Select("user")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// ContainerWithDefaultArgsOpts contains options for Container.WithDefaultArgs
type ContainerWithDefaultArgsOpts struct {
	// Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
	Args []string
}

// Configures default arguments for future commands.
func (r *Container) WithDefaultArgs(opts ...ContainerWithDefaultArgsOpts) *Container {
	q := r.Q.Select("withDefaultArgs")
	for i := len(opts) - 1; i >= 0; i-- {
		// `args` optional argument
		if !querybuilder.IsZeroValue(opts[i].Args) {
			q = q.Arg("args", opts[i].Args)
		}
	}

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithDirectoryOpts contains options for Container.WithDirectory
type ContainerWithDirectoryOpts struct {
	// Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
	Exclude []string
	// Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
	Include []string
	// A user:group to set for the directory and its contents.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a directory written at the given path.
func (r *Container) WithDirectory(path string, directory *Directory, opts ...ContainerWithDirectoryOpts) *Container {
	q := r.Q.Select("withDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("directory", directory)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container but with a different command entrypoint.
func (r *Container) WithEntrypoint(args []string) *Container {
	q := r.Q.Select("withEntrypoint")
	q = q.Arg("args", args)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithEnvVariableOpts contains options for Container.WithEnvVariable
type ContainerWithEnvVariableOpts struct {
	// Replace ${VAR} or $VAR in the value according to the current environment
	// variables defined in the container (e.g., "/opt/bin:$PATH").
	Expand bool
}

// Retrieves this container plus the given environment variable.
func (r *Container) WithEnvVariable(name string, value string, opts ...ContainerWithEnvVariableOpts) *Container {
	q := r.Q.Select("withEnvVariable")
	for i := len(opts) - 1; i >= 0; i-- {
		// `expand` optional argument
		if !querybuilder.IsZeroValue(opts[i].Expand) {
			q = q.Arg("expand", opts[i].Expand)
		}
	}
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithExecOpts contains options for Container.WithExec
type ContainerWithExecOpts struct {
	// If the container has an entrypoint, ignore it for args rather than using it to wrap them.
	SkipEntrypoint bool
	// Content to write to the command's standard input before closing (e.g., "Hello world").
	Stdin string
	// Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
	RedirectStdout string
	// Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
	RedirectStderr string
	// Provides dagger access to the executed command.
	//
	// Do not use this option unless you trust the command being executed.
	// The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
	ExperimentalPrivilegedNesting bool
	// Execute the command with all root capabilities. This is similar to running a command
	// with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
	// does not provide any security guarantees when using this option. It should only be used
	// when absolutely necessary and only with trusted commands.
	InsecureRootCapabilities bool
}

// Retrieves this container after executing the specified command inside it.
func (r *Container) WithExec(args []string, opts ...ContainerWithExecOpts) *Container {
	q := r.Q.Select("withExec")
	for i := len(opts) - 1; i >= 0; i-- {
		// `skipEntrypoint` optional argument
		if !querybuilder.IsZeroValue(opts[i].SkipEntrypoint) {
			q = q.Arg("skipEntrypoint", opts[i].SkipEntrypoint)
		}
		// `stdin` optional argument
		if !querybuilder.IsZeroValue(opts[i].Stdin) {
			q = q.Arg("stdin", opts[i].Stdin)
		}
		// `redirectStdout` optional argument
		if !querybuilder.IsZeroValue(opts[i].RedirectStdout) {
			q = q.Arg("redirectStdout", opts[i].RedirectStdout)
		}
		// `redirectStderr` optional argument
		if !querybuilder.IsZeroValue(opts[i].RedirectStderr) {
			q = q.Arg("redirectStderr", opts[i].RedirectStderr)
		}
		// `experimentalPrivilegedNesting` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalPrivilegedNesting) {
			q = q.Arg("experimentalPrivilegedNesting", opts[i].ExperimentalPrivilegedNesting)
		}
		// `insecureRootCapabilities` optional argument
		if !querybuilder.IsZeroValue(opts[i].InsecureRootCapabilities) {
			q = q.Arg("insecureRootCapabilities", opts[i].InsecureRootCapabilities)
		}
	}
	q = q.Arg("args", args)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithExposedPortOpts contains options for Container.WithExposedPort
type ContainerWithExposedPortOpts struct {
	// Transport layer network protocol
	Protocol NetworkProtocol
	// Optional port description
	Description string
}

// Expose a network port.
//
// Exposed ports serve two purposes:
//   - For health checks and introspection, when running services
//   - For setting the EXPOSE OCI field when publishing the container
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithExposedPort(port int, opts ...ContainerWithExposedPortOpts) *Container {
	q := r.Q.Select("withExposedPort")
	for i := len(opts) - 1; i >= 0; i-- {
		// `protocol` optional argument
		if !querybuilder.IsZeroValue(opts[i].Protocol) {
			q = q.Arg("protocol", opts[i].Protocol)
		}
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("port", port)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithFileOpts contains options for Container.WithFile
type ContainerWithFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
	// A user:group to set for the file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus the contents of the given file copied to the given path.
func (r *Container) WithFile(path string, source *File, opts ...ContainerWithFileOpts) *Container {
	q := r.Q.Select("withFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Indicate that subsequent operations should be featured more prominently in
// the UI.
func (r *Container) WithFocus() *Container {
	q := r.Q.Select("withFocus")

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container plus the given label.
func (r *Container) WithLabel(name string, value string) *Container {
	q := r.Q.Select("withLabel")
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithMountedCacheOpts contains options for Container.WithMountedCache
type ContainerWithMountedCacheOpts struct {
	// Identifier of the directory to use as the cache volume's root.
	Source *Directory
	// Sharing mode of the cache volume.
	Sharing CacheSharingMode
	// A user:group to set for the mounted cache directory.
	//
	// Note that this changes the ownership of the specified mount along with the
	// initial filesystem provided by source (if any). It does not have any effect
	// if/when the cache has already been created.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a cache volume mounted at the given path.
func (r *Container) WithMountedCache(path string, cache *CacheVolume, opts ...ContainerWithMountedCacheOpts) *Container {
	q := r.Q.Select("withMountedCache")
	for i := len(opts) - 1; i >= 0; i-- {
		// `source` optional argument
		if !querybuilder.IsZeroValue(opts[i].Source) {
			q = q.Arg("source", opts[i].Source)
		}
		// `sharing` optional argument
		if !querybuilder.IsZeroValue(opts[i].Sharing) {
			q = q.Arg("sharing", opts[i].Sharing)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("cache", cache)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithMountedDirectoryOpts contains options for Container.WithMountedDirectory
type ContainerWithMountedDirectoryOpts struct {
	// A user:group to set for the mounted directory and its contents.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a directory mounted at the given path.
func (r *Container) WithMountedDirectory(path string, source *Directory, opts ...ContainerWithMountedDirectoryOpts) *Container {
	q := r.Q.Select("withMountedDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithMountedFileOpts contains options for Container.WithMountedFile
type ContainerWithMountedFileOpts struct {
	// A user or user:group to set for the mounted file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a file mounted at the given path.
func (r *Container) WithMountedFile(path string, source *File, opts ...ContainerWithMountedFileOpts) *Container {
	q := r.Q.Select("withMountedFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithMountedSecretOpts contains options for Container.WithMountedSecret
type ContainerWithMountedSecretOpts struct {
	// A user:group to set for the mounted secret.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a secret mounted into a file at the given path.
func (r *Container) WithMountedSecret(path string, source *Secret, opts ...ContainerWithMountedSecretOpts) *Container {
	q := r.Q.Select("withMountedSecret")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container plus a temporary directory mounted at the given path.
func (r *Container) WithMountedTemp(path string) *Container {
	q := r.Q.Select("withMountedTemp")
	q = q.Arg("path", path)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithNewFileOpts contains options for Container.WithNewFile
type ContainerWithNewFileOpts struct {
	// Content of the file to write (e.g., "Hello world!").
	Contents string
	// Permission given to the written file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
	// A user:group to set for the file.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a new file written at the given path.
func (r *Container) WithNewFile(path string, opts ...ContainerWithNewFileOpts) *Container {
	q := r.Q.Select("withNewFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `contents` optional argument
		if !querybuilder.IsZeroValue(opts[i].Contents) {
			q = q.Arg("contents", opts[i].Contents)
		}
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container with a registry authentication for a given address.
func (r *Container) WithRegistryAuth(address string, username string, secret *Secret) *Container {
	q := r.Q.Select("withRegistryAuth")
	q = q.Arg("address", address)
	q = q.Arg("username", username)
	q = q.Arg("secret", secret)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Initializes this container from this DirectoryID.
func (r *Container) WithRootfs(directory *Directory) *Container {
	q := r.Q.Select("withRootfs")
	q = q.Arg("directory", directory)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container plus an env variable containing the given secret.
func (r *Container) WithSecretVariable(name string, secret *Secret) *Container {
	q := r.Q.Select("withSecretVariable")
	q = q.Arg("name", name)
	q = q.Arg("secret", secret)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Establish a runtime dependency on a service.
//
// The service will be started automatically when needed and detached when it is
// no longer needed, executing the default command if none is set.
//
// The service will be reachable from the container via the provided hostname alias.
//
// The service dependency will also convey to any files or directories produced by the container.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithServiceBinding(alias string, service *Container) *Container {
	q := r.Q.Select("withServiceBinding")
	q = q.Arg("alias", alias)
	q = q.Arg("service", service)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithUnixSocketOpts contains options for Container.WithUnixSocket
type ContainerWithUnixSocketOpts struct {
	// A user:group to set for the mounted socket.
	//
	// The user and group can either be an ID (1000:1000) or a name (foo:bar).
	//
	// If the group is omitted, it defaults to the same as the user.
	Owner string
}

// Retrieves this container plus a socket forwarded to the given Unix socket path.
func (r *Container) WithUnixSocket(path string, source *Socket, opts ...ContainerWithUnixSocketOpts) *Container {
	q := r.Q.Select("withUnixSocket")
	for i := len(opts) - 1; i >= 0; i-- {
		// `owner` optional argument
		if !querybuilder.IsZeroValue(opts[i].Owner) {
			q = q.Arg("owner", opts[i].Owner)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container with a different command user.
func (r *Container) WithUser(name string) *Container {
	q := r.Q.Select("withUser")
	q = q.Arg("name", name)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container with a different working directory.
func (r *Container) WithWorkdir(path string) *Container {
	q := r.Q.Select("withWorkdir")
	q = q.Arg("path", path)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container minus the given environment variable.
func (r *Container) WithoutEnvVariable(name string) *Container {
	q := r.Q.Select("withoutEnvVariable")
	q = q.Arg("name", name)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// ContainerWithoutExposedPortOpts contains options for Container.WithoutExposedPort
type ContainerWithoutExposedPortOpts struct {
	// Port protocol to unexpose
	Protocol NetworkProtocol
}

// Unexpose a previously exposed port.
//
// Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
func (r *Container) WithoutExposedPort(port int, opts ...ContainerWithoutExposedPortOpts) *Container {
	q := r.Q.Select("withoutExposedPort")
	for i := len(opts) - 1; i >= 0; i-- {
		// `protocol` optional argument
		if !querybuilder.IsZeroValue(opts[i].Protocol) {
			q = q.Arg("protocol", opts[i].Protocol)
		}
	}
	q = q.Arg("port", port)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Indicate that subsequent operations should not be featured more prominently
// in the UI.
//
// This is the initial state of all containers.
func (r *Container) WithoutFocus() *Container {
	q := r.Q.Select("withoutFocus")

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container minus the given environment label.
func (r *Container) WithoutLabel(name string) *Container {
	q := r.Q.Select("withoutLabel")
	q = q.Arg("name", name)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container after unmounting everything at the given path.
func (r *Container) WithoutMount(path string) *Container {
	q := r.Q.Select("withoutMount")
	q = q.Arg("path", path)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container without the registry authentication of a given address.
func (r *Container) WithoutRegistryAuth(address string) *Container {
	q := r.Q.Select("withoutRegistryAuth")
	q = q.Arg("address", address)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves this container with a previously added Unix socket removed.
func (r *Container) WithoutUnixSocket(path string) *Container {
	q := r.Q.Select("withoutUnixSocket")
	q = q.Arg("path", path)

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Retrieves the working directory for all commands.
func (r *Container) Workdir(ctx context.Context) (string, error) {
	if r.workdir != nil {
		return *r.workdir, nil
	}
	q := r.Q.Select("workdir")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

type Dagger struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// Build the Dagger CLI
func (r *Dagger) Cli() *Directory {
	q := r.Q.Select("cli")

	return &Directory{
		Q: q,
		C: r.C,
	}
}

func (r *Dagger) DevShell() *Container {
	q := r.Q.Select("devShell")

	return &Container{
		Q: q,
		C: r.C,
	}
}

// Lint the Dagger engine code
func (r *Dagger) EngineLint() *EnvironmentCheck {
	q := r.Q.Select("engineLint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// Lint everything (engine, sdks, etc)
func (r *Dagger) Lint() *EnvironmentCheck {
	q := r.Q.Select("lint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// Lint the Nodejs SDK
func (r *Dagger) NodejsLint() *EnvironmentCheck {
	q := r.Q.Select("nodejsLint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// Lint the Dagger Python SDK
func (r *Dagger) PythonLint() *EnvironmentCheck {
	q := r.Q.Select("pythonLint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

type Daggergo struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// Lint the Dagger Go SDK
// TODO: once namespacing is in place, can just name this "Lint"
func (r *Daggergo) GoLint() *EnvironmentCheck {
	q := r.Q.Select("goLint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

type Daggerpython struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// Lint the Python SDK
func (r *Daggerpython) PyLint() *EnvironmentCheck {
	q := r.Q.Select("py_lint")

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// A directory.
type Directory struct {
	Q *querybuilder.Selection
	C graphql.Client

	export *bool
	id     *DirectoryID
	sync   *DirectoryID
}
type WithDirectoryFunc func(r *Directory) *Directory

// With calls the provided function with current Directory.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Directory) With(f WithDirectoryFunc) *Directory {
	return f(r)
}

// Gets the difference between this directory and an another directory.
func (r *Directory) Diff(other *Directory) *Directory {
	q := r.Q.Select("diff")
	q = q.Arg("other", other)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Retrieves a directory at the given path.
func (r *Directory) Directory(path string) *Directory {
	q := r.Q.Select("directory")
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// DirectoryDockerBuildOpts contains options for Directory.DockerBuild
type DirectoryDockerBuildOpts struct {
	// Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
	//
	// Defaults: './Dockerfile'.
	Dockerfile string
	// The platform to build.
	Platform Platform
	// Build arguments to use in the build.
	BuildArgs []BuildArg
	// Target build stage to build.
	Target string
	// Secrets to pass to the build.
	//
	// They will be mounted at /run/secrets/[secret-name].
	Secrets []*Secret
}

// Builds a new Docker container from this directory.
func (r *Directory) DockerBuild(opts ...DirectoryDockerBuildOpts) *Container {
	q := r.Q.Select("dockerBuild")
	for i := len(opts) - 1; i >= 0; i-- {
		// `dockerfile` optional argument
		if !querybuilder.IsZeroValue(opts[i].Dockerfile) {
			q = q.Arg("dockerfile", opts[i].Dockerfile)
		}
		// `platform` optional argument
		if !querybuilder.IsZeroValue(opts[i].Platform) {
			q = q.Arg("platform", opts[i].Platform)
		}
		// `buildArgs` optional argument
		if !querybuilder.IsZeroValue(opts[i].BuildArgs) {
			q = q.Arg("buildArgs", opts[i].BuildArgs)
		}
		// `target` optional argument
		if !querybuilder.IsZeroValue(opts[i].Target) {
			q = q.Arg("target", opts[i].Target)
		}
		// `secrets` optional argument
		if !querybuilder.IsZeroValue(opts[i].Secrets) {
			q = q.Arg("secrets", opts[i].Secrets)
		}
	}

	return &Container{
		Q: q,
		C: r.C,
	}
}

// DirectoryEntriesOpts contains options for Directory.Entries
type DirectoryEntriesOpts struct {
	// Location of the directory to look at (e.g., "/src").
	Path string
}

// Returns a list of files and directories at the given path.
func (r *Directory) Entries(ctx context.Context, opts ...DirectoryEntriesOpts) ([]string, error) {
	q := r.Q.Select("entries")
	for i := len(opts) - 1; i >= 0; i-- {
		// `path` optional argument
		if !querybuilder.IsZeroValue(opts[i].Path) {
			q = q.Arg("path", opts[i].Path)
		}
	}

	var response []string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Writes the contents of the directory to a path on the host.
func (r *Directory) Export(ctx context.Context, path string) (bool, error) {
	if r.export != nil {
		return *r.export, nil
	}
	q := r.Q.Select("export")
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves a file at the given path.
func (r *Directory) File(path string) *File {
	q := r.Q.Select("file")
	q = q.Arg("path", path)

	return &File{
		Q: q,
		C: r.C,
	}
}

// The content-addressed identifier of the directory.
func (r *Directory) ID(ctx context.Context) (DirectoryID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response DirectoryID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Directory) XXX_GraphQLType() string {
	return "Directory"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Directory) XXX_GraphQLIDType() string {
	return "DirectoryID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Directory) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// DirectoryPipelineOpts contains options for Directory.Pipeline
type DirectoryPipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline
func (r *Directory) Pipeline(name string, opts ...DirectoryPipelineOpts) *Directory {
	q := r.Q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Force evaluation in the engine.
func (r *Directory) Sync(ctx context.Context) (*Directory, error) {
	q := r.Q.Select("sync")

	return r, q.Execute(ctx, r.C)
}

// DirectoryWithDirectoryOpts contains options for Directory.WithDirectory
type DirectoryWithDirectoryOpts struct {
	// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
	Exclude []string
	// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
	Include []string
}

// Retrieves this directory plus a directory written at the given path.
func (r *Directory) WithDirectory(path string, directory *Directory, opts ...DirectoryWithDirectoryOpts) *Directory {
	q := r.Q.Select("withDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("directory", directory)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// DirectoryWithFileOpts contains options for Directory.WithFile
type DirectoryWithFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
}

// Retrieves this directory plus the contents of the given file copied to the given path.
func (r *Directory) WithFile(path string, source *File, opts ...DirectoryWithFileOpts) *Directory {
	q := r.Q.Select("withFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("source", source)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// DirectoryWithNewDirectoryOpts contains options for Directory.WithNewDirectory
type DirectoryWithNewDirectoryOpts struct {
	// Permission granted to the created directory (e.g., 0777).
	//
	// Default: 0755.
	Permissions int
}

// Retrieves this directory plus a new directory created at the given path.
func (r *Directory) WithNewDirectory(path string, opts ...DirectoryWithNewDirectoryOpts) *Directory {
	q := r.Q.Select("withNewDirectory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// DirectoryWithNewFileOpts contains options for Directory.WithNewFile
type DirectoryWithNewFileOpts struct {
	// Permission given to the copied file (e.g., 0600).
	//
	// Default: 0644.
	Permissions int
}

// Retrieves this directory plus a new file written at the given path.
func (r *Directory) WithNewFile(path string, contents string, opts ...DirectoryWithNewFileOpts) *Directory {
	q := r.Q.Select("withNewFile")
	for i := len(opts) - 1; i >= 0; i-- {
		// `permissions` optional argument
		if !querybuilder.IsZeroValue(opts[i].Permissions) {
			q = q.Arg("permissions", opts[i].Permissions)
		}
	}
	q = q.Arg("path", path)
	q = q.Arg("contents", contents)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Retrieves this directory with all file/dir timestamps set to the given time.
func (r *Directory) WithTimestamps(timestamp int) *Directory {
	q := r.Q.Select("withTimestamps")
	q = q.Arg("timestamp", timestamp)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Retrieves this directory with the directory at the given path removed.
func (r *Directory) WithoutDirectory(path string) *Directory {
	q := r.Q.Select("withoutDirectory")
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Retrieves this directory with the file at the given path removed.
func (r *Directory) WithoutFile(path string) *Directory {
	q := r.Q.Select("withoutFile")
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// A simple key value object that represents an environment variable.
type EnvVariable struct {
	Q *querybuilder.Selection
	C graphql.Client

	name  *string
	value *string
}

// The environment variable name.
func (r *EnvVariable) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The environment variable value.
func (r *EnvVariable) Value(ctx context.Context) (string, error) {
	if r.value != nil {
		return *r.value, nil
	}
	q := r.Q.Select("value")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A collection of Dagger resources that can be queried and invoked.
type Environment struct {
	Q *querybuilder.Selection
	C graphql.Client

	id   *EnvironmentID
	name *string
}
type WithEnvironmentFunc func(r *Environment) *Environment

// With calls the provided function with current Environment.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Environment) With(f WithEnvironmentFunc) *Environment {
	return f(r)
}

// TODO
func (r *Environment) Check(name string) *EnvironmentCheck {
	q := r.Q.Select("check")
	q = q.Arg("name", name)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) Checks(ctx context.Context) ([]EnvironmentCheck, error) {
	q := r.Q.Select("checks")

	q = q.Select("description id name")

	type checks struct {
		Description string
		Id          EnvironmentCheckID
		Name        string
	}

	convert := func(fields []checks) []EnvironmentCheck {
		out := []EnvironmentCheck{}

		for i := range fields {
			out = append(out, EnvironmentCheck{description: &fields[i].Description, id: &fields[i].Id, name: &fields[i].Name})
		}

		return out
	}
	var response []checks

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// TODO
func (r *Environment) Command(name string) *EnvironmentCommand {
	q := r.Q.Select("command")
	q = q.Arg("name", name)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// Commands provided by this environment
func (r *Environment) Commands(ctx context.Context) ([]EnvironmentCommand, error) {
	q := r.Q.Select("commands")

	q = q.Select("description id name resultType")

	type commands struct {
		Description string
		Id          EnvironmentCommandID
		Name        string
		ResultType  string
	}

	convert := func(fields []commands) []EnvironmentCommand {
		out := []EnvironmentCommand{}

		for i := range fields {
			out = append(out, EnvironmentCommand{description: &fields[i].Description, id: &fields[i].Id, name: &fields[i].Name, resultType: &fields[i].ResultType})
		}

		return out
	}
	var response []commands

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// A unique identifier for this environment.
func (r *Environment) ID(ctx context.Context) (EnvironmentID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response EnvironmentID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Environment) XXX_GraphQLType() string {
	return "Environment"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Environment) XXX_GraphQLIDType() string {
	return "EnvironmentID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Environment) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// Initialize this environment from the given directory and config path
func (r *Environment) Load(source *Directory, configPath string) *Environment {
	q := r.Q.Select("load")
	q = q.Arg("source", source)
	q = q.Arg("configPath", configPath)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// Name of the environment
func (r *Environment) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
func (r *Environment) Shell(name string) *EnvironmentShell {
	q := r.Q.Select("shell")
	q = q.Arg("name", name)

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) Shells(ctx context.Context) ([]EnvironmentShell, error) {
	q := r.Q.Select("shells")

	q = q.Select("description endpoint id name")

	type shells struct {
		Description string
		Endpoint    string
		Id          EnvironmentShellID
		Name        string
	}

	convert := func(fields []shells) []EnvironmentShell {
		out := []EnvironmentShell{}

		for i := range fields {
			out = append(out, EnvironmentShell{description: &fields[i].Description, endpoint: &fields[i].Endpoint, id: &fields[i].Id, name: &fields[i].Name})
		}

		return out
	}
	var response []shells

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// TODO
func (r *Environment) WithCheck(id *EnvironmentCheck) *Environment {
	q := r.Q.Select("withCheck")
	q = q.Arg("id", id)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) WithCommand(id *EnvironmentCommand) *Environment {
	q := r.Q.Select("withCommand")
	q = q.Arg("id", id)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) WithExtension(id *Environment, namespace string) *Environment {
	q := r.Q.Select("withExtension")
	q = q.Arg("id", id)
	q = q.Arg("namespace", namespace)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) WithFunction(id *EnvironmentFunction) *Environment {
	q := r.Q.Select("withFunction")
	q = q.Arg("id", id)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Environment) WithShell(id *EnvironmentShell) *Environment {
	q := r.Q.Select("withShell")
	q = q.Arg("id", id)

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// TODO
type EnvironmentCheck struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	id          *EnvironmentCheckID
	name        *string
}
type WithEnvironmentCheckFunc func(r *EnvironmentCheck) *EnvironmentCheck

// With calls the provided function with current EnvironmentCheck.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *EnvironmentCheck) With(f WithEnvironmentCheckFunc) *EnvironmentCheck {
	return f(r)
}

// Documentation for what this check checks.
func (r *EnvironmentCheck) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Flags accepted by this check.
func (r *EnvironmentCheck) Flags(ctx context.Context) ([]EnvironmentCheckFlag, error) {
	q := r.Q.Select("flags")

	q = q.Select("description name")

	type flags struct {
		Description string
		Name        string
	}

	convert := func(fields []flags) []EnvironmentCheckFlag {
		out := []EnvironmentCheckFlag{}

		for i := range fields {
			out = append(out, EnvironmentCheckFlag{description: &fields[i].Description, name: &fields[i].Name})
		}

		return out
	}
	var response []flags

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// A unique identifier for this check.
func (r *EnvironmentCheck) ID(ctx context.Context) (EnvironmentCheckID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response EnvironmentCheckID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *EnvironmentCheck) XXX_GraphQLType() string {
	return "EnvironmentCheck"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *EnvironmentCheck) XXX_GraphQLIDType() string {
	return "EnvironmentCheckID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *EnvironmentCheck) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// The name of the check.
func (r *EnvironmentCheck) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
func (r *EnvironmentCheck) Result(ctx context.Context) ([]EnvironmentCheckResult, error) {
	q := r.Q.Select("result")

	q = q.Select("name output success")

	type result struct {
		Name    string
		Output  string
		Success bool
	}

	convert := func(fields []result) []EnvironmentCheckResult {
		out := []EnvironmentCheckResult{}

		for i := range fields {
			out = append(out, EnvironmentCheckResult{name: &fields[i].Name, output: &fields[i].Output, success: &fields[i].Success})
		}

		return out
	}
	var response []result

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// TODO
func (r *EnvironmentCheck) SetStringFlag(name string, value string) *EnvironmentCheck {
	q := r.Q.Select("setStringFlag")
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCheck) Subchecks(ctx context.Context) ([]EnvironmentCheck, error) {
	q := r.Q.Select("subchecks")

	q = q.Select("description id name")

	type subchecks struct {
		Description string
		Id          EnvironmentCheckID
		Name        string
	}

	convert := func(fields []subchecks) []EnvironmentCheck {
		out := []EnvironmentCheck{}

		for i := range fields {
			out = append(out, EnvironmentCheck{description: &fields[i].Description, id: &fields[i].Id, name: &fields[i].Name})
		}

		return out
	}
	var response []subchecks

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// TODO
func (r *EnvironmentCheck) WithDescription(description string) *EnvironmentCheck {
	q := r.Q.Select("withDescription")
	q = q.Arg("description", description)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// EnvironmentCheckWithFlagOpts contains options for EnvironmentCheck.WithFlag
type EnvironmentCheckWithFlagOpts struct {
	Description string
}

// TODO
func (r *EnvironmentCheck) WithFlag(name string, opts ...EnvironmentCheckWithFlagOpts) *EnvironmentCheck {
	q := r.Q.Select("withFlag")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("name", name)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCheck) WithName(name string) *EnvironmentCheck {
	q := r.Q.Select("withName")
	q = q.Arg("name", name)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCheck) WithSubcheck(id *EnvironmentCheck) *EnvironmentCheck {
	q := r.Q.Select("withSubcheck")
	q = q.Arg("id", id)

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// A flag accepted by a environment check.
type EnvironmentCheckFlag struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	name        *string
}

// Documentation for what this flag sets.
func (r *EnvironmentCheckFlag) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the flag.
func (r *EnvironmentCheckFlag) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
type EnvironmentCheckResult struct {
	Q *querybuilder.Selection
	C graphql.Client

	name    *string
	output  *string
	success *bool
}

func (r *EnvironmentCheckResult) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

func (r *EnvironmentCheckResult) Output(ctx context.Context) (string, error) {
	if r.output != nil {
		return *r.output, nil
	}
	q := r.Q.Select("output")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

func (r *EnvironmentCheckResult) Success(ctx context.Context) (bool, error) {
	if r.success != nil {
		return *r.success, nil
	}
	q := r.Q.Select("success")

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A command defined in a environment that can be invoked from the CLI.
type EnvironmentCommand struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	id          *EnvironmentCommandID
	name        *string
	resultType  *string
}
type WithEnvironmentCommandFunc func(r *EnvironmentCommand) *EnvironmentCommand

// With calls the provided function with current EnvironmentCommand.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *EnvironmentCommand) With(f WithEnvironmentCommandFunc) *EnvironmentCommand {
	return f(r)
}

// Documentation for what this command does.
func (r *EnvironmentCommand) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Flags accepted by this command.
func (r *EnvironmentCommand) Flags(ctx context.Context) ([]EnvironmentCommandFlag, error) {
	q := r.Q.Select("flags")

	q = q.Select("description name")

	type flags struct {
		Description string
		Name        string
	}

	convert := func(fields []flags) []EnvironmentCommandFlag {
		out := []EnvironmentCommandFlag{}

		for i := range fields {
			out = append(out, EnvironmentCommandFlag{description: &fields[i].Description, name: &fields[i].Name})
		}

		return out
	}
	var response []flags

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// A unique identifier for this command.
func (r *EnvironmentCommand) ID(ctx context.Context) (EnvironmentCommandID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response EnvironmentCommandID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *EnvironmentCommand) XXX_GraphQLType() string {
	return "EnvironmentCommand"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *EnvironmentCommand) XXX_GraphQLIDType() string {
	return "EnvironmentCommandID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *EnvironmentCommand) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// TODO
func (r *EnvironmentCommand) Invoke() *InvokeCommandResult {
	q := r.Q.Select("invoke")

	return &InvokeCommandResult{
		Q: q,
		C: r.C,
	}
}

// The name of the command.
func (r *EnvironmentCommand) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the type returned by this command.
func (r *EnvironmentCommand) ResultType(ctx context.Context) (string, error) {
	if r.resultType != nil {
		return *r.resultType, nil
	}
	q := r.Q.Select("resultType")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO, can we make an input that's like map[string]any?
func (r *EnvironmentCommand) SetStringFlag(name string, value string) *EnvironmentCommand {
	q := r.Q.Select("setStringFlag")
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCommand) WithDescription(description string) *EnvironmentCommand {
	q := r.Q.Select("withDescription")
	q = q.Arg("description", description)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// EnvironmentCommandWithFlagOpts contains options for EnvironmentCommand.WithFlag
type EnvironmentCommandWithFlagOpts struct {
	Description string
}

// TODO
func (r *EnvironmentCommand) WithFlag(name string, opts ...EnvironmentCommandWithFlagOpts) *EnvironmentCommand {
	q := r.Q.Select("withFlag")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("name", name)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCommand) WithName(name string) *EnvironmentCommand {
	q := r.Q.Select("withName")
	q = q.Arg("name", name)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentCommand) WithResultType(name string) *EnvironmentCommand {
	q := r.Q.Select("withResultType")
	q = q.Arg("name", name)

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// A flag accepted by a environment command.
type EnvironmentCommandFlag struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	name        *string
}

// Documentation for what this flag sets.
func (r *EnvironmentCommandFlag) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the flag.
func (r *EnvironmentCommandFlag) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
type EnvironmentFunction struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	id          *EnvironmentFunctionID
	name        *string
	resultType  *string
}
type WithEnvironmentFunctionFunc func(r *EnvironmentFunction) *EnvironmentFunction

// With calls the provided function with current EnvironmentFunction.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *EnvironmentFunction) With(f WithEnvironmentFunctionFunc) *EnvironmentFunction {
	return f(r)
}

// TODO
func (r *EnvironmentFunction) Args(ctx context.Context) ([]EnvironmentFunctionArg, error) {
	q := r.Q.Select("args")

	q = q.Select("argType description isList name")

	type args struct {
		ArgType     string
		Description string
		IsList      bool
		Name        string
	}

	convert := func(fields []args) []EnvironmentFunctionArg {
		out := []EnvironmentFunctionArg{}

		for i := range fields {
			out = append(out, EnvironmentFunctionArg{argType: &fields[i].ArgType, description: &fields[i].Description, isList: &fields[i].IsList, name: &fields[i].Name})
		}

		return out
	}
	var response []args

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// TODO
func (r *EnvironmentFunction) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A unique identifier for this function.
func (r *EnvironmentFunction) ID(ctx context.Context) (EnvironmentFunctionID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response EnvironmentFunctionID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *EnvironmentFunction) XXX_GraphQLType() string {
	return "EnvironmentFunction"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *EnvironmentFunction) XXX_GraphQLIDType() string {
	return "EnvironmentFunctionID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *EnvironmentFunction) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// The name of the function.
func (r *EnvironmentFunction) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the type returned by this function.
func (r *EnvironmentFunction) ResultType(ctx context.Context) (string, error) {
	if r.resultType != nil {
		return *r.resultType, nil
	}
	q := r.Q.Select("resultType")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// EnvironmentFunctionWithArgOpts contains options for EnvironmentFunction.WithArg
type EnvironmentFunctionWithArgOpts struct {
	Description string
}

// TODO
func (r *EnvironmentFunction) WithArg(name string, argType string, isList bool, opts ...EnvironmentFunctionWithArgOpts) *EnvironmentFunction {
	q := r.Q.Select("withArg")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("name", name)
	q = q.Arg("argType", argType)
	q = q.Arg("isList", isList)

	return &EnvironmentFunction{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentFunction) WithDescription(description string) *EnvironmentFunction {
	q := r.Q.Select("withDescription")
	q = q.Arg("description", description)

	return &EnvironmentFunction{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentFunction) WithName(name string) *EnvironmentFunction {
	q := r.Q.Select("withName")
	q = q.Arg("name", name)

	return &EnvironmentFunction{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentFunction) WithResultType(name string) *EnvironmentFunction {
	q := r.Q.Select("withResultType")
	q = q.Arg("name", name)

	return &EnvironmentFunction{
		Q: q,
		C: r.C,
	}
}

// TODO
type EnvironmentFunctionArg struct {
	Q *querybuilder.Selection
	C graphql.Client

	argType     *string
	description *string
	isList      *bool
	name        *string
}

// TODO, should be enum
func (r *EnvironmentFunctionArg) ArgType(ctx context.Context) (string, error) {
	if r.argType != nil {
		return *r.argType, nil
	}
	q := r.Q.Select("argType")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Documentation for what this arg sets.
func (r *EnvironmentFunctionArg) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
func (r *EnvironmentFunctionArg) IsList(ctx context.Context) (bool, error) {
	if r.isList != nil {
		return *r.isList, nil
	}
	q := r.Q.Select("isList")

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the arg.
func (r *EnvironmentFunctionArg) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
type EnvironmentShell struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	endpoint    *string
	id          *EnvironmentShellID
	name        *string
}
type WithEnvironmentShellFunc func(r *EnvironmentShell) *EnvironmentShell

// With calls the provided function with current EnvironmentShell.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *EnvironmentShell) With(f WithEnvironmentShellFunc) *EnvironmentShell {
	return f(r)
}

// Documentation for what this shell shells. TODO: fix
func (r *EnvironmentShell) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
func (r *EnvironmentShell) Endpoint(ctx context.Context) (string, error) {
	if r.endpoint != nil {
		return *r.endpoint, nil
	}
	q := r.Q.Select("endpoint")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Flags accepted by this shell.
func (r *EnvironmentShell) Flags(ctx context.Context) ([]EnvironmentShellFlag, error) {
	q := r.Q.Select("flags")

	q = q.Select("description name")

	type flags struct {
		Description string
		Name        string
	}

	convert := func(fields []flags) []EnvironmentShellFlag {
		out := []EnvironmentShellFlag{}

		for i := range fields {
			out = append(out, EnvironmentShellFlag{description: &fields[i].Description, name: &fields[i].Name})
		}

		return out
	}
	var response []flags

	q = q.Bind(&response)

	err := q.Execute(ctx, r.C)
	if err != nil {
		return nil, err
	}

	return convert(response), nil
}

// A unique identifier for this shell.
func (r *EnvironmentShell) ID(ctx context.Context) (EnvironmentShellID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response EnvironmentShellID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *EnvironmentShell) XXX_GraphQLType() string {
	return "EnvironmentShell"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *EnvironmentShell) XXX_GraphQLIDType() string {
	return "EnvironmentShellID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *EnvironmentShell) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// The name of the shell.
func (r *EnvironmentShell) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
func (r *EnvironmentShell) SetStringFlag(name string, value string) *EnvironmentShell {
	q := r.Q.Select("setStringFlag")
	q = q.Arg("name", name)
	q = q.Arg("value", value)

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentShell) WithDescription(description string) *EnvironmentShell {
	q := r.Q.Select("withDescription")
	q = q.Arg("description", description)

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// EnvironmentShellWithFlagOpts contains options for EnvironmentShell.WithFlag
type EnvironmentShellWithFlagOpts struct {
	Description string
}

// TODO
func (r *EnvironmentShell) WithFlag(name string, opts ...EnvironmentShellWithFlagOpts) *EnvironmentShell {
	q := r.Q.Select("withFlag")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
	}
	q = q.Arg("name", name)

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *EnvironmentShell) WithName(name string) *EnvironmentShell {
	q := r.Q.Select("withName")
	q = q.Arg("name", name)

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// A flag accepted by a environment shell.
type EnvironmentShellFlag struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	name        *string
}

// Documentation for what this flag sets.
func (r *EnvironmentShellFlag) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The name of the flag.
func (r *EnvironmentShellFlag) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// TODO
type Extensions struct {
	Q *querybuilder.Selection
	C graphql.Client

	dummy *bool
}

// TODO: needed?
func (r *Extensions) Dummy(ctx context.Context) (bool, error) {
	if r.dummy != nil {
		return *r.dummy, nil
	}
	q := r.Q.Select("dummy")

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A file.
type File struct {
	Q *querybuilder.Selection
	C graphql.Client

	contents *string
	export   *bool
	id       *FileID
	size     *int
	sync     *FileID
}
type WithFileFunc func(r *File) *File

// With calls the provided function with current File.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *File) With(f WithFileFunc) *File {
	return f(r)
}

// Retrieves the contents of the file.
func (r *File) Contents(ctx context.Context) (string, error) {
	if r.contents != nil {
		return *r.contents, nil
	}
	q := r.Q.Select("contents")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// FileExportOpts contains options for File.Export
type FileExportOpts struct {
	// If allowParentDirPath is true, the path argument can be a directory path, in which case
	// the file will be created in that directory.
	AllowParentDirPath bool
}

// Writes the file to a file path on the host.
func (r *File) Export(ctx context.Context, path string, opts ...FileExportOpts) (bool, error) {
	if r.export != nil {
		return *r.export, nil
	}
	q := r.Q.Select("export")
	for i := len(opts) - 1; i >= 0; i-- {
		// `allowParentDirPath` optional argument
		if !querybuilder.IsZeroValue(opts[i].AllowParentDirPath) {
			q = q.Arg("allowParentDirPath", opts[i].AllowParentDirPath)
		}
	}
	q = q.Arg("path", path)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Retrieves the content-addressed identifier of the file.
func (r *File) ID(ctx context.Context) (FileID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response FileID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *File) XXX_GraphQLType() string {
	return "File"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *File) XXX_GraphQLIDType() string {
	return "FileID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *File) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// Gets the size of the file, in bytes.
func (r *File) Size(ctx context.Context) (int, error) {
	if r.size != nil {
		return *r.size, nil
	}
	q := r.Q.Select("size")

	var response int

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// Force evaluation in the engine.
func (r *File) Sync(ctx context.Context) (*File, error) {
	q := r.Q.Select("sync")

	return r, q.Execute(ctx, r.C)
}

// Retrieves this file with its created/modified timestamps set to the given time.
func (r *File) WithTimestamps(timestamp int) *File {
	q := r.Q.Select("withTimestamps")
	q = q.Arg("timestamp", timestamp)

	return &File{
		Q: q,
		C: r.C,
	}
}

// A git ref (tag, branch or commit).
type GitRef struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// GitRefTreeOpts contains options for GitRef.Tree
type GitRefTreeOpts struct {
	SSHKnownHosts string

	SSHAuthSocket *Socket
}

// The filesystem tree at this ref.
func (r *GitRef) Tree(opts ...GitRefTreeOpts) *Directory {
	q := r.Q.Select("tree")
	for i := len(opts) - 1; i >= 0; i-- {
		// `sshKnownHosts` optional argument
		if !querybuilder.IsZeroValue(opts[i].SSHKnownHosts) {
			q = q.Arg("sshKnownHosts", opts[i].SSHKnownHosts)
		}
		// `sshAuthSocket` optional argument
		if !querybuilder.IsZeroValue(opts[i].SSHAuthSocket) {
			q = q.Arg("sshAuthSocket", opts[i].SSHAuthSocket)
		}
	}

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// A git repository.
type GitRepository struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// Returns details on one branch.
func (r *GitRepository) Branch(name string) *GitRef {
	q := r.Q.Select("branch")
	q = q.Arg("name", name)

	return &GitRef{
		Q: q,
		C: r.C,
	}
}

// Returns details on one commit.
func (r *GitRepository) Commit(id string) *GitRef {
	q := r.Q.Select("commit")
	q = q.Arg("id", id)

	return &GitRef{
		Q: q,
		C: r.C,
	}
}

// Returns details on one tag.
func (r *GitRepository) Tag(name string) *GitRef {
	q := r.Q.Select("tag")
	q = q.Arg("name", name)

	return &GitRef{
		Q: q,
		C: r.C,
	}
}

// Information about the host execution environment.
type Host struct {
	Q *querybuilder.Selection
	C graphql.Client
}

// HostDirectoryOpts contains options for Host.Directory
type HostDirectoryOpts struct {
	// Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
	Exclude []string
	// Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
	Include []string
}

// Accesses a directory on the host.
func (r *Host) Directory(path string, opts ...HostDirectoryOpts) *Directory {
	q := r.Q.Select("directory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `exclude` optional argument
		if !querybuilder.IsZeroValue(opts[i].Exclude) {
			q = q.Arg("exclude", opts[i].Exclude)
		}
		// `include` optional argument
		if !querybuilder.IsZeroValue(opts[i].Include) {
			q = q.Arg("include", opts[i].Include)
		}
	}
	q = q.Arg("path", path)

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// Accesses a file on the host.
func (r *Host) File(path string) *File {
	q := r.Q.Select("file")
	q = q.Arg("path", path)

	return &File{
		Q: q,
		C: r.C,
	}
}

// Sets a secret given a user-defined name and the file path on the host, and returns the secret.
// The file is limited to a size of 512000 bytes.
func (r *Host) SetSecretFile(name string, path string) *Secret {
	q := r.Q.Select("setSecretFile")
	q = q.Arg("name", name)
	q = q.Arg("path", path)

	return &Secret{
		Q: q,
		C: r.C,
	}
}

// Accesses a Unix socket on the host.
func (r *Host) UnixSocket(path string) *Socket {
	q := r.Q.Select("unixSocket")
	q = q.Arg("path", path)

	return &Socket{
		Q: q,
		C: r.C,
	}
}

// TODO
type InvokeCommandResult struct {
	Q *querybuilder.Selection
	C graphql.Client

	string *string
}

// TODO
func (r *InvokeCommandResult) Directory() *Directory {
	q := r.Q.Select("directory")

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *InvokeCommandResult) File() *File {
	q := r.Q.Select("file")

	return &File{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *InvokeCommandResult) String(ctx context.Context) (string, error) {
	if r.string != nil {
		return *r.string, nil
	}
	q := r.Q.Select("string")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A simple key value object that represents a label.
type Label struct {
	Q *querybuilder.Selection
	C graphql.Client

	name  *string
	value *string
}

// The label name.
func (r *Label) Name(ctx context.Context) (string, error) {
	if r.name != nil {
		return *r.name, nil
	}
	q := r.Q.Select("name")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The label value.
func (r *Label) Value(ctx context.Context) (string, error) {
	if r.value != nil {
		return *r.value, nil
	}
	q := r.Q.Select("value")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// A port exposed by a container.
type Port struct {
	Q *querybuilder.Selection
	C graphql.Client

	description *string
	port        *int
	protocol    *NetworkProtocol
}

// The port description.
func (r *Port) Description(ctx context.Context) (string, error) {
	if r.description != nil {
		return *r.description, nil
	}
	q := r.Q.Select("description")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The port number.
func (r *Port) Port(ctx context.Context) (int, error) {
	if r.port != nil {
		return *r.port, nil
	}
	q := r.Q.Select("port")

	var response int

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// The transport layer network protocol.
func (r *Port) Protocol(ctx context.Context) (NetworkProtocol, error) {
	if r.protocol != nil {
		return *r.protocol, nil
	}
	q := r.Q.Select("protocol")

	var response NetworkProtocol

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

type WithClientFunc func(r *Client) *Client

// With calls the provided function with current Client.
//
// This is useful for reusability and readability by not breaking the calling chain.
func (r *Client) With(f WithClientFunc) *Client {
	return f(r)
}

func (r *Client) Apko() *Apko {
	q := r.Q.Select("apko")

	return &Apko{
		Q: q,
		C: r.C,
	}
}

// Constructs a cache volume for a given cache key.
func (r *Client) CacheVolume(key string) *CacheVolume {
	q := r.Q.Select("cacheVolume")
	q = q.Arg("key", key)

	return &CacheVolume{
		Q: q,
		C: r.C,
	}
}

// Checks if the current Dagger Engine is compatible with an SDK's required version.
func (r *Client) CheckVersionCompatibility(ctx context.Context, version string) (bool, error) {
	q := r.Q.Select("checkVersionCompatibility")
	q = q.Arg("version", version)

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// ContainerOpts contains options for Client.Container
type ContainerOpts struct {
	ID ContainerID

	Platform Platform
}

// Loads a container from ID.
//
// Null ID returns an empty container (scratch).
// Optional platform argument initializes new containers to execute and publish as that platform.
// Platform defaults to that of the builder's host.
func (r *Client) Container(opts ...ContainerOpts) *Container {
	q := r.Q.Select("container")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
		// `platform` optional argument
		if !querybuilder.IsZeroValue(opts[i].Platform) {
			q = q.Arg("platform", opts[i].Platform)
		}
	}

	return &Container{
		Q: q,
		C: r.C,
	}
}

func (r *Client) Dagger() *Dagger {
	q := r.Q.Select("dagger")

	return &Dagger{
		Q: q,
		C: r.C,
	}
}

func (r *Client) Daggergo() *Daggergo {
	q := r.Q.Select("daggergo")

	return &Daggergo{
		Q: q,
		C: r.C,
	}
}

func (r *Client) Daggerpython() *Daggerpython {
	q := r.Q.Select("daggerpython")

	return &Daggerpython{
		Q: q,
		C: r.C,
	}
}

// The default platform of the builder.
func (r *Client) DefaultPlatform(ctx context.Context) (Platform, error) {
	q := r.Q.Select("defaultPlatform")

	var response Platform

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// DirectoryOpts contains options for Client.Directory
type DirectoryOpts struct {
	ID DirectoryID
}

// Load a directory by ID. No argument produces an empty directory.
func (r *Client) Directory(opts ...DirectoryOpts) *Directory {
	q := r.Q.Select("directory")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Directory{
		Q: q,
		C: r.C,
	}
}

// EnvironmentOpts contains options for Client.Environment
type EnvironmentOpts struct {
	ID EnvironmentID
}

// Load a environment from ID.
func (r *Client) Environment(opts ...EnvironmentOpts) *Environment {
	q := r.Q.Select("environment")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Environment{
		Q: q,
		C: r.C,
	}
}

// EnvironmentCheckOpts contains options for Client.EnvironmentCheck
type EnvironmentCheckOpts struct {
	ID EnvironmentCheckID
}

// Load a environment check from ID.
func (r *Client) EnvironmentCheck(opts ...EnvironmentCheckOpts) *EnvironmentCheck {
	q := r.Q.Select("environmentCheck")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &EnvironmentCheck{
		Q: q,
		C: r.C,
	}
}

// EnvironmentCommandOpts contains options for Client.EnvironmentCommand
type EnvironmentCommandOpts struct {
	ID EnvironmentCommandID
}

// Load a environment command from ID.
func (r *Client) EnvironmentCommand(opts ...EnvironmentCommandOpts) *EnvironmentCommand {
	q := r.Q.Select("environmentCommand")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &EnvironmentCommand{
		Q: q,
		C: r.C,
	}
}

// EnvironmentFunctionOpts contains options for Client.EnvironmentFunction
type EnvironmentFunctionOpts struct {
	ID EnvironmentFunctionID
}

// Load a environment function from ID.
func (r *Client) EnvironmentFunction(opts ...EnvironmentFunctionOpts) *EnvironmentFunction {
	q := r.Q.Select("environmentFunction")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &EnvironmentFunction{
		Q: q,
		C: r.C,
	}
}

// EnvironmentShellOpts contains options for Client.EnvironmentShell
type EnvironmentShellOpts struct {
	ID EnvironmentShellID
}

// Load a environment shell from ID.
func (r *Client) EnvironmentShell(opts ...EnvironmentShellOpts) *EnvironmentShell {
	q := r.Q.Select("environmentShell")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &EnvironmentShell{
		Q: q,
		C: r.C,
	}
}

// TODO
func (r *Client) Extensions() *Extensions {
	q := r.Q.Select("extensions")

	return &Extensions{
		Q: q,
		C: r.C,
	}
}

// Loads a file by ID.
func (r *Client) File(id FileID) *File {
	q := r.Q.Select("file")
	q = q.Arg("id", id)

	return &File{
		Q: q,
		C: r.C,
	}
}

// GitOpts contains options for Client.Git
type GitOpts struct {
	// Set to true to keep .git directory.
	KeepGitDir bool
	// A service which must be started before the repo is fetched.
	ExperimentalServiceHost *Container
}

// Queries a git repository.
func (r *Client) Git(url string, opts ...GitOpts) *GitRepository {
	q := r.Q.Select("git")
	for i := len(opts) - 1; i >= 0; i-- {
		// `keepGitDir` optional argument
		if !querybuilder.IsZeroValue(opts[i].KeepGitDir) {
			q = q.Arg("keepGitDir", opts[i].KeepGitDir)
		}
		// `experimentalServiceHost` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalServiceHost) {
			q = q.Arg("experimentalServiceHost", opts[i].ExperimentalServiceHost)
		}
	}
	q = q.Arg("url", url)

	return &GitRepository{
		Q: q,
		C: r.C,
	}
}

// Queries the host environment.
func (r *Client) Host() *Host {
	q := r.Q.Select("host")

	return &Host{
		Q: q,
		C: r.C,
	}
}

// HTTPOpts contains options for Client.HTTP
type HTTPOpts struct {
	// A service which must be started before the URL is fetched.
	ExperimentalServiceHost *Container
}

// Returns a file containing an http remote url content.
func (r *Client) HTTP(url string, opts ...HTTPOpts) *File {
	q := r.Q.Select("http")
	for i := len(opts) - 1; i >= 0; i-- {
		// `experimentalServiceHost` optional argument
		if !querybuilder.IsZeroValue(opts[i].ExperimentalServiceHost) {
			q = q.Arg("experimentalServiceHost", opts[i].ExperimentalServiceHost)
		}
	}
	q = q.Arg("url", url)

	return &File{
		Q: q,
		C: r.C,
	}
}

// TODO: temp hack, should make each env load lazily (with some cache backend too)
func (r *Client) LoadUniverse(ctx context.Context) (bool, error) {
	q := r.Q.Select("loadUniverse")

	var response bool

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// PipelineOpts contains options for Client.Pipeline
type PipelineOpts struct {
	// Pipeline description.
	Description string
	// Pipeline labels.
	Labels []PipelineLabel
}

// Creates a named sub-pipeline.
func (r *Client) Pipeline(name string, opts ...PipelineOpts) *Client {
	q := r.Q.Select("pipeline")
	for i := len(opts) - 1; i >= 0; i-- {
		// `description` optional argument
		if !querybuilder.IsZeroValue(opts[i].Description) {
			q = q.Arg("description", opts[i].Description)
		}
		// `labels` optional argument
		if !querybuilder.IsZeroValue(opts[i].Labels) {
			q = q.Arg("labels", opts[i].Labels)
		}
	}
	q = q.Arg("name", name)

	return &Client{
		Q: q,
		C: r.C,
	}
}

// Loads a secret from its ID.
func (r *Client) Secret(id SecretID) *Secret {
	q := r.Q.Select("secret")
	q = q.Arg("id", id)

	return &Secret{
		Q: q,
		C: r.C,
	}
}

// Sets a secret given a user defined name to its plaintext and returns the secret.
// The plaintext value is limited to a size of 128000 bytes.
func (r *Client) SetSecret(name string, plaintext string) *Secret {
	q := r.Q.Select("setSecret")
	q = q.Arg("name", name)
	q = q.Arg("plaintext", plaintext)

	return &Secret{
		Q: q,
		C: r.C,
	}
}

// SocketOpts contains options for Client.Socket
type SocketOpts struct {
	ID SocketID
}

// Loads a socket by its ID.
func (r *Client) Socket(opts ...SocketOpts) *Socket {
	q := r.Q.Select("socket")
	for i := len(opts) - 1; i >= 0; i-- {
		// `id` optional argument
		if !querybuilder.IsZeroValue(opts[i].ID) {
			q = q.Arg("id", opts[i].ID)
		}
	}

	return &Socket{
		Q: q,
		C: r.C,
	}
}

// A reference to a secret value, which can be handled more safely than the value itself.
type Secret struct {
	Q *querybuilder.Selection
	C graphql.Client

	id        *SecretID
	plaintext *string
}

// The identifier for this secret.
func (r *Secret) ID(ctx context.Context) (SecretID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response SecretID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Secret) XXX_GraphQLType() string {
	return "Secret"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Secret) XXX_GraphQLIDType() string {
	return "SecretID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Secret) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

// The value of this secret.
func (r *Secret) Plaintext(ctx context.Context) (string, error) {
	if r.plaintext != nil {
		return *r.plaintext, nil
	}
	q := r.Q.Select("plaintext")

	var response string

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

type Socket struct {
	Q *querybuilder.Selection
	C graphql.Client

	id *SocketID
}

// The content-addressed identifier of the socket.
func (r *Socket) ID(ctx context.Context) (SocketID, error) {
	if r.id != nil {
		return *r.id, nil
	}
	q := r.Q.Select("id")

	var response SocketID

	q = q.Bind(&response)
	return response, q.Execute(ctx, r.C)
}

// XXX_GraphQLType is an internal function. It returns the native GraphQL type name
func (r *Socket) XXX_GraphQLType() string {
	return "Socket"
}

// XXX_GraphQLIDType is an internal function. It returns the native GraphQL type name for the ID of this object
func (r *Socket) XXX_GraphQLIDType() string {
	return "SocketID"
}

// XXX_GraphQLID is an internal function. It returns the underlying type ID
func (r *Socket) XXX_GraphQLID(ctx context.Context) (string, error) {
	id, err := r.ID(ctx)
	if err != nil {
		return "", err
	}
	return string(id), nil
}

type CacheSharingMode string

const (
	Locked  CacheSharingMode = "LOCKED"
	Private CacheSharingMode = "PRIVATE"
	Shared  CacheSharingMode = "SHARED"
)

type ImageLayerCompression string

const (
	Estargz      ImageLayerCompression = "EStarGZ"
	Gzip         ImageLayerCompression = "Gzip"
	Uncompressed ImageLayerCompression = "Uncompressed"
	Zstd         ImageLayerCompression = "Zstd"
)

type ImageMediaTypes string

const (
	Dockermediatypes ImageMediaTypes = "DockerMediaTypes"
	Ocimediatypes    ImageMediaTypes = "OCIMediaTypes"
)

type NetworkProtocol string

const (
	Tcp NetworkProtocol = "TCP"
	Udp NetworkProtocol = "UDP"
)
