// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.function.UnaryOperator;

/**
 * An OCI-compatible container, also known as a Docker container.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(Container.Deserializer.class)
public class Container implements IDAble<ContainerID> {
    private QueryBuilder queryBuilder;

    private String envVariable;

    private Integer exitCode;

    private String export;

    private ContainerID id;

    private String imageRef;

    private String label;

    private Platform platform;

    private String publish;

    private String stderr;

    private String stdout;

    private ContainerID sync;

    private Void up;

    private String user;

    private String workdir;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected Container() {
    }

    Container(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Turn the container into a Service.<br/><br/>Be sure to set any exposed ports before this conversion.</p>
     * @param optArgs asService optional arguments
     */
    public Service asService(AsServiceArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asService", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Turn the container into a Service.<br/><br/>Be sure to set any exposed ports before this conversion.</p>
     */
    public Service asService() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asService", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Package the container state as an OCI image, and return it as a tar archive</p>
     * @param optArgs asTarball optional arguments
     */
    public File asTarball(AsTarballArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asTarball", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Package the container state as an OCI image, and return it as a tar archive</p>
     */
    public File asTarball() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asTarball", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Initializes this container from a Dockerfile build.</p>
     * @param context Directory context used by the Dockerfile.
     * @param optArgs build optional arguments
     */
    public Container build(Directory context, BuildArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("context", context);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("build", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Initializes this container from a Dockerfile build.</p>
     * @param context Directory context used by the Dockerfile.
     */
    public Container build(Directory context) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("context", context);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("build", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return the container's default arguments.</p>
     */
    public List<String> defaultArgs() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("defaultArgs");
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>Retrieve a directory from the container's root filesystem<br/><br/>Mounts are included.</p>
     * @param path The path of the directory to retrieve (e.g., "./src").
     * @param optArgs directory optional arguments
     */
    public Directory directory(String path, DirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieve a directory from the container's root filesystem<br/><br/>Mounts are included.</p>
     * @param path The path of the directory to retrieve (e.g., "./src").
     */
    public Directory directory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return the container's OCI entrypoint.</p>
     */
    public List<String> entrypoint() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("entrypoint");
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>Retrieves the value of the specified environment variable.</p>
     * @param name The name of the environment variable to retrieve (e.g., "PATH").
     */
    public String envVariable(String name) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.envVariable != null) {
            return envVariable;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("envVariable", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves the list of environment variables passed to commands.</p>
     */
    public List<EnvVariable> envVariables() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("envVariables");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(EnvVariable.class);
        return builders.stream().map(qb -> new EnvVariable(qb)).toList();
    }

    /**
     * <p>The exit code of the last executed command<br/><br/>Returns an error if no command was executed</p>
     */
    public Integer exitCode() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.exitCode != null) {
            return exitCode;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("exitCode");
        return nextQueryBuilder.executeQuery(java.lang.Integer.class);
    }

    /**
     * <p>EXPERIMENTAL API! Subject to change/removal at any time.<br/><br/>Configures all available GPUs on the host to be accessible to this container.<br/><br/>This currently works for Nvidia devices only.</p>
     */
    public Container experimentalWithAllGPUs() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("experimentalWithAllGPUs");
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>EXPERIMENTAL API! Subject to change/removal at any time.<br/><br/>Configures the provided list of devices to be accessible to this container.<br/><br/>This currently works for Nvidia devices only.</p>
     * @param devices List of devices to be accessible to this container.
     */
    public Container experimentalWithGPU(List<String> devices) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("devices", devices);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("experimentalWithGPU", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Writes the container as an OCI tarball to the destination file path on the host.<br/><br/>It can also export platform variants.</p>
     * @param path Host's destination path (e.g., "./tarball").<br/><br/>Path can be relative to the engine's workdir or absolute.
     * @param optArgs export optional arguments
     */
    public String export(String path, ExportArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Writes the container as an OCI tarball to the destination file path on the host.<br/><br/>It can also export platform variants.</p>
     * @param path Host's destination path (e.g., "./tarball").<br/><br/>Path can be relative to the engine's workdir or absolute.
     */
    public String export(String path) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves the list of exposed ports.<br/><br/>This includes ports already exposed by the image, even if not explicitly added with dagger.</p>
     */
    public List<Port> exposedPorts() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("exposedPorts");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(Port.class);
        return builders.stream().map(qb -> new Port(qb)).toList();
    }

    /**
     * <p>Retrieves a file at the given path.<br/><br/>Mounts are included.</p>
     * @param path The path of the file to retrieve (e.g., "./README.md").
     * @param optArgs file optional arguments
     */
    public File file(String path, FileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("file", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Retrieves a file at the given path.<br/><br/>Mounts are included.</p>
     * @param path The path of the file to retrieve (e.g., "./README.md").
     */
    public File file(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("file", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Download a container image, and apply it to the container state. All previous state will be lost.</p>
     * @param address Address of the container image to download, in standard OCI ref format. Example:"registry.dagger.io/engine:latest"
     */
    public Container from(String address) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("address", address);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("from", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>A unique identifier for this Container.</p>
     */
    public ContainerID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(ContainerID.class);
    }

    /**
     * <p>The unique image reference which can only be retrieved immediately after the 'Container.From' call.</p>
     */
    public String imageRef() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.imageRef != null) {
            return imageRef;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("imageRef");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Reads the container from an OCI tarball.</p>
     * @param source File to read the container from.
     * @param optArgs importTarball optional arguments
     */
    public Container importTarball(File source, ImportTarballArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("import", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Reads the container from an OCI tarball.</p>
     * @param source File to read the container from.
     */
    public Container importTarball(File source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("import", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves the value of the specified label.</p>
     * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
     */
    public String label(String name) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.label != null) {
            return label;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("label", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves the list of labels passed to container.</p>
     */
    public List<Label> labels() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("labels");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(Label.class);
        return builders.stream().map(qb -> new Label(qb)).toList();
    }

    /**
     * <p>Retrieves the list of paths where a directory is mounted.</p>
     */
    public List<String> mounts() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("mounts");
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>The platform this container executes and publishes as.</p>
     */
    public Platform platform() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.platform != null) {
            return platform;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("platform");
        return nextQueryBuilder.executeQuery(Platform.class);
    }

    /**
     * <p>Package the container state as an OCI image, and publish it to a registry<br/><br/>Returns the fully qualified address of the published image, with digest</p>
     * @param address The OCI address to publish to<br/><br/>Same format as "docker push". Example: "registry.example.com/user/repo:tag"
     * @param optArgs publish optional arguments
     */
    public String publish(String address, PublishArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        if (this.publish != null) {
            return publish;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("address", address);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("publish", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Package the container state as an OCI image, and publish it to a registry<br/><br/>Returns the fully qualified address of the published image, with digest</p>
     * @param address The OCI address to publish to<br/><br/>Same format as "docker push". Example: "registry.example.com/user/repo:tag"
     */
    public String publish(String address) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.publish != null) {
            return publish;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("address", address);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("publish", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Return a snapshot of the container's root filesystem. The snapshot can be modified then written back using withRootfs. Use that method for filesystem modifications.</p>
     */
    public Directory rootfs() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("rootfs");
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>The buffered standard error stream of the last executed command<br/><br/>Returns an error if no command was executed</p>
     */
    public String stderr() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.stderr != null) {
            return stderr;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("stderr");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The buffered standard output stream of the last executed command<br/><br/>Returns an error if no command was executed</p>
     */
    public String stdout() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.stdout != null) {
            return stdout;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("stdout");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Forces evaluation of the pipeline in the engine.<br/><br/>It doesn't run the default command if no exec has been set.</p>
     */
    public Container sync() throws InterruptedException, ExecutionException, DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sync");
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Opens an interactive terminal for this container using its configured default terminal command if not overridden by args (or sh as a fallback default).</p>
     * @param optArgs terminal optional arguments
     */
    public Container terminal(TerminalArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("terminal", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Opens an interactive terminal for this container using its configured default terminal command if not overridden by args (or sh as a fallback default).</p>
     */
    public Container terminal() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("terminal", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Starts a Service and creates a tunnel that forwards traffic from the caller's network to that service.<br/><br/>Be sure to set any exposed ports before calling this api.</p>
     * @param optArgs up optional arguments
     */
    public Void up(UpArguments optArgs) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.up != null) {
            return up;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("up", fieldArgs);
        return nextQueryBuilder.executeQuery(Void.class);
    }

    /**
     * <p>Starts a Service and creates a tunnel that forwards traffic from the caller's network to that service.<br/><br/>Be sure to set any exposed ports before calling this api.</p>
     */
    public Void up() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.up != null) {
            return up;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("up", fieldArgs);
        return nextQueryBuilder.executeQuery(Void.class);
    }

    /**
     * <p>Retrieves the user to be set for all commands.</p>
     */
    public String user() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.user != null) {
            return user;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("user");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves this container plus the given OCI anotation.</p>
     * @param name The name of the annotation.
     * @param value The value of the annotation.
     */
    public Container withAnnotation(String name, String value) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withAnnotation", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Configures default arguments for future commands. Like CMD in Dockerfile.</p>
     * @param args Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
     */
    public Container withDefaultArgs(List<String> args) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDefaultArgs", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set the default command to invoke for the container's terminal API.</p>
     * @param args The args of the command.
     * @param optArgs withDefaultTerminalCmd optional arguments
     */
    public Container withDefaultTerminalCmd(List<String> args,
            WithDefaultTerminalCmdArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDefaultTerminalCmd", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set the default command to invoke for the container's terminal API.</p>
     * @param args The args of the command.
     */
    public Container withDefaultTerminalCmd(List<String> args) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDefaultTerminalCmd", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a directory added to its filesystem</p>
     * @param path Location of the written directory (e.g., "/tmp/directory").
     * @param directory Identifier of the directory to write
     * @param optArgs withDirectory optional arguments
     */
    public Container withDirectory(String path, Directory directory,
            WithDirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("directory", directory);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a directory added to its filesystem</p>
     * @param path Location of the written directory (e.g., "/tmp/directory").
     * @param directory Identifier of the directory to write
     */
    public Container withDirectory(String path, Directory directory) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("directory", directory);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set an OCI-style entrypoint. It will be included in the container's OCI configuration. Note, withExec ignores the entrypoint by default.</p>
     * @param args Arguments of the entrypoint. Example: ["go", "run"].
     * @param optArgs withEntrypoint optional arguments
     */
    public Container withEntrypoint(List<String> args, WithEntrypointArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEntrypoint", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set an OCI-style entrypoint. It will be included in the container's OCI configuration. Note, withExec ignores the entrypoint by default.</p>
     * @param args Arguments of the entrypoint. Example: ["go", "run"].
     */
    public Container withEntrypoint(List<String> args) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEntrypoint", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set a new environment variable in the container.</p>
     * @param name Name of the environment variable (e.g., "HOST").
     * @param value Value of the environment variable. (e.g., "localhost").
     * @param optArgs withEnvVariable optional arguments
     */
    public Container withEnvVariable(String name, String value, WithEnvVariableArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnvVariable", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set a new environment variable in the container.</p>
     * @param name Name of the environment variable (e.g., "HOST").
     * @param value Value of the environment variable. (e.g., "localhost").
     */
    public Container withEnvVariable(String name, String value) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnvVariable", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Execute a command in the container, and return a new snapshot of the container state after execution.</p>
     * @param args Command to execute. Must be valid exec() arguments, not a shell command. Example: ["go", "run", "main.go"].<br/><br/>To run a shell command, execute the shell and pass the shell command as argument. Example: ["sh", "-c", "ls -l | grep foo"]<br/><br/>Defaults to the container's default arguments (see "defaultArgs" and "withDefaultArgs").
     * @param optArgs withExec optional arguments
     */
    public Container withExec(List<String> args, WithExecArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withExec", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Execute a command in the container, and return a new snapshot of the container state after execution.</p>
     * @param args Command to execute. Must be valid exec() arguments, not a shell command. Example: ["go", "run", "main.go"].<br/><br/>To run a shell command, execute the shell and pass the shell command as argument. Example: ["sh", "-c", "ls -l | grep foo"]<br/><br/>Defaults to the container's default arguments (see "defaultArgs" and "withDefaultArgs").
     */
    public Container withExec(List<String> args) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("args", args);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withExec", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Expose a network port. Like EXPOSE in Dockerfile (but with healthcheck support)<br/><br/>Exposed ports serve two purposes:<br/><br/>- For health checks and introspection, when running services<br/><br/>- For setting the EXPOSE OCI field when publishing the container</p>
     * @param port Port number to expose. Example: 8080
     * @param optArgs withExposedPort optional arguments
     */
    public Container withExposedPort(Integer port, WithExposedPortArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("port", port);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withExposedPort", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Expose a network port. Like EXPOSE in Dockerfile (but with healthcheck support)<br/><br/>Exposed ports serve two purposes:<br/><br/>- For health checks and introspection, when running services<br/><br/>- For setting the EXPOSE OCI field when publishing the container</p>
     * @param port Port number to expose. Example: 8080
     */
    public Container withExposedPort(Integer port) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("port", port);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withExposedPort", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a container snapshot with a file added</p>
     * @param path Path of the new file. Example: "/path/to/new-file.txt"
     * @param source File to add
     * @param optArgs withFile optional arguments
     */
    public Container withFile(String path, File source, WithFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a container snapshot with a file added</p>
     * @param path Path of the new file. Example: "/path/to/new-file.txt"
     * @param source File to add
     */
    public Container withFile(String path, File source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus the contents of the given files copied to the given path.</p>
     * @param path Location where copied files should be placed (e.g., "/src").
     * @param sources Identifiers of the files to copy.
     * @param optArgs withFiles optional arguments
     */
    public Container withFiles(String path, List<File> sources, WithFilesArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("sources", sources);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFiles", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus the contents of the given files copied to the given path.</p>
     * @param path Location where copied files should be placed (e.g., "/src").
     * @param sources Identifiers of the files to copy.
     */
    public Container withFiles(String path, List<File> sources) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("sources", sources);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFiles", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus the given label.</p>
     * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
     * @param value The value of the label (e.g., "2023-01-01T00:00:00Z").
     */
    public Container withLabel(String name, String value) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withLabel", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a cache volume mounted at the given path.</p>
     * @param path Location of the cache directory (e.g., "/root/.npm").
     * @param cache Identifier of the cache volume to mount.
     * @param optArgs withMountedCache optional arguments
     */
    public Container withMountedCache(String path, CacheVolume cache,
            WithMountedCacheArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("cache", cache);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedCache", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a cache volume mounted at the given path.</p>
     * @param path Location of the cache directory (e.g., "/root/.npm").
     * @param cache Identifier of the cache volume to mount.
     */
    public Container withMountedCache(String path, CacheVolume cache) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("cache", cache);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedCache", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a directory mounted at the given path.</p>
     * @param path Location of the mounted directory (e.g., "/mnt/directory").
     * @param source Identifier of the mounted directory.
     * @param optArgs withMountedDirectory optional arguments
     */
    public Container withMountedDirectory(String path, Directory source,
            WithMountedDirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a directory mounted at the given path.</p>
     * @param path Location of the mounted directory (e.g., "/mnt/directory").
     * @param source Identifier of the mounted directory.
     */
    public Container withMountedDirectory(String path, Directory source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a file mounted at the given path.</p>
     * @param path Location of the mounted file (e.g., "/tmp/file.txt").
     * @param source Identifier of the mounted file.
     * @param optArgs withMountedFile optional arguments
     */
    public Container withMountedFile(String path, File source, WithMountedFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a file mounted at the given path.</p>
     * @param path Location of the mounted file (e.g., "/tmp/file.txt").
     * @param source Identifier of the mounted file.
     */
    public Container withMountedFile(String path, File source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a secret mounted into a file at the given path.</p>
     * @param path Location of the secret file (e.g., "/tmp/secret.txt").
     * @param source Identifier of the secret to mount.
     * @param optArgs withMountedSecret optional arguments
     */
    public Container withMountedSecret(String path, Secret source,
            WithMountedSecretArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedSecret", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a secret mounted into a file at the given path.</p>
     * @param path Location of the secret file (e.g., "/tmp/secret.txt").
     * @param source Identifier of the secret to mount.
     */
    public Container withMountedSecret(String path, Secret source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedSecret", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a temporary directory mounted at the given path. Any writes will be ephemeral to a single withExec call; they will not be persisted to subsequent withExecs.</p>
     * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
     * @param optArgs withMountedTemp optional arguments
     */
    public Container withMountedTemp(String path, WithMountedTempArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedTemp", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a temporary directory mounted at the given path. Any writes will be ephemeral to a single withExec call; they will not be persisted to subsequent withExecs.</p>
     * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
     */
    public Container withMountedTemp(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withMountedTemp", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a file added to its filesystem with text content</p>
     * @param path Path of the new file. May be relative or absolute. Example: "README.md" or "/etc/profile"
     * @param contents Contents of the new file. Example: "Hello world!"
     * @param optArgs withNewFile optional arguments
     */
    public Container withNewFile(String path, String contents, WithNewFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("contents", contents);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a file added to its filesystem with text content</p>
     * @param path Path of the new file. May be relative or absolute. Example: "README.md" or "/etc/profile"
     * @param contents Contents of the new file. Example: "Hello world!"
     */
    public Container withNewFile(String path, String contents) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("contents", contents);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Attach credentials for future publishing to a registry. Use in combination with publish</p>
     * @param address The image address that needs authentication. Same format as "docker push". Example: "registry.dagger.io/dagger:latest"
     * @param username The username to authenticate with. Example: "alice"
     * @param secret The API key, password or token to authenticate to this registry
     */
    public Container withRegistryAuth(String address, String username, Secret secret) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("address", address);
        builder.add("username", username);
        builder.add("secret", secret);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withRegistryAuth", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Change the container's root filesystem. The previous root filesystem will be lost.</p>
     * @param directory The new root filesystem.
     */
    public Container withRootfs(Directory directory) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("directory", directory);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withRootfs", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Set a new environment variable, using a secret value</p>
     * @param name Name of the secret variable (e.g., "API_SECRET").
     * @param secret Identifier of the secret value.
     */
    public Container withSecretVariable(String name, Secret secret) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("secret", secret);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withSecretVariable", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Establish a runtime dependency on a from a container to a network service.<br/><br/>The service will be started automatically when needed and detached when it is no longer needed, executing the default command if none is set.<br/><br/>The service will be reachable from the container via the provided hostname alias.<br/><br/>The service dependency will also convey to any files or directories produced by the container.</p>
     * @param alias Hostname that will resolve to the target service (only accessible from within this container)
     * @param service The target service
     */
    public Container withServiceBinding(String alias, Service service) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("alias", alias);
        builder.add("service", service);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withServiceBinding", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a socket forwarded to the given Unix socket path.</p>
     * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
     * @param source Identifier of the socket to forward.
     * @param optArgs withUnixSocket optional arguments
     */
    public Container withUnixSocket(String path, Socket source, WithUnixSocketArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withUnixSocket", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container plus a socket forwarded to the given Unix socket path.</p>
     * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
     * @param source Identifier of the socket to forward.
     */
    public Container withUnixSocket(String path, Socket source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withUnixSocket", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with a different command user.</p>
     * @param name The user to set (e.g., "root").
     */
    public Container withUser(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withUser", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Change the container's working directory. Like WORKDIR in Dockerfile.</p>
     * @param path The path to set as the working directory (e.g., "/app").
     * @param optArgs withWorkdir optional arguments
     */
    public Container withWorkdir(String path, WithWorkdirArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withWorkdir", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Change the container's working directory. Like WORKDIR in Dockerfile.</p>
     * @param path The path to set as the working directory (e.g., "/app").
     */
    public Container withWorkdir(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withWorkdir", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container minus the given OCI annotation.</p>
     * @param name The name of the annotation.
     */
    public Container withoutAnnotation(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutAnnotation", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Remove the container's default arguments.</p>
     */
    public Container withoutDefaultArgs() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutDefaultArgs");
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a directory removed from its filesystem</p>
     * @param path Location of the directory to remove (e.g., ".github/").
     * @param optArgs withoutDirectory optional arguments
     */
    public Container withoutDirectory(String path, WithoutDirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container snapshot, with a directory removed from its filesystem</p>
     * @param path Location of the directory to remove (e.g., ".github/").
     */
    public Container withoutDirectory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutDirectory", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Reset the container's OCI entrypoint.</p>
     * @param optArgs withoutEntrypoint optional arguments
     */
    public Container withoutEntrypoint(WithoutEntrypointArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutEntrypoint", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Reset the container's OCI entrypoint.</p>
     */
    public Container withoutEntrypoint() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutEntrypoint", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container minus the given environment variable.</p>
     * @param name The name of the environment variable (e.g., "HOST").
     */
    public Container withoutEnvVariable(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutEnvVariable", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Unexpose a previously exposed port.</p>
     * @param port Port number to unexpose
     * @param optArgs withoutExposedPort optional arguments
     */
    public Container withoutExposedPort(Integer port, WithoutExposedPortArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("port", port);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutExposedPort", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Unexpose a previously exposed port.</p>
     * @param port Port number to unexpose
     */
    public Container withoutExposedPort(Integer port) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("port", port);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutExposedPort", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with the file at the given path removed.</p>
     * @param path Location of the file to remove (e.g., "/file.txt").
     * @param optArgs withoutFile optional arguments
     */
    public Container withoutFile(String path, WithoutFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with the file at the given path removed.</p>
     * @param path Location of the file to remove (e.g., "/file.txt").
     */
    public Container withoutFile(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFile", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container spanshot with specified files removed</p>
     * @param paths Paths of the files to remove. Example: ["foo.txt, "/root/.ssh/config"
     * @param optArgs withoutFiles optional arguments
     */
    public Container withoutFiles(List<String> paths, WithoutFilesArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("paths", paths);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFiles", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Return a new container spanshot with specified files removed</p>
     * @param paths Paths of the files to remove. Example: ["foo.txt, "/root/.ssh/config"
     */
    public Container withoutFiles(List<String> paths) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("paths", paths);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFiles", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container minus the given environment label.</p>
     * @param name The name of the label to remove (e.g., "org.opencontainers.artifact.created").
     */
    public Container withoutLabel(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutLabel", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container after unmounting everything at the given path.</p>
     * @param path Location of the cache directory (e.g., "/root/.npm").
     * @param optArgs withoutMount optional arguments
     */
    public Container withoutMount(String path, WithoutMountArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutMount", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container after unmounting everything at the given path.</p>
     * @param path Location of the cache directory (e.g., "/root/.npm").
     */
    public Container withoutMount(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutMount", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container without the registry authentication of a given address.</p>
     * @param address Registry's address to remove the authentication from.<br/><br/>Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
     */
    public Container withoutRegistryAuth(String address) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("address", address);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutRegistryAuth", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container minus the given environment variable containing the secret.</p>
     * @param name The name of the environment variable (e.g., "HOST").
     */
    public Container withoutSecretVariable(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutSecretVariable", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with a previously added Unix socket removed.</p>
     * @param path Location of the socket to remove (e.g., "/tmp/socket").
     * @param optArgs withoutUnixSocket optional arguments
     */
    public Container withoutUnixSocket(String path, WithoutUnixSocketArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutUnixSocket", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with a previously added Unix socket removed.</p>
     * @param path Location of the socket to remove (e.g., "/tmp/socket").
     */
    public Container withoutUnixSocket(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutUnixSocket", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this container with an unset command user.<br/><br/>Should default to root.</p>
     */
    public Container withoutUser() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutUser");
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Unset the container's working directory.<br/><br/>Should default to "/".</p>
     */
    public Container withoutWorkdir() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutWorkdir");
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Retrieves the working directory for all commands.</p>
     */
    public String workdir() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.workdir != null) {
            return workdir;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("workdir");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    public Container with(UnaryOperator<Container> containerFunc) {
        return containerFunc.apply(this);
    }

    public static class Deserializer implements JsonbDeserializer<Container> {
        @Override
        public Container deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            Container o = Dagger.dag().loadContainerFromID(new ContainerID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link Container#asService}
     *
     */
    public static class AsServiceArguments {
        private List<String> args;

        private Boolean useEntrypoint;

        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        private Boolean expand;

        private Boolean noInit;

        /**
         * Command to run instead of the container's default command (e.g., ["go", "run", "main.go"]).<br/><br/>If empty, the container's default command is used.
         */
        public AsServiceArguments withArgs(List<String> args) {
            this.args = args;
            return this;
        }

        /**
         * If the container has an entrypoint, prepend it to the args.
         */
        public AsServiceArguments withUseEntrypoint(Boolean useEntrypoint) {
            this.useEntrypoint = useEntrypoint;
            return this;
        }

        /**
         * Provides Dagger access to the executed command.
         */
        public AsServiceArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
         */
        public AsServiceArguments withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public AsServiceArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        /**
         * If set, skip the automatic init process injected into containers by default.<br/><br/>This should only be used if the user requires that their exec process be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
         */
        public AsServiceArguments withNoInit(Boolean noInit) {
            this.noInit = noInit;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (args != null) {
                builder.add("args", this.args);
            }

            if (useEntrypoint != null) {
                builder.add("useEntrypoint", this.useEntrypoint);
            }

            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

            if (noInit != null) {
                builder.add("noInit", this.noInit);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#asTarball}
     *
     */
    public static class AsTarballArguments {
        private List<Container> platformVariants;

        private ImageLayerCompression forcedCompression;

        private ImageMediaTypes mediaTypes;

        /**
         * Identifiers for other platform specific containers.<br/><br/>Used for multi-platform images.
         */
        public AsTarballArguments withPlatformVariants(List<Container> platformVariants) {
            this.platformVariants = platformVariants;
            return this;
        }

        /**
         * Force each layer of the image to use the specified compression algorithm.<br/><br/>If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
         */
        public AsTarballArguments withForcedCompression(ImageLayerCompression forcedCompression) {
            this.forcedCompression = forcedCompression;
            return this;
        }

        /**
         * Use the specified media types for the image's layers.<br/><br/>Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
         */
        public AsTarballArguments withMediaTypes(ImageMediaTypes mediaTypes) {
            this.mediaTypes = mediaTypes;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (platformVariants != null) {
                builder.add("platformVariants", this.platformVariants);
            }

            if (forcedCompression != null) {
                builder.add("forcedCompression", this.forcedCompression);
            }

            if (mediaTypes != null) {
                builder.add("mediaTypes", this.mediaTypes);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#build}
     *
     */
    public static class BuildArguments {
        private String dockerfile;

        private String target;

        private List<BuildArg> buildArgs;

        private List<Secret> secrets;

        private Boolean noInit;

        /**
         * Path to the Dockerfile to use.
         */
        public BuildArguments withDockerfile(String dockerfile) {
            this.dockerfile = dockerfile;
            return this;
        }

        /**
         * Target build stage to build.
         */
        public BuildArguments withTarget(String target) {
            this.target = target;
            return this;
        }

        /**
         * Additional build arguments.
         */
        public BuildArguments withBuildArgs(List<BuildArg> buildArgs) {
            this.buildArgs = buildArgs;
            return this;
        }

        /**
         * Secrets to pass to the build.<br/><br/>They will be mounted at /run/secrets/[secret-name] in the build container<br/><br/>They can be accessed in the Dockerfile using the "secret" mount type and mount path /run/secrets/[secret-name], e.g. RUN --mount=type=secret,id=my-secret curl [http://example.com?token=$(cat /run/secrets/my-secret)](http://example.com?token=$(cat /run/secrets/my-secret))
         */
        public BuildArguments withSecrets(List<Secret> secrets) {
            this.secrets = secrets;
            return this;
        }

        /**
         * If set, skip the automatic init process injected into containers created by RUN statements.<br/><br/>This should only be used if the user requires that their exec processes be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
         */
        public BuildArguments withNoInit(Boolean noInit) {
            this.noInit = noInit;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (dockerfile != null) {
                builder.add("dockerfile", this.dockerfile);
            }

            if (target != null) {
                builder.add("target", this.target);
            }

            if (buildArgs != null) {
                builder.add("buildArgs", this.buildArgs);
            }

            if (secrets != null) {
                builder.add("secrets", this.secrets);
            }

            if (noInit != null) {
                builder.add("noInit", this.noInit);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#directory}
     *
     */
    public static class DirectoryArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public DirectoryArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#export}
     *
     */
    public static class ExportArguments {
        private List<Container> platformVariants;

        private ImageLayerCompression forcedCompression;

        private ImageMediaTypes mediaTypes;

        private Boolean expand;

        /**
         * Identifiers for other platform specific containers.<br/><br/>Used for multi-platform image.
         */
        public ExportArguments withPlatformVariants(List<Container> platformVariants) {
            this.platformVariants = platformVariants;
            return this;
        }

        /**
         * Force each layer of the exported image to use the specified compression algorithm.<br/><br/>If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
         */
        public ExportArguments withForcedCompression(ImageLayerCompression forcedCompression) {
            this.forcedCompression = forcedCompression;
            return this;
        }

        /**
         * Use the specified media types for the exported image's layers.<br/><br/>Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
         */
        public ExportArguments withMediaTypes(ImageMediaTypes mediaTypes) {
            this.mediaTypes = mediaTypes;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public ExportArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (platformVariants != null) {
                builder.add("platformVariants", this.platformVariants);
            }

            if (forcedCompression != null) {
                builder.add("forcedCompression", this.forcedCompression);
            }

            if (mediaTypes != null) {
                builder.add("mediaTypes", this.mediaTypes);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#file}
     *
     */
    public static class FileArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public FileArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#importTarball}
     *
     */
    public static class ImportTarballArguments {
        private String tag;

        /**
         * Identifies the tag to import from the archive, if the archive bundles multiple tags.
         */
        public ImportTarballArguments withTag(String tag) {
            this.tag = tag;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (tag != null) {
                builder.add("tag", this.tag);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#publish}
     *
     */
    public static class PublishArguments {
        private List<Container> platformVariants;

        private ImageLayerCompression forcedCompression;

        private ImageMediaTypes mediaTypes;

        /**
         * Identifiers for other platform specific containers.<br/><br/>Used for multi-platform image.
         */
        public PublishArguments withPlatformVariants(List<Container> platformVariants) {
            this.platformVariants = platformVariants;
            return this;
        }

        /**
         * Force each layer of the published image to use the specified compression algorithm.<br/><br/>If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
         */
        public PublishArguments withForcedCompression(ImageLayerCompression forcedCompression) {
            this.forcedCompression = forcedCompression;
            return this;
        }

        /**
         * Use the specified media types for the published image's layers.<br/><br/>Defaults to "OCI", which is compatible with most recent registries, but "Docker" may be needed for older registries without OCI support.
         */
        public PublishArguments withMediaTypes(ImageMediaTypes mediaTypes) {
            this.mediaTypes = mediaTypes;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (platformVariants != null) {
                builder.add("platformVariants", this.platformVariants);
            }

            if (forcedCompression != null) {
                builder.add("forcedCompression", this.forcedCompression);
            }

            if (mediaTypes != null) {
                builder.add("mediaTypes", this.mediaTypes);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#terminal}
     *
     */
    public static class TerminalArguments {
        private List<String> cmd;

        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        /**
         * If set, override the container's default terminal command and invoke these command arguments instead.
         */
        public TerminalArguments withCmd(List<String> cmd) {
            this.cmd = cmd;
            return this;
        }

        /**
         * Provides Dagger access to the executed command.
         */
        public TerminalArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
         */
        public TerminalArguments withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (cmd != null) {
                builder.add("cmd", this.cmd);
            }

            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#up}
     *
     */
    public static class UpArguments {
        private List<PortForward> ports;

        private Boolean random;

        private List<String> args;

        private Boolean useEntrypoint;

        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        private Boolean expand;

        private Boolean noInit;

        /**
         * List of frontend/backend port mappings to forward.<br/><br/>Frontend is the port accepting traffic on the host, backend is the service port.
         */
        public UpArguments withPorts(List<PortForward> ports) {
            this.ports = ports;
            return this;
        }

        /**
         * Bind each tunnel port to a random port on the host.
         */
        public UpArguments withRandom(Boolean random) {
            this.random = random;
            return this;
        }

        /**
         * Command to run instead of the container's default command (e.g., ["go", "run", "main.go"]).<br/><br/>If empty, the container's default command is used.
         */
        public UpArguments withArgs(List<String> args) {
            this.args = args;
            return this;
        }

        /**
         * If the container has an entrypoint, prepend it to the args.
         */
        public UpArguments withUseEntrypoint(Boolean useEntrypoint) {
            this.useEntrypoint = useEntrypoint;
            return this;
        }

        /**
         * Provides Dagger access to the executed command.
         */
        public UpArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
         */
        public UpArguments withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public UpArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        /**
         * If set, skip the automatic init process injected into containers by default.<br/><br/>This should only be used if the user requires that their exec process be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
         */
        public UpArguments withNoInit(Boolean noInit) {
            this.noInit = noInit;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (ports != null) {
                builder.add("ports", this.ports);
            }

            if (random != null) {
                builder.add("random", this.random);
            }

            if (args != null) {
                builder.add("args", this.args);
            }

            if (useEntrypoint != null) {
                builder.add("useEntrypoint", this.useEntrypoint);
            }

            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

            if (noInit != null) {
                builder.add("noInit", this.noInit);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withDefaultTerminalCmd}
     *
     */
    public static class WithDefaultTerminalCmdArguments {
        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        /**
         * Provides Dagger access to the executed command.
         */
        public WithDefaultTerminalCmdArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
         */
        public WithDefaultTerminalCmdArguments withInsecureRootCapabilities(
                Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withDirectory}
     *
     */
    public static class WithDirectoryArguments {
        private List<String> exclude;

        private List<String> include;

        private String owner;

        private Boolean expand;

        /**
         * Patterns to exclude in the written directory (e.g. ["node_modules/**", ".gitignore", ".git/"]).
         */
        public WithDirectoryArguments withExclude(List<String> exclude) {
            this.exclude = exclude;
            return this;
        }

        /**
         * Patterns to include in the written directory (e.g. ["*.go", "go.mod", "go.sum"]).
         */
        public WithDirectoryArguments withInclude(List<String> include) {
            this.include = include;
            return this;
        }

        /**
         * A user:group to set for the directory and its contents.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithDirectoryArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithDirectoryArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (exclude != null) {
                builder.add("exclude", this.exclude);
            }

            if (include != null) {
                builder.add("include", this.include);
            }

            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withEntrypoint}
     *
     */
    public static class WithEntrypointArguments {
        private Boolean keepDefaultArgs;

        /**
         * Don't reset the default arguments when setting the entrypoint. By default it is reset, since entrypoint and default args are often tightly coupled.
         */
        public WithEntrypointArguments withKeepDefaultArgs(Boolean keepDefaultArgs) {
            this.keepDefaultArgs = keepDefaultArgs;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (keepDefaultArgs != null) {
                builder.add("keepDefaultArgs", this.keepDefaultArgs);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withEnvVariable}
     *
     */
    public static class WithEnvVariableArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value according to the current environment variables defined in the container (e.g. "/opt/bin:$PATH").
         */
        public WithEnvVariableArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withExec}
     *
     */
    public static class WithExecArguments {
        private Boolean useEntrypoint;

        private String stdin;

        private String redirectStdout;

        private String redirectStderr;

        private ReturnType expect;

        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        private Boolean expand;

        private Boolean noInit;

        /**
         * Apply the OCI entrypoint, if present, by prepending it to the args. Ignored by default.
         */
        public WithExecArguments withUseEntrypoint(Boolean useEntrypoint) {
            this.useEntrypoint = useEntrypoint;
            return this;
        }

        /**
         * Content to write to the command's standard input. Example: "Hello world")
         */
        public WithExecArguments withStdin(String stdin) {
            this.stdin = stdin;
            return this;
        }

        /**
         * Redirect the command's standard output to a file in the container. Example: "./stdout.txt"
         */
        public WithExecArguments withRedirectStdout(String redirectStdout) {
            this.redirectStdout = redirectStdout;
            return this;
        }

        /**
         * Like redirectStdout, but for standard error
         */
        public WithExecArguments withRedirectStderr(String redirectStderr) {
            this.redirectStderr = redirectStderr;
            return this;
        }

        /**
         * Exit codes this command is allowed to exit with without error
         */
        public WithExecArguments withExpect(ReturnType expect) {
            this.expect = expect;
            return this;
        }

        /**
         * Provides Dagger access to the executed command.
         */
        public WithExecArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. Like --privileged in Docker<br/><br/>DANGER: this grants the command full access to the host system. Only use when 1) you trust the command being executed and 2) you specifically need this level of access.
         */
        public WithExecArguments withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithExecArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        /**
         * Skip the automatic init process injected into containers by default.<br/><br/>Only use this if you specifically need the command to be pid 1 in the container. Otherwise it may result in unexpected behavior. If you're not sure, you don't need this.
         */
        public WithExecArguments withNoInit(Boolean noInit) {
            this.noInit = noInit;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (useEntrypoint != null) {
                builder.add("useEntrypoint", this.useEntrypoint);
            }

            if (stdin != null) {
                builder.add("stdin", this.stdin);
            }

            if (redirectStdout != null) {
                builder.add("redirectStdout", this.redirectStdout);
            }

            if (redirectStderr != null) {
                builder.add("redirectStderr", this.redirectStderr);
            }

            if (expect != null) {
                builder.add("expect", this.expect);
            }

            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

            if (noInit != null) {
                builder.add("noInit", this.noInit);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withExposedPort}
     *
     */
    public static class WithExposedPortArguments {
        private NetworkProtocol protocol;

        private String description;

        private Boolean experimentalSkipHealthcheck;

        /**
         * Network protocol. Example: "tcp"
         */
        public WithExposedPortArguments withProtocol(NetworkProtocol protocol) {
            this.protocol = protocol;
            return this;
        }

        /**
         * Port description. Example: "payment API endpoint"
         */
        public WithExposedPortArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         * Skip the health check when run as a service.
         */
        public WithExposedPortArguments withExperimentalSkipHealthcheck(
                Boolean experimentalSkipHealthcheck) {
            this.experimentalSkipHealthcheck = experimentalSkipHealthcheck;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (protocol != null) {
                builder.add("protocol", this.protocol);
            }

            if (description != null) {
                builder.add("description", this.description);
            }

            if (experimentalSkipHealthcheck != null) {
                builder.add("experimentalSkipHealthcheck", this.experimentalSkipHealthcheck);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withFile}
     *
     */
    public static class WithFileArguments {
        private Integer permissions;

        private String owner;

        private Boolean expand;

        /**
         * Permissions of the new file. Example: 0600
         */
        public WithFileArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        /**
         * A user:group to set for the file.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithFileArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithFileArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withFiles}
     *
     */
    public static class WithFilesArguments {
        private Integer permissions;

        private String owner;

        private Boolean expand;

        /**
         * Permission given to the copied files (e.g., 0600).
         */
        public WithFilesArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        /**
         * A user:group to set for the files.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithFilesArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithFilesArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withMountedCache}
     *
     */
    public static class WithMountedCacheArguments {
        private Directory source;

        private CacheSharingMode sharing;

        private String owner;

        private Boolean expand;

        /**
         * Identifier of the directory to use as the cache volume's root.
         */
        public WithMountedCacheArguments withSource(Directory source) {
            this.source = source;
            return this;
        }

        /**
         * Sharing mode of the cache volume.
         */
        public WithMountedCacheArguments withSharing(CacheSharingMode sharing) {
            this.sharing = sharing;
            return this;
        }

        /**
         * A user:group to set for the mounted cache directory.<br/><br/>Note that this changes the ownership of the specified mount along with the initial filesystem provided by source (if any). It does not have any effect if/when the cache has already been created.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithMountedCacheArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithMountedCacheArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (source != null) {
                builder.add("source", this.source);
            }

            if (sharing != null) {
                builder.add("sharing", this.sharing);
            }

            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withMountedDirectory}
     *
     */
    public static class WithMountedDirectoryArguments {
        private String owner;

        private Boolean expand;

        /**
         * A user:group to set for the mounted directory and its contents.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithMountedDirectoryArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithMountedDirectoryArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withMountedFile}
     *
     */
    public static class WithMountedFileArguments {
        private String owner;

        private Boolean expand;

        /**
         * A user or user:group to set for the mounted file.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithMountedFileArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithMountedFileArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withMountedSecret}
     *
     */
    public static class WithMountedSecretArguments {
        private String owner;

        private Integer mode;

        private Boolean expand;

        /**
         * A user:group to set for the mounted secret.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithMountedSecretArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Permission given to the mounted secret (e.g., 0600).<br/><br/>This option requires an owner to be set to be active.
         */
        public WithMountedSecretArguments withMode(Integer mode) {
            this.mode = mode;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithMountedSecretArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (mode != null) {
                builder.add("mode", this.mode);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withMountedTemp}
     *
     */
    public static class WithMountedTempArguments {
        private Integer size;

        private Boolean expand;

        /**
         * Size of the temporary directory in bytes.
         */
        public WithMountedTempArguments withSize(Integer size) {
            this.size = size;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithMountedTempArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (size != null) {
                builder.add("size", this.size);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withNewFile}
     *
     */
    public static class WithNewFileArguments {
        private Integer permissions;

        private String owner;

        private Boolean expand;

        /**
         * Permissions of the new file. Example: 0600
         */
        public WithNewFileArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        /**
         * A user:group to set for the file.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithNewFileArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithNewFileArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withUnixSocket}
     *
     */
    public static class WithUnixSocketArguments {
        private String owner;

        private Boolean expand;

        /**
         * A user:group to set for the mounted socket.<br/><br/>The user and group can either be an ID (1000:1000) or a name (foo:bar).<br/><br/>If the group is omitted, it defaults to the same as the user.
         */
        public WithUnixSocketArguments withOwner(String owner) {
            this.owner = owner;
            return this;
        }

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithUnixSocketArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (owner != null) {
                builder.add("owner", this.owner);
            }

            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withWorkdir}
     *
     */
    public static class WithWorkdirArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithWorkdirArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutDirectory}
     *
     */
    public static class WithoutDirectoryArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithoutDirectoryArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutEntrypoint}
     *
     */
    public static class WithoutEntrypointArguments {
        private Boolean keepDefaultArgs;

        /**
         * Don't remove the default arguments when unsetting the entrypoint.
         */
        public WithoutEntrypointArguments withKeepDefaultArgs(Boolean keepDefaultArgs) {
            this.keepDefaultArgs = keepDefaultArgs;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (keepDefaultArgs != null) {
                builder.add("keepDefaultArgs", this.keepDefaultArgs);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutExposedPort}
     *
     */
    public static class WithoutExposedPortArguments {
        private NetworkProtocol protocol;

        /**
         * Port protocol to unexpose
         */
        public WithoutExposedPortArguments withProtocol(NetworkProtocol protocol) {
            this.protocol = protocol;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (protocol != null) {
                builder.add("protocol", this.protocol);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutFile}
     *
     */
    public static class WithoutFileArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithoutFileArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutFiles}
     *
     */
    public static class WithoutFilesArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of paths according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
         */
        public WithoutFilesArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutMount}
     *
     */
    public static class WithoutMountArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithoutMountArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Container#withoutUnixSocket}
     *
     */
    public static class WithoutUnixSocketArguments {
        private Boolean expand;

        /**
         * Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
         */
        public WithoutUnixSocketArguments withExpand(Boolean expand) {
            this.expand = expand;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (expand != null) {
                builder.add("expand", this.expand);
            }

                    return builder.build();
        }
    }
}
