// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.function.UnaryOperator;

/**
 * A directory.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(Directory.Deserializer.class)
public class Directory implements IDAble<DirectoryID> {
    private QueryBuilder queryBuilder;

    private String digest;

    private String export;

    private DirectoryID id;

    private String name;

    private DirectoryID sync;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected Directory() {
    }

    Directory(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Converts this directory to a local git repository</p>
     */
    public GitRepository asGit() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asGit");
        return new GitRepository(nextQueryBuilder);
    }

    /**
     * <p>Load the directory as a Dagger module source</p>
     * @param optArgs asModule optional arguments
     */
    public Module asModule(AsModuleArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asModule", fieldArgs);
        return new Module(nextQueryBuilder);
    }

    /**
     * <p>Load the directory as a Dagger module source</p>
     */
    public Module asModule() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asModule", fieldArgs);
        return new Module(nextQueryBuilder);
    }

    /**
     * <p>Load the directory as a Dagger module source</p>
     * @param optArgs asModuleSource optional arguments
     */
    public ModuleSource asModuleSource(AsModuleSourceArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asModuleSource", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Load the directory as a Dagger module source</p>
     */
    public ModuleSource asModuleSource() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asModuleSource", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Return the difference between this directory and an another directory. The difference is encoded as a directory.</p>
     * @param other The directory to compare against
     */
    public Directory diff(Directory other) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("other", other);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("diff", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return the directory's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.</p>
     */
    public String digest() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.digest != null) {
            return digest;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("digest");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves a directory at the given path.</p>
     * @param path Location of the directory to retrieve. Example: "/src"
     */
    public Directory directory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Use Dockerfile compatibility to build a container from this directory. Only use this function for Dockerfile compatibility. Otherwise use the native Container type directly, it is feature-complete and supports all Dockerfile features.</p>
     * @param optArgs dockerBuild optional arguments
     */
    public Container dockerBuild(DockerBuildArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("dockerBuild", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Use Dockerfile compatibility to build a container from this directory. Only use this function for Dockerfile compatibility. Otherwise use the native Container type directly, it is feature-complete and supports all Dockerfile features.</p>
     */
    public Container dockerBuild() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("dockerBuild", fieldArgs);
        return new Container(nextQueryBuilder);
    }

    /**
     * <p>Returns a list of files and directories at the given path.</p>
     * @param optArgs entries optional arguments
     */
    public List<String> entries(EntriesArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("entries", fieldArgs);
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>Returns a list of files and directories at the given path.</p>
     */
    public List<String> entries() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("entries", fieldArgs);
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>Writes the contents of the directory to a path on the host.</p>
     * @param path Location of the copied directory (e.g., "logs/").
     * @param optArgs export optional arguments
     */
    public String export(String path, ExportArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Writes the contents of the directory to a path on the host.</p>
     * @param path Location of the copied directory (e.g., "logs/").
     */
    public String export(String path) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieve a file at the given path.</p>
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    public File file(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("file", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with some paths included or excluded</p>
     * @param optArgs filter optional arguments
     */
    public Directory filter(FilterArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("filter", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with some paths included or excluded</p>
     */
    public Directory filter() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("filter", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Returns a list of files and directories that matche the given pattern.</p>
     * @param pattern Pattern to match (e.g., "*.md").
     */
    public List<String> glob(String pattern) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("pattern", pattern);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("glob", fieldArgs);
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>A unique identifier for this Directory.</p>
     */
    public DirectoryID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(DirectoryID.class);
    }

    /**
     * <p>Returns the name of the directory.</p>
     */
    public String name() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.name != null) {
            return name;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("name");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Force evaluation in the engine.</p>
     */
    public Directory sync() throws InterruptedException, ExecutionException, DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sync");
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Opens an interactive terminal in new container with this directory mounted inside.</p>
     * @param optArgs terminal optional arguments
     */
    public Directory terminal(TerminalArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("terminal", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Opens an interactive terminal in new container with this directory mounted inside.</p>
     */
    public Directory terminal() {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("terminal", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a directory added</p>
     * @param path Location of the written directory (e.g., "/src/").
     * @param directory Identifier of the directory to copy.
     * @param optArgs withDirectory optional arguments
     */
    public Directory withDirectory(String path, Directory directory,
            WithDirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("directory", directory);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDirectory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a directory added</p>
     * @param path Location of the written directory (e.g., "/src/").
     * @param directory Identifier of the directory to copy.
     */
    public Directory withDirectory(String path, Directory directory) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("directory", directory);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDirectory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus the contents of the given file copied to the given path.</p>
     * @param path Location of the copied file (e.g., "/file.txt").
     * @param source Identifier of the file to copy.
     * @param optArgs withFile optional arguments
     */
    public Directory withFile(String path, File source, WithFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFile", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus the contents of the given file copied to the given path.</p>
     * @param path Location of the copied file (e.g., "/file.txt").
     * @param source Identifier of the file to copy.
     */
    public Directory withFile(String path, File source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFile", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus the contents of the given files copied to the given path.</p>
     * @param path Location where copied files should be placed (e.g., "/src").
     * @param sources Identifiers of the files to copy.
     * @param optArgs withFiles optional arguments
     */
    public Directory withFiles(String path, List<File> sources, WithFilesArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("sources", sources);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFiles", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus the contents of the given files copied to the given path.</p>
     * @param path Location where copied files should be placed (e.g., "/src").
     * @param sources Identifiers of the files to copy.
     */
    public Directory withFiles(String path, List<File> sources) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("sources", sources);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFiles", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus a new directory created at the given path.</p>
     * @param path Location of the directory created (e.g., "/logs").
     * @param optArgs withNewDirectory optional arguments
     */
    public Directory withNewDirectory(String path, WithNewDirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewDirectory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory plus a new directory created at the given path.</p>
     * @param path Location of the directory created (e.g., "/logs").
     */
    public Directory withNewDirectory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewDirectory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a new file added</p>
     * @param path Path of the new file. Example: "foo/bar.txt"
     * @param contents Contents of the new file. Example: "Hello world!"
     * @param optArgs withNewFile optional arguments
     */
    public Directory withNewFile(String path, String contents, WithNewFileArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("contents", contents);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewFile", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a new file added</p>
     * @param path Path of the new file. Example: "foo/bar.txt"
     * @param contents Contents of the new file. Example: "Hello world!"
     */
    public Directory withNewFile(String path, String contents) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        builder.add("contents", contents);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withNewFile", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this directory with all file/dir timestamps set to the given time.</p>
     * @param timestamp Timestamp to set dir/files in.<br/><br/>Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    public Directory withTimestamps(Integer timestamp) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("timestamp", timestamp);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withTimestamps", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a subdirectory removed</p>
     * @param path Path of the subdirectory to remove. Example: ".github/workflows"
     */
    public Directory withoutDirectory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutDirectory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with a file removed</p>
     * @param path Path of the file to remove (e.g., "/file.txt").
     */
    public Directory withoutFile(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFile", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Return a snapshot with files removed</p>
     * @param paths Paths of the files to remove (e.g., ["/file.txt"]).
     */
    public Directory withoutFiles(List<String> paths) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("paths", paths);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutFiles", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    public Directory with(UnaryOperator<Directory> directoryFunc) {
        return directoryFunc.apply(this);
    }

    public static class Deserializer implements JsonbDeserializer<Directory> {
        @Override
        public Directory deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            Directory o = Dagger.dag().loadDirectoryFromID(new DirectoryID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link Directory#asModule}
     *
     */
    public static class AsModuleArguments {
        private String sourceRootPath;

        /**
         * An optional subpath of the directory which contains the module's configuration file.<br/><br/>If not set, the module source code is loaded from the root of the directory.
         */
        public AsModuleArguments withSourceRootPath(String sourceRootPath) {
            this.sourceRootPath = sourceRootPath;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (sourceRootPath != null) {
                builder.add("sourceRootPath", this.sourceRootPath);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#asModuleSource}
     *
     */
    public static class AsModuleSourceArguments {
        private String sourceRootPath;

        /**
         * An optional subpath of the directory which contains the module's configuration file.<br/><br/>If not set, the module source code is loaded from the root of the directory.
         */
        public AsModuleSourceArguments withSourceRootPath(String sourceRootPath) {
            this.sourceRootPath = sourceRootPath;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (sourceRootPath != null) {
                builder.add("sourceRootPath", this.sourceRootPath);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#dockerBuild}
     *
     */
    public static class DockerBuildArguments {
        private Platform platform;

        private String dockerfile;

        private String target;

        private List<BuildArg> buildArgs;

        private List<Secret> secrets;

        private Boolean noInit;

        /**
         * The platform to build.
         */
        public DockerBuildArguments withPlatform(Platform platform) {
            this.platform = platform;
            return this;
        }

        /**
         * Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
         */
        public DockerBuildArguments withDockerfile(String dockerfile) {
            this.dockerfile = dockerfile;
            return this;
        }

        /**
         * Target build stage to build.
         */
        public DockerBuildArguments withTarget(String target) {
            this.target = target;
            return this;
        }

        /**
         * Build arguments to use in the build.
         */
        public DockerBuildArguments withBuildArgs(List<BuildArg> buildArgs) {
            this.buildArgs = buildArgs;
            return this;
        }

        /**
         * Secrets to pass to the build.<br/><br/>They will be mounted at /run/secrets/[secret-name].
         */
        public DockerBuildArguments withSecrets(List<Secret> secrets) {
            this.secrets = secrets;
            return this;
        }

        /**
         * If set, skip the automatic init process injected into containers created by RUN statements.<br/><br/>This should only be used if the user requires that their exec processes be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
         */
        public DockerBuildArguments withNoInit(Boolean noInit) {
            this.noInit = noInit;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (platform != null) {
                builder.add("platform", this.platform);
            }

            if (dockerfile != null) {
                builder.add("dockerfile", this.dockerfile);
            }

            if (target != null) {
                builder.add("target", this.target);
            }

            if (buildArgs != null) {
                builder.add("buildArgs", this.buildArgs);
            }

            if (secrets != null) {
                builder.add("secrets", this.secrets);
            }

            if (noInit != null) {
                builder.add("noInit", this.noInit);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#entries}
     *
     */
    public static class EntriesArguments {
        private String path;

        /**
         * Location of the directory to look at (e.g., "/src").
         */
        public EntriesArguments withPath(String path) {
            this.path = path;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (path != null) {
                builder.add("path", this.path);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#export}
     *
     */
    public static class ExportArguments {
        private Boolean wipe;

        /**
         * If true, then the host directory will be wiped clean before exporting so that it exactly matches the directory being exported; this means it will delete any files on the host that aren't in the exported dir. If false (the default), the contents of the directory will be merged with any existing contents of the host directory, leaving any existing files on the host that aren't in the exported directory alone.
         */
        public ExportArguments withWipe(Boolean wipe) {
            this.wipe = wipe;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (wipe != null) {
                builder.add("wipe", this.wipe);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#filter}
     *
     */
    public static class FilterArguments {
        private List<String> exclude;

        private List<String> include;

        /**
         * If set, paths matching one of these glob patterns is excluded from the new snapshot. Example: ["node_modules/", ".git*", ".env"]
         */
        public FilterArguments withExclude(List<String> exclude) {
            this.exclude = exclude;
            return this;
        }

        /**
         * If set, only paths matching one of these glob patterns is included in the new snapshot. Example: (e.g., ["app/", "package.*"]).
         */
        public FilterArguments withInclude(List<String> include) {
            this.include = include;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (exclude != null) {
                builder.add("exclude", this.exclude);
            }

            if (include != null) {
                builder.add("include", this.include);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#terminal}
     *
     */
    public static class TerminalArguments {
        private List<String> cmd;

        private Boolean experimentalPrivilegedNesting;

        private Boolean insecureRootCapabilities;

        private Container container;

        /**
         * If set, override the container's default terminal command and invoke these command arguments instead.
         */
        public TerminalArguments withCmd(List<String> cmd) {
            this.cmd = cmd;
            return this;
        }

        /**
         * Provides Dagger access to the executed command.
         */
        public TerminalArguments withExperimentalPrivilegedNesting(
                Boolean experimentalPrivilegedNesting) {
            this.experimentalPrivilegedNesting = experimentalPrivilegedNesting;
            return this;
        }

        /**
         * Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
         */
        public TerminalArguments withInsecureRootCapabilities(Boolean insecureRootCapabilities) {
            this.insecureRootCapabilities = insecureRootCapabilities;
            return this;
        }

        /**
         * If set, override the default container used for the terminal.
         */
        public TerminalArguments withContainer(Container container) {
            this.container = container;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (cmd != null) {
                builder.add("cmd", this.cmd);
            }

            if (experimentalPrivilegedNesting != null) {
                builder.add("experimentalPrivilegedNesting", this.experimentalPrivilegedNesting);
            }

            if (insecureRootCapabilities != null) {
                builder.add("insecureRootCapabilities", this.insecureRootCapabilities);
            }

            if (container != null) {
                builder.add("container", this.container);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#withDirectory}
     *
     */
    public static class WithDirectoryArguments {
        private List<String> exclude;

        private List<String> include;

        /**
         * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
         */
        public WithDirectoryArguments withExclude(List<String> exclude) {
            this.exclude = exclude;
            return this;
        }

        /**
         * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
         */
        public WithDirectoryArguments withInclude(List<String> include) {
            this.include = include;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (exclude != null) {
                builder.add("exclude", this.exclude);
            }

            if (include != null) {
                builder.add("include", this.include);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#withFile}
     *
     */
    public static class WithFileArguments {
        private Integer permissions;

        /**
         * Permission given to the copied file (e.g., 0600).
         */
        public WithFileArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#withFiles}
     *
     */
    public static class WithFilesArguments {
        private Integer permissions;

        /**
         * Permission given to the copied files (e.g., 0600).
         */
        public WithFilesArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#withNewDirectory}
     *
     */
    public static class WithNewDirectoryArguments {
        private Integer permissions;

        /**
         * Permission granted to the created directory (e.g., 0777).
         */
        public WithNewDirectoryArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Directory#withNewFile}
     *
     */
    public static class WithNewFileArguments {
        private Integer permissions;

        /**
         * Permissions of the new file. Example: 0600
         */
        public WithNewFileArguments withPermissions(Integer permissions) {
            this.permissions = permissions;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (permissions != null) {
                builder.add("permissions", this.permissions);
            }

                    return builder.build();
        }
    }
}
