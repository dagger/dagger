// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.concurrent.ExecutionException;

/**
 * A file.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(File.Deserializer.class)
public class File implements IDAble<FileID> {
    private QueryBuilder queryBuilder;

    private String contents;

    private String digest;

    private String export;

    private FileID id;

    private String name;

    private Integer size;

    private FileID sync;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected File() {
    }

    File(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Retrieves the contents of the file.</p>
     */
    public String contents() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.contents != null) {
            return contents;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("contents");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Return the file's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.</p>
     * @param optArgs digest optional arguments
     */
    public String digest(DigestArguments optArgs) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.digest != null) {
            return digest;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("digest", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Return the file's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.</p>
     */
    public String digest() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.digest != null) {
            return digest;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("digest", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Writes the file to a file path on the host.</p>
     * @param path Location of the written directory (e.g., "output.txt").
     * @param optArgs export optional arguments
     */
    public String export(String path, ExportArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Writes the file to a file path on the host.</p>
     * @param path Location of the written directory (e.g., "output.txt").
     */
    public String export(String path) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.export != null) {
            return export;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("export", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>A unique identifier for this File.</p>
     */
    public FileID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(FileID.class);
    }

    /**
     * <p>Retrieves the name of the file.</p>
     */
    public String name() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.name != null) {
            return name;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("name");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves the size of the file, in bytes.</p>
     */
    public Integer size() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.size != null) {
            return size;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("size");
        return nextQueryBuilder.executeQuery(java.lang.Integer.class);
    }

    /**
     * <p>Force evaluation in the engine.</p>
     */
    public File sync() throws InterruptedException, ExecutionException, DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sync");
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Retrieves this file with its name set to the given name.</p>
     * @param name Name to set file to.
     */
    public File withName(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withName", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>Retrieves this file with its created/modified timestamps set to the given time.</p>
     * @param timestamp Timestamp to set dir/files in.<br/><br/>Formatted in seconds following Unix epoch (e.g., 1672531199).
     */
    public File withTimestamps(Integer timestamp) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("timestamp", timestamp);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withTimestamps", fieldArgs);
        return new File(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<File> {
        @Override
        public File deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            File o = Dagger.dag().loadFileFromID(new FileID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link File#digest}
     *
     */
    public static class DigestArguments {
        private Boolean excludeMetadata;

        /**
         * If true, exclude metadata from the digest.
         */
        public DigestArguments withExcludeMetadata(Boolean excludeMetadata) {
            this.excludeMetadata = excludeMetadata;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (excludeMetadata != null) {
                builder.add("excludeMetadata", this.excludeMetadata);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link File#export}
     *
     */
    public static class ExportArguments {
        private Boolean allowParentDirPath;

        /**
         * If allowParentDirPath is true, the path argument can be a directory path, in which case the file will be created in that directory.
         */
        public ExportArguments withAllowParentDirPath(Boolean allowParentDirPath) {
            this.allowParentDirPath = allowParentDirPath;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (allowParentDirPath != null) {
                builder.add("allowParentDirPath", this.allowParentDirPath);
            }

                    return builder.build();
        }
    }
}
