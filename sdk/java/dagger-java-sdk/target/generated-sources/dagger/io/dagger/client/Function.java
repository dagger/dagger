// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * Function represents a resolver provided by a Module.<br/><br/>A function always evaluates against a parent object and is given a set of named arguments.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(Function.Deserializer.class)
public class Function implements IDAble<FunctionID> {
    private QueryBuilder queryBuilder;

    private String description;

    private FunctionID id;

    private String name;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected Function() {
    }

    Function(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Arguments accepted by the function, if any.</p>
     */
    public List<FunctionArg> args() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("args");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(FunctionArg.class);
        return builders.stream().map(qb -> new FunctionArg(qb)).toList();
    }

    /**
     * <p>A doc string for the function, if any.</p>
     */
    public String description() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.description != null) {
            return description;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("description");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>A unique identifier for this Function.</p>
     */
    public FunctionID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(FunctionID.class);
    }

    /**
     * <p>The name of the function.</p>
     */
    public String name() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.name != null) {
            return name;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("name");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The type returned by the function.</p>
     */
    public TypeDef returnType() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("returnType");
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>The location of this function declaration.</p>
     */
    public SourceMap sourceMap() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sourceMap");
        return new SourceMap(nextQueryBuilder);
    }

    /**
     * <p>Returns the function with the provided argument</p>
     * @param name The name of the argument
     * @param typeDef The type of the argument
     * @param optArgs withArg optional arguments
     */
    public Function withArg(String name, TypeDef typeDef, WithArgArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("typeDef", typeDef);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withArg", fieldArgs);
        return new Function(nextQueryBuilder);
    }

    /**
     * <p>Returns the function with the provided argument</p>
     * @param name The name of the argument
     * @param typeDef The type of the argument
     */
    public Function withArg(String name, TypeDef typeDef) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("typeDef", typeDef);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withArg", fieldArgs);
        return new Function(nextQueryBuilder);
    }

    /**
     * <p>Returns the function with the given doc string.</p>
     * @param description The doc string to set.
     */
    public Function withDescription(String description) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("description", description);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDescription", fieldArgs);
        return new Function(nextQueryBuilder);
    }

    /**
     * <p>Returns the function with the given source map.</p>
     * @param sourceMap The source map for the function definition.
     */
    public Function withSourceMap(SourceMap sourceMap) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("sourceMap", sourceMap);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withSourceMap", fieldArgs);
        return new Function(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<Function> {
        @Override
        public Function deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            Function o = Dagger.dag().loadFunctionFromID(new FunctionID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link Function#withArg}
     *
     */
    public static class WithArgArguments {
        private String description;

        private JSON defaultValue;

        private String defaultPath;

        private List<String> ignore;

        private SourceMap sourceMap;

        /**
         * A doc string for the argument, if any
         */
        public WithArgArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         * A default value to use for this argument if not explicitly set by the caller, if any
         */
        public WithArgArguments withDefaultValue(JSON defaultValue) {
            this.defaultValue = defaultValue;
            return this;
        }

        /**
         * If the argument is a Directory or File type, default to load path from context directory, relative to root directory.
         */
        public WithArgArguments withDefaultPath(String defaultPath) {
            this.defaultPath = defaultPath;
            return this;
        }

        /**
         * Patterns to ignore when loading the contextual argument value.
         */
        public WithArgArguments withIgnore(List<String> ignore) {
            this.ignore = ignore;
            return this;
        }

        /**
         *
         */
        public WithArgArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (defaultValue != null) {
                builder.add("defaultValue", this.defaultValue);
            }

            if (defaultPath != null) {
                builder.add("defaultPath", this.defaultPath);
            }

            if (ignore != null) {
                builder.add("ignore", this.ignore);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }
}
