// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * A git repository.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(GitRepository.Deserializer.class)
public class GitRepository implements IDAble<GitRepositoryID> {
    private QueryBuilder queryBuilder;

    private GitRepositoryID id;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected GitRepository() {
    }

    GitRepository(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Returns details of a branch.</p>
     * @param name Branch's name (e.g., "main").
     */
    public GitRef branch(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("branch", fieldArgs);
        return new GitRef(nextQueryBuilder);
    }

    /**
     * <p>Returns details of a commit.</p>
     * @param id Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
     */
    public GitRef commit(String id) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("id", id);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("commit", fieldArgs);
        return new GitRef(nextQueryBuilder);
    }

    /**
     * <p>Returns details for HEAD.</p>
     */
    public GitRef head() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("head");
        return new GitRef(nextQueryBuilder);
    }

    /**
     * <p>A unique identifier for this GitRepository.</p>
     */
    public GitRepositoryID id() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(GitRepositoryID.class);
    }

    /**
     * <p>Returns details of a ref.</p>
     * @param name Ref's name (can be a commit identifier, a tag name, a branch name, or a fully-qualified ref).
     */
    public GitRef ref(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("ref", fieldArgs);
        return new GitRef(nextQueryBuilder);
    }

    /**
     * <p>Returns details of a tag.</p>
     * @param name Tag's name (e.g., "v0.3.9").
     */
    public GitRef tag(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("tag", fieldArgs);
        return new GitRef(nextQueryBuilder);
    }

    /**
     * <p>tags that match any of the given glob patterns.</p>
     * @param optArgs tags optional arguments
     */
    public List<String> tags(TagsArguments optArgs) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("tags", fieldArgs);
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>tags that match any of the given glob patterns.</p>
     */
    public List<String> tags() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("tags", fieldArgs);
        return nextQueryBuilder.executeListQuery(String.class);
    }

    /**
     * <p>Header to authenticate the remote with.</p>
     * @param header Secret used to populate the Authorization HTTP header
     */
    public GitRepository withAuthHeader(Secret header) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("header", header);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withAuthHeader", fieldArgs);
        return new GitRepository(nextQueryBuilder);
    }

    /**
     * <p>Token to authenticate the remote with.</p>
     * @param token Secret used to populate the password during basic HTTP Authorization
     */
    public GitRepository withAuthToken(Secret token) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("token", token);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withAuthToken", fieldArgs);
        return new GitRepository(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<GitRepository> {
        @Override
        public GitRepository deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            GitRepository o = Dagger.dag().loadGitRepositoryFromID(new GitRepositoryID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link GitRepository#tags}
     *
     */
    public static class TagsArguments {
        private List<String> patterns;

        /**
         * Glob patterns (e.g., "refs/tags/v*").
         */
        public TagsArguments withPatterns(List<String> patterns) {
            this.patterns = patterns;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (patterns != null) {
                builder.add("patterns", this.patterns);
            }

                    return builder.build();
        }
    }
}
