// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.Deprecated;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * Information about the host environment.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(Host.Deserializer.class)
public class Host implements IDAble<HostID> {
    private QueryBuilder queryBuilder;

    private HostID id;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected Host() {
    }

    Host(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Accesses a directory on the host.</p>
     * @param path Location of the directory to access (e.g., ".").
     * @param optArgs directory optional arguments
     */
    public Directory directory(String path, DirectoryArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Accesses a directory on the host.</p>
     * @param path Location of the directory to access (e.g., ".").
     */
    public Directory directory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>Accesses a file on the host.</p>
     * @param path Location of the file to retrieve (e.g., "README.md").
     */
    public File file(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("file", fieldArgs);
        return new File(nextQueryBuilder);
    }

    /**
     * <p>A unique identifier for this Host.</p>
     */
    public HostID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(HostID.class);
    }

    /**
     * <p>Creates a service that forwards traffic to a specified address via the host.</p>
     * @param ports Ports to expose via the service, forwarding through the host network.<br/><br/>If a port's frontend is unspecified or 0, it defaults to the same as the backend port.<br/><br/>An empty set of ports is not valid; an error will be returned.
     * @param optArgs service optional arguments
     */
    public Service service(List<PortForward> ports, ServiceArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("ports", ports);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("service", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Creates a service that forwards traffic to a specified address via the host.</p>
     * @param ports Ports to expose via the service, forwarding through the host network.<br/><br/>If a port's frontend is unspecified or 0, it defaults to the same as the backend port.<br/><br/>An empty set of ports is not valid; an error will be returned.
     */
    public Service service(List<PortForward> ports) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("ports", ports);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("service", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Sets a secret given a user-defined name and the file path on the host, and returns the secret.<br/><br/>The file is limited to a size of 512000 bytes.</p>@deprecated setSecretFile is superceded by use of the secret API with file:// URIs
     *
     * @param name The user defined name for this secret.
     * @param path Location of the file to set as a secret.
     */
    @Deprecated
    public Secret setSecretFile(String name, String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("setSecretFile", fieldArgs);
        return new Secret(nextQueryBuilder);
    }

    /**
     * <p>Creates a tunnel that forwards traffic from the host to a service.</p>
     * @param service Service to send traffic from the tunnel.
     * @param optArgs tunnel optional arguments
     */
    public Service tunnel(Service service, TunnelArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("service", service);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("tunnel", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Creates a tunnel that forwards traffic from the host to a service.</p>
     * @param service Service to send traffic from the tunnel.
     */
    public Service tunnel(Service service) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("service", service);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("tunnel", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    /**
     * <p>Accesses a Unix socket on the host.</p>
     * @param path Location of the Unix socket (e.g., "/var/run/docker.sock").
     */
    public Socket unixSocket(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("unixSocket", fieldArgs);
        return new Socket(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<Host> {
        @Override
        public Host deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            Host o = Dagger.dag().loadHostFromID(new HostID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link Host#directory}
     *
     */
    public static class DirectoryArguments {
        private List<String> exclude;

        private List<String> include;

        /**
         * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
         */
        public DirectoryArguments withExclude(List<String> exclude) {
            this.exclude = exclude;
            return this;
        }

        /**
         * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
         */
        public DirectoryArguments withInclude(List<String> include) {
            this.include = include;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (exclude != null) {
                builder.add("exclude", this.exclude);
            }

            if (include != null) {
                builder.add("include", this.include);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Host#service}
     *
     */
    public static class ServiceArguments {
        private String host;

        /**
         * Upstream host to forward traffic to.
         */
        public ServiceArguments withHost(String host) {
            this.host = host;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (host != null) {
                builder.add("host", this.host);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Host#tunnel}
     *
     */
    public static class TunnelArguments {
        private List<PortForward> ports;

        private Boolean _native;

        /**
         * Configure explicit port forwarding rules for the tunnel.<br/><br/>If a port's frontend is unspecified or 0, a random port will be chosen by the host.<br/><br/>If no ports are given, all of the service's ports are forwarded. If native is true, each port maps to the same port on the host. If native is false, each port maps to a random port chosen by the host.<br/><br/>If ports are given and native is true, the ports are additive.
         */
        public TunnelArguments withPorts(List<PortForward> ports) {
            this.ports = ports;
            return this;
        }

        /**
         * Map each service port to the same port on the host, as if the service were running natively.<br/><br/>Note: enabling may result in port conflicts.
         */
        public TunnelArguments withNative(Boolean _native) {
            this._native = _native;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (ports != null) {
                builder.add("ports", this.ports);
            }

            if (_native != null) {
                builder.add("native", this._native);
            }

                    return builder.build();
        }
    }
}
