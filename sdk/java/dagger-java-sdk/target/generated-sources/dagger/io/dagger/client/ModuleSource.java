// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(ModuleSource.Deserializer.class)
public class ModuleSource implements IDAble<ModuleSourceID> {
    private QueryBuilder queryBuilder;

    private String asString;

    private String cloneRef;

    private String commit;

    private Boolean configExists;

    private String digest;

    private String engineVersion;

    private String htmlRepoURL;

    private String htmlURL;

    private ModuleSourceID id;

    private ModuleSourceKind kind;

    private String localContextDirectoryPath;

    private String moduleName;

    private String moduleOriginalName;

    private String originalSubpath;

    private String pin;

    private String repoRootPath;

    private String sourceRootSubpath;

    private String sourceSubpath;

    private ModuleSourceID sync;

    private String version;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected ModuleSource() {
    }

    ModuleSource(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Load the source as a module. If this is a local source, the parent directory must have been provided during module source creation</p>
     */
    public Module asModule() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asModule");
        return new Module(nextQueryBuilder);
    }

    /**
     * <p>A human readable ref string representation of this module source.</p>
     */
    public String asString() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.asString != null) {
            return asString;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asString");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The ref to clone the root of the git repo from. Only valid for git sources.</p>
     */
    public String cloneRef() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.cloneRef != null) {
            return cloneRef;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("cloneRef");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The resolved commit of the git repo this source points to.</p>
     */
    public String commit() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.commit != null) {
            return commit;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("commit");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The clients generated for the module.</p>
     */
    public List<ModuleConfigClient> configClients() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("configClients");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(ModuleConfigClient.class);
        return builders.stream().map(qb -> new ModuleConfigClient(qb)).toList();
    }

    /**
     * <p>Whether an existing dagger.json for the module was found.</p>
     */
    public Boolean configExists() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.configExists != null) {
            return configExists;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("configExists");
        return nextQueryBuilder.executeQuery(java.lang.Boolean.class);
    }

    /**
     * <p>The full directory loaded for the module source, including the source code as a subdirectory.</p>
     */
    public Directory contextDirectory() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("contextDirectory");
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>The dependencies of the module source.</p>
     */
    public List<ModuleSource> dependencies() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("dependencies");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(ModuleSource.class);
        return builders.stream().map(qb -> new ModuleSource(qb)).toList();
    }

    /**
     * <p>A content-hash of the module source. Module sources with the same digest will output the same generated context and convert into the same module instance.</p>
     */
    public String digest() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.digest != null) {
            return digest;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("digest");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The directory containing the module configuration and source code (source code may be in a subdir).</p>
     * @param path A subpath from the source directory to select.
     */
    public Directory directory(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("directory", fieldArgs);
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>The engine version of the module.</p>
     */
    public String engineVersion() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.engineVersion != null) {
            return engineVersion;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("engineVersion");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The generated files and directories made on top of the module source's context directory.</p>
     */
    public Directory generatedContextDirectory() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("generatedContextDirectory");
        return new Directory(nextQueryBuilder);
    }

    /**
     * <p>The URL to access the web view of the repository (e.g., GitHub, GitLab, Bitbucket).</p>
     */
    public String htmlRepoURL() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.htmlRepoURL != null) {
            return htmlRepoURL;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("htmlRepoURL");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The URL to the source's git repo in a web browser. Only valid for git sources.</p>
     */
    public String htmlURL() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.htmlURL != null) {
            return htmlURL;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("htmlURL");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>A unique identifier for this ModuleSource.</p>
     */
    public ModuleSourceID id() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(ModuleSourceID.class);
    }

    /**
     * <p>The kind of module source (currently local, git or dir).</p>
     */
    public ModuleSourceKind kind() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.kind != null) {
            return kind;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("kind");
        return nextQueryBuilder.executeQuery(ModuleSourceKind.class);
    }

    /**
     * <p>The full absolute path to the context directory on the caller's host filesystem that this module source is loaded from. Only valid for local module sources.</p>
     */
    public String localContextDirectoryPath() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.localContextDirectoryPath != null) {
            return localContextDirectoryPath;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("localContextDirectoryPath");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The name of the module, including any setting via the withName API.</p>
     */
    public String moduleName() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.moduleName != null) {
            return moduleName;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("moduleName");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The original name of the module as read from the module's dagger.json (or set for the first time with the withName API).</p>
     */
    public String moduleOriginalName() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.moduleOriginalName != null) {
            return moduleOriginalName;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("moduleOriginalName");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The original subpath used when instantiating this module source, relative to the context directory.</p>
     */
    public String originalSubpath() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.originalSubpath != null) {
            return originalSubpath;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("originalSubpath");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The pinned version of this module source.</p>
     */
    public String pin() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.pin != null) {
            return pin;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("pin");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The import path corresponding to the root of the git repo this source points to. Only valid for git sources.</p>
     */
    public String repoRootPath() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.repoRootPath != null) {
            return repoRootPath;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("repoRootPath");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The SDK configuration of the module.</p>
     */
    public SDKConfig sdk() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sdk");
        return new SDKConfig(nextQueryBuilder);
    }

    /**
     * <p>The path, relative to the context directory, that contains the module's dagger.json.</p>
     */
    public String sourceRootSubpath() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.sourceRootSubpath != null) {
            return sourceRootSubpath;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sourceRootSubpath");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>The path to the directory containing the module's source code, relative to the context directory.</p>
     */
    public String sourceSubpath() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.sourceSubpath != null) {
            return sourceSubpath;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sourceSubpath");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Forces evaluation of the module source, including any loading into the engine and associated validation.</p>
     */
    public ModuleSource sync() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("sync");
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>The specified version of the git repo this source points to.</p>
     */
    public String version() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.version != null) {
            return version;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("version");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Update the module source with a new client to generate.</p>
     * @param generator The generator to use
     * @param outputDir The output directory for the generated client.
     * @param optArgs withClient optional arguments
     */
    public ModuleSource withClient(String generator, String outputDir,
            WithClientArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("generator", generator);
        builder.add("outputDir", outputDir);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withClient", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update the module source with a new client to generate.</p>
     * @param generator The generator to use
     * @param outputDir The output directory for the generated client.
     */
    public ModuleSource withClient(String generator, String outputDir) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("generator", generator);
        builder.add("outputDir", outputDir);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withClient", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Append the provided dependencies to the module source's dependency list.</p>
     * @param dependencies The dependencies to append.
     */
    public ModuleSource withDependencies(List<ModuleSource> dependencies) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("dependencies", dependencies);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withDependencies", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Upgrade the engine version of the module to the given value.</p>
     * @param version The engine version to upgrade to.
     */
    public ModuleSource withEngineVersion(String version) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("version", version);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEngineVersion", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update the module source with additional include patterns for files+directories from its context that are required for building it</p>
     * @param patterns The new additional include patterns.
     */
    public ModuleSource withIncludes(List<String> patterns) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("patterns", patterns);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withIncludes", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update the module source with a new name.</p>
     * @param name The name to set.
     */
    public ModuleSource withName(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withName", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update the module source with a new SDK.</p>
     * @param source The SDK source to set.
     */
    public ModuleSource withSDK(String source) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("source", source);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withSDK", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update the module source with a new source subpath.</p>
     * @param path The path to set as the source subpath. Must be relative to the module source's source root directory.
     */
    public ModuleSource withSourceSubpath(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withSourceSubpath", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Update one or more module dependencies.</p>
     * @param dependencies The dependencies to update.
     */
    public ModuleSource withUpdateDependencies(List<String> dependencies) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("dependencies", dependencies);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withUpdateDependencies", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Remove a client from the module source.</p>
     * @param path The path of the client to remove.
     */
    public ModuleSource withoutClient(String path) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("path", path);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutClient", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    /**
     * <p>Remove the provided dependencies from the module source's dependency list.</p>
     * @param dependencies The dependencies to remove.
     */
    public ModuleSource withoutDependencies(List<String> dependencies) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("dependencies", dependencies);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withoutDependencies", fieldArgs);
        return new ModuleSource(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<ModuleSource> {
        @Override
        public ModuleSource deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            ModuleSource o = Dagger.dag().loadModuleSourceFromID(new ModuleSourceID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link ModuleSource#withClient}
     *
     */
    public static class WithClientArguments {
        private Boolean dev;

        /**
         * Generate in developer mode
         */
        public WithClientArguments withDev(Boolean dev) {
            this.dev = dev;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (dev != null) {
                builder.add("dev", this.dev);
            }

                    return builder.build();
        }
    }
}
