// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.List;
import java.util.concurrent.ExecutionException;

/**
 * A content-addressed service providing TCP connectivity.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(Service.Deserializer.class)
public class Service implements IDAble<ServiceID> {
    private QueryBuilder queryBuilder;

    private String endpoint;

    private String hostname;

    private ServiceID id;

    private ServiceID start;

    private ServiceID stop;

    private Void up;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected Service() {
    }

    Service(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>Retrieves an endpoint that clients can use to reach this container.<br/><br/>If no port is specified, the first exposed port is used. If none exist an error is returned.<br/><br/>If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.</p>
     * @param optArgs endpoint optional arguments
     */
    public String endpoint(EndpointArguments optArgs) throws InterruptedException,
            ExecutionException, DaggerQueryException {
        if (this.endpoint != null) {
            return endpoint;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("endpoint", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves an endpoint that clients can use to reach this container.<br/><br/>If no port is specified, the first exposed port is used. If none exist an error is returned.<br/><br/>If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.</p>
     */
    public String endpoint() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.endpoint != null) {
            return endpoint;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("endpoint", fieldArgs);
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>Retrieves a hostname which can be used by clients to reach this container.</p>
     */
    public String hostname() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.hostname != null) {
            return hostname;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("hostname");
        return nextQueryBuilder.executeQuery(java.lang.String.class);
    }

    /**
     * <p>A unique identifier for this Service.</p>
     */
    public ServiceID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(ServiceID.class);
    }

    /**
     * <p>Retrieves the list of ports provided by the service.</p>
     */
    public List<Port> ports() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("ports");
        nextQueryBuilder = nextQueryBuilder.chain(List.of("id"));
        List<QueryBuilder> builders = nextQueryBuilder.executeObjectListQuery(Port.class);
        return builders.stream().map(qb -> new Port(qb)).toList();
    }

    /**
     * <p>Start the service and wait for its health checks to succeed.<br/><br/>Services bound to a Container do not need to be manually started.</p>
     */
    public Service start() throws InterruptedException, ExecutionException, DaggerQueryException {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("start");
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Stop the service.</p>
     * @param optArgs stop optional arguments
     */
    public Service stop(StopArguments optArgs) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("stop", fieldArgs);
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Stop the service.</p>
     */
    public Service stop() throws InterruptedException, ExecutionException, DaggerQueryException {
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("stop", fieldArgs);
        nextQueryBuilder.executeQuery();
        return this;
    }

    /**
     * <p>Creates a tunnel that forwards traffic from the caller's network to this service.</p>
     * @param optArgs up optional arguments
     */
    public Void up(UpArguments optArgs) throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.up != null) {
            return up;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("up", fieldArgs);
        return nextQueryBuilder.executeQuery(Void.class);
    }

    /**
     * <p>Creates a tunnel that forwards traffic from the caller's network to this service.</p>
     */
    public Void up() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.up != null) {
            return up;
        }
        Arguments.Builder builder = Arguments.newBuilder();
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("up", fieldArgs);
        return nextQueryBuilder.executeQuery(Void.class);
    }

    /**
     * <p>Configures a hostname which can be used by clients within the session to reach this container.</p>
     * @param hostname The hostname to use.
     */
    public Service withHostname(String hostname) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("hostname", hostname);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withHostname", fieldArgs);
        return new Service(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<Service> {
        @Override
        public Service deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            Service o = Dagger.dag().loadServiceFromID(new ServiceID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link Service#endpoint}
     *
     */
    public static class EndpointArguments {
        private Integer port;

        private String scheme;

        /**
         * The exposed port number for the endpoint
         */
        public EndpointArguments withPort(Integer port) {
            this.port = port;
            return this;
        }

        /**
         * Return a URL with the given scheme, eg. http for http://
         */
        public EndpointArguments withScheme(String scheme) {
            this.scheme = scheme;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (port != null) {
                builder.add("port", this.port);
            }

            if (scheme != null) {
                builder.add("scheme", this.scheme);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Service#stop}
     *
     */
    public static class StopArguments {
        private Boolean kill;

        /**
         * Immediately kill the service without waiting for a graceful exit
         */
        public StopArguments withKill(Boolean kill) {
            this.kill = kill;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (kill != null) {
                builder.add("kill", this.kill);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link Service#up}
     *
     */
    public static class UpArguments {
        private List<PortForward> ports;

        private Boolean random;

        /**
         * List of frontend/backend port mappings to forward.<br/><br/>Frontend is the port accepting traffic on the host, backend is the service port.
         */
        public UpArguments withPorts(List<PortForward> ports) {
            this.ports = ports;
            return this;
        }

        /**
         * Bind each tunnel port to a random port on the host.
         */
        public UpArguments withRandom(Boolean random) {
            this.random = random;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (ports != null) {
                builder.add("ports", this.ports);
            }

            if (random != null) {
                builder.add("random", this.random);
            }

                    return builder.build();
        }
    }
}
