// This class has been generated by dagger-java-sdk. DO NOT EDIT.
package io.dagger.client;

import jakarta.json.bind.annotation.JsonbTypeDeserializer;
import jakarta.json.bind.annotation.JsonbTypeSerializer;
import jakarta.json.bind.serializer.DeserializationContext;
import jakarta.json.bind.serializer.JsonbDeserializer;
import jakarta.json.stream.JsonParser;
import java.lang.Boolean;
import java.lang.InterruptedException;
import java.lang.Override;
import java.lang.String;
import java.lang.reflect.Type;
import java.util.concurrent.ExecutionException;

/**
 * A definition of a parameter or return type in a Module.
 */
@JsonbTypeSerializer(IDAbleSerializer.class)
@JsonbTypeDeserializer(TypeDef.Deserializer.class)
public class TypeDef implements IDAble<TypeDefID> {
    private QueryBuilder queryBuilder;

    private TypeDefID id;

    private TypeDefKind kind;

    private Boolean optional;

    /**
     * Empty constructor for JSON-B deserialization
     */
    protected TypeDef() {
    }

    TypeDef(QueryBuilder queryBuilder) {
        this.queryBuilder = queryBuilder;
    }

    /**
     * <p>If kind is ENUM, the enum-specific type definition. If kind is not ENUM, this will be null.</p>
     */
    public EnumTypeDef asEnum() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asEnum");
        return new EnumTypeDef(nextQueryBuilder);
    }

    /**
     * <p>If kind is INPUT, the input-specific type definition. If kind is not INPUT, this will be null.</p>
     */
    public InputTypeDef asInput() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asInput");
        return new InputTypeDef(nextQueryBuilder);
    }

    /**
     * <p>If kind is INTERFACE, the interface-specific type definition. If kind is not INTERFACE, this will be null.</p>
     */
    public InterfaceTypeDef asInterface() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asInterface");
        return new InterfaceTypeDef(nextQueryBuilder);
    }

    /**
     * <p>If kind is LIST, the list-specific type definition. If kind is not LIST, this will be null.</p>
     */
    public ListTypeDef asList() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asList");
        return new ListTypeDef(nextQueryBuilder);
    }

    /**
     * <p>If kind is OBJECT, the object-specific type definition. If kind is not OBJECT, this will be null.</p>
     */
    public ObjectTypeDef asObject() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asObject");
        return new ObjectTypeDef(nextQueryBuilder);
    }

    /**
     * <p>If kind is SCALAR, the scalar-specific type definition. If kind is not SCALAR, this will be null.</p>
     */
    public ScalarTypeDef asScalar() {
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("asScalar");
        return new ScalarTypeDef(nextQueryBuilder);
    }

    /**
     * <p>A unique identifier for this TypeDef.</p>
     */
    public TypeDefID id() throws InterruptedException, ExecutionException, DaggerQueryException {
        if (this.id != null) {
            return id;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("id");
        return nextQueryBuilder.executeQuery(TypeDefID.class);
    }

    /**
     * <p>The kind of type this is (e.g. primitive, list, object).</p>
     */
    public TypeDefKind kind() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.kind != null) {
            return kind;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("kind");
        return nextQueryBuilder.executeQuery(TypeDefKind.class);
    }

    /**
     * <p>Whether this type can be set to null. Defaults to false.</p>
     */
    public Boolean optional() throws InterruptedException, ExecutionException,
            DaggerQueryException {
        if (this.optional != null) {
            return optional;
        }
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("optional");
        return nextQueryBuilder.executeQuery(java.lang.Boolean.class);
    }

    /**
     * <p>Adds a function for constructing a new instance of an Object TypeDef, failing if the type is not an object.</p>
     */
    public TypeDef withConstructor(Function function) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("function", function);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withConstructor", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Enum with the provided name.<br/><br/>Note that an enum's values may be omitted if the intent is only to refer to an enum. This is how functions are able to return their own, or any other circular reference.</p>
     * @param name The name of the enum
     * @param optArgs withEnum optional arguments
     */
    public TypeDef withEnum(String name, WithEnumArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnum", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Enum with the provided name.<br/><br/>Note that an enum's values may be omitted if the intent is only to refer to an enum. This is how functions are able to return their own, or any other circular reference.</p>
     * @param name The name of the enum
     */
    public TypeDef withEnum(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnum", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Adds a static value for an Enum TypeDef, failing if the type is not an enum.</p>
     * @param value The name of the value in the enum
     * @param optArgs withEnumValue optional arguments
     */
    public TypeDef withEnumValue(String value, WithEnumValueArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnumValue", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Adds a static value for an Enum TypeDef, failing if the type is not an enum.</p>
     * @param value The name of the value in the enum
     */
    public TypeDef withEnumValue(String value) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("value", value);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withEnumValue", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Adds a static field for an Object TypeDef, failing if the type is not an object.</p>
     * @param name The name of the field in the object
     * @param typeDef The type of the field
     * @param optArgs withField optional arguments
     */
    public TypeDef withField(String name, TypeDef typeDef, WithFieldArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("typeDef", typeDef);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withField", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Adds a static field for an Object TypeDef, failing if the type is not an object.</p>
     * @param name The name of the field in the object
     * @param typeDef The type of the field
     */
    public TypeDef withField(String name, TypeDef typeDef) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        builder.add("typeDef", typeDef);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withField", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Adds a function for an Object or Interface TypeDef, failing if the type is not one of those kinds.</p>
     */
    public TypeDef withFunction(Function function) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("function", function);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withFunction", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Interface with the provided name.</p>
     * @param optArgs withInterface optional arguments
     */
    public TypeDef withInterface(String name, WithInterfaceArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withInterface", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Interface with the provided name.</p>
     */
    public TypeDef withInterface(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withInterface", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Sets the kind of the type.</p>
     */
    public TypeDef withKind(TypeDefKind kind) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("kind", kind);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withKind", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind List with the provided type for its elements.</p>
     */
    public TypeDef withListOf(TypeDef elementType) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("elementType", elementType);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withListOf", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Object with the provided name.<br/><br/>Note that an object's fields and functions may be omitted if the intent is only to refer to an object. This is how functions are able to return their own object, or any other circular reference.</p>
     * @param optArgs withObject optional arguments
     */
    public TypeDef withObject(String name, WithObjectArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withObject", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Object with the provided name.<br/><br/>Note that an object's fields and functions may be omitted if the intent is only to refer to an object. This is how functions are able to return their own object, or any other circular reference.</p>
     */
    public TypeDef withObject(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withObject", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Sets whether this type can be set to null.</p>
     */
    public TypeDef withOptional(Boolean optional) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("optional", optional);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withOptional", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Scalar with the provided name.</p>
     * @param optArgs withScalar optional arguments
     */
    public TypeDef withScalar(String name, WithScalarArguments optArgs) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        fieldArgs = fieldArgs.merge(optArgs.toArguments());
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withScalar", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    /**
     * <p>Returns a TypeDef of kind Scalar with the provided name.</p>
     */
    public TypeDef withScalar(String name) {
        Arguments.Builder builder = Arguments.newBuilder();
        builder.add("name", name);
        Arguments fieldArgs = builder.build();
        QueryBuilder nextQueryBuilder = this.queryBuilder.chain("withScalar", fieldArgs);
        return new TypeDef(nextQueryBuilder);
    }

    public static class Deserializer implements JsonbDeserializer<TypeDef> {
        @Override
        public TypeDef deserialize(JsonParser parser, DeserializationContext ctx, Type type) {
            String id = ctx.deserialize(String.class, parser);
            TypeDef o = Dagger.dag().loadTypeDefFromID(new TypeDefID(id));
            return o;
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withEnum}
     *
     */
    public static class WithEnumArguments {
        private String description;

        private SourceMap sourceMap;

        /**
         * A doc string for the enum, if any
         */
        public WithEnumArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         * The source map for the enum definition.
         */
        public WithEnumArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withEnumValue}
     *
     */
    public static class WithEnumValueArguments {
        private String description;

        private SourceMap sourceMap;

        /**
         * A doc string for the value, if any
         */
        public WithEnumValueArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         * The source map for the enum value definition.
         */
        public WithEnumValueArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withField}
     *
     */
    public static class WithFieldArguments {
        private String description;

        private SourceMap sourceMap;

        /**
         * A doc string for the field, if any
         */
        public WithFieldArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         * The source map for the field definition.
         */
        public WithFieldArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withInterface}
     *
     */
    public static class WithInterfaceArguments {
        private String description;

        private SourceMap sourceMap;

        /**
         *
         */
        public WithInterfaceArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         *
         */
        public WithInterfaceArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withObject}
     *
     */
    public static class WithObjectArguments {
        private String description;

        private SourceMap sourceMap;

        /**
         *
         */
        public WithObjectArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        /**
         *
         */
        public WithObjectArguments withSourceMap(SourceMap sourceMap) {
            this.sourceMap = sourceMap;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

            if (sourceMap != null) {
                builder.add("sourceMap", this.sourceMap);
            }

                    return builder.build();
        }
    }

    /**
     * Optional arguments for {@link TypeDef#withScalar}
     *
     */
    public static class WithScalarArguments {
        private String description;

        /**
         *
         */
        public WithScalarArguments withDescription(String description) {
            this.description = description;
            return this;
        }

        Arguments toArguments() {
            Arguments.Builder builder = Arguments.newBuilder();
            if (description != null) {
                builder.add("description", this.description);
            }

                    return builder.build();
        }
    }
}
