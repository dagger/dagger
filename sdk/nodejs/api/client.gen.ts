/**
 * This file was auto-generated by `client-gen`.
 * Do not make direct changes to the file.
 */
import { GraphQLClient } from "graphql-request"

import { computeQuery } from "./utils.js"

/**
 * @hidden
 */
export type QueryTree = {
  operation: string
  args?: Record<string, unknown>
}

interface ClientConfig {
  queryTree?: QueryTree[]
  host?: string
  sessionToken?: string
}

class BaseClient {
  protected _queryTree: QueryTree[]
  protected client: GraphQLClient
  /**
   * @defaultValue `127.0.0.1:8080`
   */
  public clientHost: string
  public sessionToken: string

  /**
   * @hidden
   */
  constructor({ queryTree, host, sessionToken }: ClientConfig = {}) {
    this._queryTree = queryTree || []
    this.clientHost = host || "127.0.0.1:8080"
    this.sessionToken = sessionToken || ""
    this.client = new GraphQLClient(`http://${host}/query`, {
      headers: {
        Authorization:
          "Basic " + Buffer.from(sessionToken + ":").toString("base64"),
      },
    })
  }

  /**
   * @hidden
   */
  get queryTree() {
    return this._queryTree
  }
}

export type BuildArg = {
  name: string
  value: string
}

/**
 * A global cache volume identifier.
 */
export type CacheID = string

export type ContainerBuildOpts = {
  /**
   * Path to the Dockerfile to use.
   * Defaults to './Dockerfile'.
   */
  dockerfile?: string

  /**
   * Additional build arguments.
   */
  buildArgs?: BuildArg[]
}

export type ContainerExecOpts = {
  /**
   * Command to run instead of the container's default command.
   */
  args?: string[]

  /**
   * Content to write to the command's standard input before closing.
   */
  stdin?: string

  /**
   * Redirect the command's standard output to a file in the container.
   */
  redirectStdout?: string

  /**
   * Redirect the command's standard error to a file in the container.
   */
  redirectStderr?: string

  /**
   * Provide dagger access to the executed command.
   * Do not use this option unless you trust the command being executed.
   * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   */
  experimentalPrivilegedNesting?: boolean
}

export type ContainerExportOpts = {
  /**
   * Identifiers for other platform specific containers.
   * Used for multi-platform image.
   */
  platformVariants?: ContainerID[] | Container[]
}

export type ContainerPublishOpts = {
  /**
   * Identifiers for other platform specific containers.
   * Used for multi-platform image.
   */
  platformVariants?: ContainerID[] | Container[]
}

export type ContainerWithDefaultArgsOpts = {
  args?: string[]
}

export type ContainerWithDirectoryOpts = {
  exclude?: string[]
  include?: string[]
}

export type ContainerWithExecOpts = {
  /**
   * Content to write to the command's standard input before closing.
   */
  stdin?: string

  /**
   * Redirect the command's standard output to a file in the container.
   */
  redirectStdout?: string

  /**
   * Redirect the command's standard error to a file in the container.
   */
  redirectStderr?: string

  /**
   * Provide dagger access to the executed command.
   * Do not use this option unless you trust the command being executed.
   * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   */
  experimentalPrivilegedNesting?: boolean
}

export type ContainerWithFileOpts = {
  permissions?: number
}

export type ContainerWithMountedCacheOpts = {
  source?: DirectoryID | Directory
}

export type ContainerWithNewFileOpts = {
  contents?: string
  permissions?: number
}

/**
 * A unique container identifier. Null designates an empty container (scratch).
 */
export type ContainerID = string

/**
 * The `DateTime` scalar type represents a DateTime. The DateTime is serialized as an RFC 3339 quoted string
 */
export type DateTime = string

export type DirectoryDockerBuildOpts = {
  /**
   * Path to the Dockerfile to use.
   * Defaults to './Dockerfile'.
   */
  dockerfile?: string
  platform?: Platform
  buildArgs?: BuildArg[]
}

export type DirectoryEntriesOpts = {
  path?: string
}

export type DirectoryWithDirectoryOpts = {
  /**
   * Exclude artifacts that match the given pattern.
   * (e.g. ["node_modules/", ".git*"]).
   */
  exclude?: string[]

  /**
   * Include only artifacts that match the given pattern.
   * (e.g. ["app/", "package.*"]).
   */
  include?: string[]
}

export type DirectoryWithFileOpts = {
  permissions?: number
}

export type DirectoryWithNewDirectoryOpts = {
  permissions?: number
}

export type DirectoryWithNewFileOpts = {
  permissions?: number
}

/**
 * A content-addressed directory identifier.
 */
export type DirectoryID = string

/**
 * A file identifier.
 */
export type FileID = string

export type GitRefTreeOpts = {
  sshKnownHosts?: string
  sshAuthSocket?: SocketID | Socket
}

export type HostDirectoryOpts = {
  exclude?: string[]
  include?: string[]
}

export type HostWorkdirOpts = {
  exclude?: string[]
  include?: string[]
}

/**
 * The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
 */
export type ID = string

/**
 * The platform config OS and architecture in a Container.
 * The format is {os}/{platform}/{version} (e.g. darwin/arm64/v7, windows/amd64, linux/arm64).
 */
export type Platform = string

export type ClientContainerOpts = {
  id?: ContainerID | Container
  platform?: Platform
}

export type ClientDirectoryOpts = {
  id?: DirectoryID | Directory
}

export type ClientGitOpts = {
  keepGitDir?: boolean
}

export type ClientSocketOpts = {
  id?: SocketID | Socket
}

/**
 * A unique identifier for a secret.
 */
export type SecretID = string

/**
 * A content-addressed socket identifier.
 */
export type SocketID = string

export type __TypeEnumValuesOpts = {
  includeDeprecated?: boolean
}

export type __TypeFieldsOpts = {
  includeDeprecated?: boolean
}

/**
 * A directory whose contents persist across runs.
 */
export class CacheVolume extends BaseClient {
  async id(): Promise<CacheID> {
    const response: Awaited<CacheID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * An OCI-compatible container, also known as a docker container.
 */
export class Container extends BaseClient {
  /**
   * Initializes this container from a Dockerfile build, using the context, a dockerfile file path and some additional buildArgs.
   * @param context Directory context used by the Dockerfile.
   * @param opts.dockerfile Path to the Dockerfile to use.
Defaults to './Dockerfile'.
   * @param opts.buildArgs Additional build arguments.
   */
  build(
    context: DirectoryID | Directory,
    opts?: ContainerBuildOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "build",
          args: { context, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves default arguments for future commands.
   */
  async defaultArgs(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "defaultArgs",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a directory at the given path. Mounts are included.
   */
  directory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves entrypoint to be prepended to the arguments of all commands.
   */
  async entrypoint(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "entrypoint",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the value of the specified environment variable.
   */
  async envVariable(name: string): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "envVariable",
          args: { name },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the list of environment variables passed to commands.
   */
  async envVariables(): Promise<EnvVariable[]> {
    const response: Awaited<EnvVariable[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "envVariables",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves this container after executing the specified command inside it.
   * @param opts.args Command to run instead of the container's default command.
   * @param opts.stdin Content to write to the command's standard input before closing.
   * @param opts.redirectStdout Redirect the command's standard output to a file in the container.
   * @param opts.redirectStderr Redirect the command's standard error to a file in the container.
   * @param opts.experimentalPrivilegedNesting Provide dagger access to the executed command.
Do not use this option unless you trust the command being executed.
The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   * @deprecated Replaced by withExec.
   */
  exec(opts?: ContainerExecOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "exec",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Exit code of the last executed command. Zero means success.
   * Null if no command has been executed.
   */
  async exitCode(): Promise<number> {
    const response: Awaited<number> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "exitCode",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Writes the container as an OCI tarball to the destination file path on the host for the specified platformVariants.
   * Return true on success.
   * @param path Host's destination path.
Path can be relative to the engine's workdir or absolute.
   * @param opts.platformVariants Identifiers for other platform specific containers.
Used for multi-platform image.
   */
  async export(path: string, opts?: ContainerExportOpts): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path, ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a file at the given path. Mounts are included.
   */
  file(path: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Initializes this container from the base image published at the given address.
   * @param address Image's address from its registry.
Formatted as {host}/{user}/{repo}:{tag} (e.g. docker.io/dagger/dagger:main).
   */
  from(address: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "from",
          args: { address },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container's root filesystem. Mounts are not included.
   * @deprecated Replaced by rootfs.
   */
  fs(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "fs",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * A unique identifier for this container.
   */
  async id(): Promise<ContainerID> {
    const response: Awaited<ContainerID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the list of paths where a directory is mounted.
   */
  async mounts(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "mounts",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The platform this container executes and publishes as.
   */
  async platform(): Promise<Platform> {
    const response: Awaited<Platform> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "platform",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Publishes this container as a new image to the specified address, for the platformVariants, returning a fully qualified ref.
   * @param address Registry's address to publish the image to.
Formatted as {host}/{user}/{repo}:{tag} (e.g. docker.io/dagger/dagger:main).
   * @param opts.platformVariants Identifiers for other platform specific containers.
Used for multi-platform image.
   */
  async publish(address: string, opts?: ContainerPublishOpts): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "publish",
          args: { address, ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves this container's root filesystem. Mounts are not included.
   */
  rootfs(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "rootfs",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The error stream of the last executed command.
   * Null if no command has been executed.
   */
  async stderr(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "stderr",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The output stream of the last executed command.
   * Null if no command has been executed.
   */
  async stdout(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "stdout",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the user to be set for all commands.
   */
  async user(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "user",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Configures default arguments for future commands.
   */
  withDefaultArgs(opts?: ContainerWithDefaultArgsOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDefaultArgs",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a directory written at the given path.
   */
  withDirectory(
    path: string,
    directory: DirectoryID | Directory,
    opts?: ContainerWithDirectoryOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDirectory",
          args: { path, directory, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container but with a different command entrypoint.
   */
  withEntrypoint(args: string[]): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withEntrypoint",
          args: { args },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus the given environment variable.
   */
  withEnvVariable(name: string, value: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withEnvVariable",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container after executing the specified command inside it.
   * @param args Command to run instead of the container's default command.
   * @param opts.stdin Content to write to the command's standard input before closing.
   * @param opts.redirectStdout Redirect the command's standard output to a file in the container.
   * @param opts.redirectStderr Redirect the command's standard error to a file in the container.
   * @param opts.experimentalPrivilegedNesting Provide dagger access to the executed command.
Do not use this option unless you trust the command being executed.
The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   */
  withExec(args: string[], opts?: ContainerWithExecOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withExec",
          args: { args, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Initializes this container from this DirectoryID.
   * @deprecated Replaced by withRootfs.
   */
  withFS(id: DirectoryID | Directory): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFS",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus the contents of the given file copied to the given path.
   */
  withFile(
    path: string,
    source: FileID | File,
    opts?: ContainerWithFileOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFile",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a cache volume mounted at the given path.
   */
  withMountedCache(
    path: string,
    cache: CacheID | CacheVolume,
    opts?: ContainerWithMountedCacheOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedCache",
          args: { path, cache, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a directory mounted at the given path.
   */
  withMountedDirectory(
    path: string,
    source: DirectoryID | Directory
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedDirectory",
          args: { path, source },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a file mounted at the given path.
   */
  withMountedFile(path: string, source: FileID | File): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedFile",
          args: { path, source },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a secret mounted into a file at the given path.
   */
  withMountedSecret(path: string, source: SecretID | Secret): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedSecret",
          args: { path, source },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a temporary directory mounted at the given path.
   */
  withMountedTemp(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedTemp",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a new file written at the given path.
   */
  withNewFile(path: string, opts?: ContainerWithNewFileOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewFile",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Initializes this container from this DirectoryID.
   */
  withRootfs(id: DirectoryID | Directory): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withRootfs",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus an env variable containing the given secret.
   */
  withSecretVariable(name: string, secret: SecretID | Secret): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withSecretVariable",
          args: { name, secret },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a socket forwarded to the given Unix socket path.
   */
  withUnixSocket(path: string, source: SocketID | Socket): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withUnixSocket",
          args: { path, source },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this containers with a different command user.
   */
  withUser(name: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withUser",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a different working directory.
   */
  withWorkdir(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withWorkdir",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container minus the given environment variable.
   */
  withoutEnvVariable(name: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutEnvVariable",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container after unmounting everything at the given path.
   */
  withoutMount(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutMount",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a previously added Unix socket removed.
   */
  withoutUnixSocket(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutUnixSocket",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves the working directory for all commands.
   */
  async workdir(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "workdir",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A directory.
 */
export class Directory extends BaseClient {
  /**
   * Gets the difference between this directory and an another directory.
   */
  diff(other: DirectoryID | Directory): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "diff",
          args: { other },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves a directory at the given path.
   */
  directory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Builds a new Docker container from this directory.
   * @param opts.dockerfile Path to the Dockerfile to use.
Defaults to './Dockerfile'.
   */
  dockerBuild(opts?: DirectoryDockerBuildOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "dockerBuild",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns a list of files and directories at the given path.
   */
  async entries(opts?: DirectoryEntriesOpts): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "entries",
          args: { ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Writes the contents of the directory to a path on the host.
   */
  async export(path: string): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a file at the given path.
   */
  file(path: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The content-addressed identifier of the directory.
   */
  async id(): Promise<DirectoryID> {
    const response: Awaited<DirectoryID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * load a project's metadata
   */
  loadProject(configPath: string): Project {
    return new Project({
      queryTree: [
        ...this._queryTree,
        {
          operation: "loadProject",
          args: { configPath },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus a directory written at the given path.
   * @param opts.exclude Exclude artifacts that match the given pattern.
(e.g. ["node_modules/", ".git*"]).
   * @param opts.include Include only artifacts that match the given pattern.
(e.g. ["app/", "package.*"]).
   */
  withDirectory(
    path: string,
    directory: DirectoryID | Directory,
    opts?: DirectoryWithDirectoryOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDirectory",
          args: { path, directory, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus the contents of the given file copied to the given path.
   */
  withFile(
    path: string,
    source: FileID | File,
    opts?: DirectoryWithFileOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFile",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus a new directory created at the given path.
   */
  withNewDirectory(
    path: string,
    opts?: DirectoryWithNewDirectoryOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewDirectory",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus a new file written at the given path.
   */
  withNewFile(
    path: string,
    contents: string,
    opts?: DirectoryWithNewFileOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewFile",
          args: { path, contents, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with all file/dir timestamps set to the given time, in seconds from the Unix epoch.
   */
  withTimestamps(timestamp: number): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withTimestamps",
          args: { timestamp },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with the directory at the given path removed.
   */
  withoutDirectory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutDirectory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with the file at the given path removed.
   */
  withoutFile(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutFile",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A simple key value object that represents an environment variable.
 */
export class EnvVariable extends BaseClient {
  /**
   * The environment variable name.
   */
  async name(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The environment variable value.
   */
  async value(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "value",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A file.
 */
export class File extends BaseClient {
  /**
   * Retrieves the contents of the file.
   */
  async contents(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "contents",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Writes the file to a file path on the host.
   */
  async export(path: string): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the content-addressed identifier of the file.
   */
  async id(): Promise<FileID> {
    const response: Awaited<FileID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a secret referencing the contents of this file.
   */
  secret(): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "secret",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Gets the size of the file, in bytes.
   */
  async size(): Promise<number> {
    const response: Awaited<number> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "size",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves this file with its created/modified timestamps set to the given time, in seconds from the Unix epoch.
   */
  withTimestamps(timestamp: number): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withTimestamps",
          args: { timestamp },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A git ref (tag, branch or commit).
 */
export class GitRef extends BaseClient {
  /**
   * The digest of the current value of this ref.
   */
  async digest(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "digest",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The filesystem tree at this ref.
   */
  tree(opts?: GitRefTreeOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "tree",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A git repository.
 */
export class GitRepository extends BaseClient {
  /**
   * Returns details on one branch.
   */
  branch(name: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "branch",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Lists of branches on the repository.
   */
  async branches(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "branches",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Returns details on one commit.
   */
  commit(id: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "commit",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns details on one tag.
   */
  tag(name: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "tag",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Lists of tags on the repository.
   */
  async tags(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "tags",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * Information about the host execution environment.
 */
export class Host extends BaseClient {
  /**
   * Accesses a directory on the host.
   */
  directory(path: string, opts?: HostDirectoryOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Accesses an environment variable on the host.
   */
  envVariable(name: string): HostVariable {
    return new HostVariable({
      queryTree: [
        ...this._queryTree,
        {
          operation: "envVariable",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Accesses a Unix socket on the host.
   */
  unixSocket(path: string): Socket {
    return new Socket({
      queryTree: [
        ...this._queryTree,
        {
          operation: "unixSocket",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves the current working directory on the host.
   * @deprecated Use directory with path set to '.' instead.
   */
  workdir(opts?: HostWorkdirOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "workdir",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * An environment variable on the host environment.
 */
export class HostVariable extends BaseClient {
  /**
   * A secret referencing the value of this variable.
   */
  secret(): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "secret",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The value of this variable.
   */
  async value(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "value",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A set of scripts and/or extensions
 */
export class Project extends BaseClient {
  /**
   * extensions in this project
   */
  async extensions(): Promise<Project[]> {
    const response: Awaited<Project[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "extensions",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Code files generated by the SDKs in the project
   */
  generatedCode(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "generatedCode",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * install the project's schema
   */
  async install(): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "install",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * name of the project
   */
  async name(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * schema provided by the project
   */
  async schema(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "schema",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * sdk used to generate code for and/or execute this project
   */
  async sdk(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sdk",
        },
      ],
      this.client
    )

    return response
  }
}

export default class Client extends BaseClient {
  /**
   * Constructs a cache volume for a given cache key.
   * @param key A string identifier to target this cache volume (e.g. "myapp-cache").
   */
  cacheVolume(key: string): CacheVolume {
    return new CacheVolume({
      queryTree: [
        ...this._queryTree,
        {
          operation: "cacheVolume",
          args: { key },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a container from ID.
   * Null ID returns an empty container (scratch).
   * Optional platform argument initializes new containers to execute and publish as that platform. Platform defaults to that of the builder's host.
   */
  container(opts?: ClientContainerOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "container",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The default platform of the builder.
   */
  async defaultPlatform(): Promise<Platform> {
    const response: Awaited<Platform> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "defaultPlatform",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Load a directory by ID. No argument produces an empty directory.
   */
  directory(opts?: ClientDirectoryOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a file by ID.
   */
  file(id: FileID | File): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Queries a git repository.
   */
  git(url: string, opts?: ClientGitOpts): GitRepository {
    return new GitRepository({
      queryTree: [
        ...this._queryTree,
        {
          operation: "git",
          args: { url, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Queries the host environment.
   */
  host(): Host {
    return new Host({
      queryTree: [
        ...this._queryTree,
        {
          operation: "host",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns a file containing an http remote url content.
   */
  http(url: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "http",
          args: { url },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Look up a project by name
   */
  project(name: string): Project {
    return new Project({
      queryTree: [
        ...this._queryTree,
        {
          operation: "project",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a secret from its ID.
   */
  secret(id: SecretID | Secret): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "secret",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a socket by its ID.
   */
  socket(opts?: ClientSocketOpts): Socket {
    return new Socket({
      queryTree: [
        ...this._queryTree,
        {
          operation: "socket",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A reference to a secret value, which can be handled more safely than the value itself.
 */
export class Secret extends BaseClient {
  /**
   * The identifier for this secret.
   */
  async id(): Promise<SecretID> {
    const response: Awaited<SecretID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The value of this secret.
   */
  async plaintext(): Promise<string> {
    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "plaintext",
        },
      ],
      this.client
    )

    return response
  }
}

export class Socket extends BaseClient {
  /**
   * The content-addressed identifier of the socket.
   */
  async id(): Promise<SocketID> {
    const response: Awaited<SocketID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
}
