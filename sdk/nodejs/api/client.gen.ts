/**
 * This file was auto-generated by `client-gen`.
 * Do not make direct changes to the file.
 */
import { GraphQLClient } from "graphql-request"

import { computeQuery } from "./utils.js"

/**
 * @hidden
 */
export type QueryTree = {
  operation: string
  args?: Record<string, unknown>
}

interface ClientConfig {
  queryTree?: QueryTree[]
  host?: string
  sessionToken?: string
}

class BaseClient {
  protected _queryTree: QueryTree[]
  protected client: GraphQLClient
  /**
   * @defaultValue `127.0.0.1:8080`
   */
  public clientHost: string
  public sessionToken: string

  /**
   * @hidden
   */
  constructor({ queryTree, host, sessionToken }: ClientConfig = {}) {
    this._queryTree = queryTree || []
    this.clientHost = host || "127.0.0.1:8080"
    this.sessionToken = sessionToken || ""
    this.client = new GraphQLClient(`http://${host}/query`, {
      headers: {
        Authorization:
          "Basic " + Buffer.from(sessionToken + ":").toString("base64"),
      },
    })
  }

  /**
   * @hidden
   */
  get queryTree() {
    return this._queryTree
  }
}

export type BuildArg = {
  /**
   * The build argument name.
   */
  name: string

  /**
   * The build argument value.
   */
  value: string
}

/**
 * A global cache volume identifier.
 */
export type CacheID = string & { __CacheID: never }

/**
 * Sharing mode of the cache volume.
 */
export enum CacheSharingMode {
  /**
   * Shares the cache volume amongst many build pipelines,
   * but will serialize the writes
   */
  Locked,

  /**
   * Keeps a cache volume for a single build pipeline
   */
  Private,

  /**
   * Shares the cache volume amongst many build pipelines
   */
  Shared,
}
export type ContainerBuildOpts = {
  /**
   * Path to the Dockerfile to use.
   *
   * Default: './Dockerfile'.
   */
  dockerfile?: string

  /**
   * Additional build arguments.
   */
  buildArgs?: BuildArg[]

  /**
   * Target build stage to build.
   */
  target?: string

  /**
   * Secrets to pass to the build.
   *
   * They will be mounted at /run/secrets/[secret-name].
   */
  secrets?: Secret[]
}

export type ContainerEndpointOpts = {
  /**
   * The exposed port number for the endpoint
   */
  port?: number

  /**
   * Return a URL with the given scheme, eg. http for http://
   */
  scheme?: string
}

export type ContainerExportOpts = {
  /**
   * Identifiers for other platform specific containers.
   * Used for multi-platform image.
   */
  platformVariants?: Container[]

  /**
   * Force each layer of the exported image to use the specified compression algorithm.
   * If this is unset, then if a layer already has a compressed blob in the engine's
   * cache, that will be used (this can result in a mix of compression algorithms for
   * different layers). If this is unset and a layer has no compressed blob in the
   * engine's cache, then it will be compressed using Gzip.
   */
  forcedCompression?: ImageLayerCompression

  /**
   * Use the specified media types for the exported image's layers. Defaults to OCI, which
   * is largely compatible with most recent container runtimes, but Docker may be needed
   * for older runtimes without OCI support.
   */
  mediaTypes?: ImageMediaTypes
}

export type ContainerImportOpts = {
  /**
   * Identifies the tag to import from the archive, if the archive bundles
   * multiple tags.
   */
  tag?: string
}

export type ContainerPipelineOpts = {
  /**
   * Pipeline description.
   */
  description?: string

  /**
   * Pipeline labels.
   */
  labels?: PipelineLabel[]
}

export type ContainerPublishOpts = {
  /**
   * Identifiers for other platform specific containers.
   * Used for multi-platform image.
   */
  platformVariants?: Container[]

  /**
   * Force each layer of the published image to use the specified compression algorithm.
   * If this is unset, then if a layer already has a compressed blob in the engine's
   * cache, that will be used (this can result in a mix of compression algorithms for
   * different layers). If this is unset and a layer has no compressed blob in the
   * engine's cache, then it will be compressed using Gzip.
   */
  forcedCompression?: ImageLayerCompression

  /**
   * Use the specified media types for the published image's layers. Defaults to OCI, which
   * is largely compatible with most recent registries, but Docker may be needed for older
   * registries without OCI support.
   */
  mediaTypes?: ImageMediaTypes
}

export type ContainerWithDefaultArgsOpts = {
  /**
   * Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
   */
  args?: string[]
}

export type ContainerWithDirectoryOpts = {
  /**
   * Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
   */
  exclude?: string[]

  /**
   * Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
   */
  include?: string[]

  /**
   * A user:group to set for the directory and its contents.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithEnvVariableOpts = {
  /**
   * Replace ${VAR} or $VAR in the value according to the current environment
   * variables defined in the container (e.g., "/opt/bin:$PATH").
   */
  expand?: boolean
}

export type ContainerWithExecOpts = {
  /**
   * If the container has an entrypoint, ignore it for args rather than using it to wrap them.
   */
  skipEntrypoint?: boolean

  /**
   * Content to write to the command's standard input before closing (e.g., "Hello world").
   */
  stdin?: string

  /**
   * Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
   */
  redirectStdout?: string

  /**
   * Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
   */
  redirectStderr?: string

  /**
   * Provides dagger access to the executed command.
   *
   * Do not use this option unless you trust the command being executed.
   * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   */
  experimentalPrivilegedNesting?: boolean

  /**
   * Execute the command with all root capabilities. This is similar to running a command
   * with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
   * does not provide any security guarantees when using this option. It should only be used
   * when absolutely necessary and only with trusted commands.
   */
  insecureRootCapabilities?: boolean
}

export type ContainerWithExposedPortOpts = {
  /**
   * Transport layer network protocol
   */
  protocol?: NetworkProtocol

  /**
   * Optional port description
   */
  description?: string
}

export type ContainerWithFileOpts = {
  /**
   * Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   */
  permissions?: number

  /**
   * A user:group to set for the file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithMountedCacheOpts = {
  /**
   * Identifier of the directory to use as the cache volume's root.
   */
  source?: Directory

  /**
   * Sharing mode of the cache volume.
   */
  sharing?: CacheSharingMode

  /**
   * A user:group to set for the mounted cache directory.
   *
   * Note that this changes the ownership of the specified mount along with the
   * initial filesystem provided by source (if any). It does not have any effect
   * if/when the cache has already been created.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithMountedDirectoryOpts = {
  /**
   * A user:group to set for the mounted directory and its contents.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithMountedFileOpts = {
  /**
   * A user or user:group to set for the mounted file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithMountedSecretOpts = {
  /**
   * A user:group to set for the mounted secret.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithNewFileOpts = {
  /**
   * Content of the file to write (e.g., "Hello world!").
   */
  contents?: string

  /**
   * Permission given to the written file (e.g., 0600).
   *
   * Default: 0644.
   */
  permissions?: number

  /**
   * A user:group to set for the file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithUnixSocketOpts = {
  /**
   * A user:group to set for the mounted socket.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  owner?: string
}

export type ContainerWithoutExposedPortOpts = {
  /**
   * Port protocol to unexpose
   */
  protocol?: NetworkProtocol
}

/**
 * A unique container identifier. Null designates an empty container (scratch).
 */
export type ContainerID = string & { __ContainerID: never }

/**
 * The `DateTime` scalar type represents a DateTime. The DateTime is serialized as an RFC 3339 quoted string
 */
export type DateTime = string & { __DateTime: never }

export type DirectoryDockerBuildOpts = {
  /**
   * Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
   *
   * Defaults: './Dockerfile'.
   */
  dockerfile?: string

  /**
   * The platform to build.
   */
  platform?: Platform

  /**
   * Build arguments to use in the build.
   */
  buildArgs?: BuildArg[]

  /**
   * Target build stage to build.
   */
  target?: string

  /**
   * Secrets to pass to the build.
   *
   * They will be mounted at /run/secrets/[secret-name].
   */
  secrets?: Secret[]
}

export type DirectoryEntriesOpts = {
  /**
   * Location of the directory to look at (e.g., "/src").
   */
  path?: string
}

export type DirectoryPipelineOpts = {
  /**
   * Pipeline description.
   */
  description?: string

  /**
   * Pipeline labels.
   */
  labels?: PipelineLabel[]
}

export type DirectoryWithDirectoryOpts = {
  /**
   * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
   */
  exclude?: string[]

  /**
   * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
   */
  include?: string[]
}

export type DirectoryWithFileOpts = {
  /**
   * Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   */
  permissions?: number
}

export type DirectoryWithNewDirectoryOpts = {
  /**
   * Permission granted to the created directory (e.g., 0777).
   *
   * Default: 0755.
   */
  permissions?: number
}

export type DirectoryWithNewFileOpts = {
  /**
   * Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   */
  permissions?: number
}

/**
 * A content-addressed directory identifier.
 */
export type DirectoryID = string & { __DirectoryID: never }

export type EnvironmentArtifactWithFlagOpts = {
  description?: string
}

export type EnvironmentArtifactID = string & { __EnvironmentArtifactID: never }

export type EnvironmentCheckWithFlagOpts = {
  description?: string
}

/**
 * A unique environment check identifier.
 */
export type EnvironmentCheckID = string & { __EnvironmentCheckID: never }

export type EnvironmentCheckResultID = string & {
  __EnvironmentCheckResultID: never
}

export type EnvironmentCommandWithFlagOpts = {
  description?: string
}

/**
 * A unique environment command identifier.
 */
export type EnvironmentCommandID = string & { __EnvironmentCommandID: never }

export type EnvironmentFunctionWithArgOpts = {
  isOptional?: boolean
  description?: string
}

/**
 * A unique environment function identifier.
 */
export type EnvironmentFunctionID = string & { __EnvironmentFunctionID: never }

/**
 * A unique environment identifier.
 */
export type EnvironmentID = string & { __EnvironmentID: never }

export type EnvironmentShellWithFlagOpts = {
  description?: string
}

/**
 * A unique environment shell identifier.
 */
export type EnvironmentShellID = string & { __EnvironmentShellID: never }

export type FileExportOpts = {
  /**
   * If allowParentDirPath is true, the path argument can be a directory path, in which case
   * the file will be created in that directory.
   */
  allowParentDirPath?: boolean
}

/**
 * A file identifier.
 */
export type FileID = string & { __FileID: never }

export type GitRefTreeOpts = {
  sshKnownHosts?: string
  sshAuthSocket?: Socket
}

export type GoBuildOpts = {
  packages?: string[]
  subdir?: string
  xdefs?: string[]
  static?: boolean
  race?: boolean
  goos?: string
  goarch?: string
  buildFlags?: string[]
}

export type GoGolangCilintOpts = {
  verbose?: boolean
  timeout?: number
}

export type GoGotestsumOpts = {
  packages?: string[]
  format?: string
  race?: boolean
  goTestFlags?: string[]
  gotestsumFlags?: string[]
}

export type GoTestOpts = {
  packages?: string[]
  race?: boolean
  verbose?: boolean
  testFlags?: string[]
}

export type HostDirectoryOpts = {
  /**
   * Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
   */
  exclude?: string[]

  /**
   * Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
   */
  include?: string[]
}

/**
 * The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
 */
export type ID = string & { __ID: never }

/**
 * Compression algorithm to use for image layers.
 */
export enum ImageLayerCompression {
  Estargz,
  Gzip,
  Uncompressed,
  Zstd,
}
/**
 * Mediatypes to use in published or exported image metadata.
 */
export enum ImageMediaTypes {
  Dockermediatypes,
  Ocimediatypes,
}
/**
 * Transport layer network protocol associated to a port.
 */
export enum NetworkProtocol {
  /**
   * TCP (Transmission Control Protocol)
   */
  Tcp,

  /**
   * UDP (User Datagram Protocol)
   */
  Udp,
}
export type PipelineLabel = {
  /**
   * Label name.
   */
  name: string

  /**
   * Label value.
   */
  value: string
}

/**
 * The platform config OS and architecture in a Container.
 *
 * The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
 */
export type Platform = string & { __Platform: never }

export type ClientContainerOpts = {
  id?: ContainerID
  platform?: Platform
}

export type ClientDirectoryOpts = {
  id?: DirectoryID
}

export type ClientEnvironmentOpts = {
  id?: EnvironmentID
}

export type ClientEnvironmentArtifactOpts = {
  id?: EnvironmentArtifactID
}

export type ClientEnvironmentCheckOpts = {
  id?: EnvironmentCheckID
}

export type ClientEnvironmentCheckResultOpts = {
  id?: EnvironmentCheckResultID
}

export type ClientEnvironmentCommandOpts = {
  id?: EnvironmentCommandID
}

export type ClientEnvironmentFunctionOpts = {
  id?: EnvironmentFunctionID
}

export type ClientEnvironmentShellOpts = {
  id?: EnvironmentShellID
}

export type ClientGitOpts = {
  /**
   * Set to true to keep .git directory.
   */
  keepGitDir?: boolean

  /**
   * A service which must be started before the repo is fetched.
   */
  experimentalServiceHost?: Container
}

export type ClientHttpOpts = {
  /**
   * A service which must be started before the URL is fetched.
   */
  experimentalServiceHost?: Container
}

export type ClientPipelineOpts = {
  /**
   * Pipeline description.
   */
  description?: string

  /**
   * Pipeline labels.
   */
  labels?: PipelineLabel[]
}

export type ClientSocketOpts = {
  id?: SocketID
}

/**
 * A unique identifier for a secret.
 */
export type SecretID = string & { __SecretID: never }

/**
 * A content-addressed socket identifier.
 */
export type SocketID = string & { __SocketID: never }

export type __TypeEnumValuesOpts = {
  includeDeprecated?: boolean
}

export type __TypeFieldsOpts = {
  includeDeprecated?: boolean
}

export class Apko extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }
  alpine(packages: string[]): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "alpine",
          args: { packages },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  wolfi(packages: string[]): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "wolfi",
          args: { packages },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A directory whose contents persist across runs.
 */
export class CacheVolume extends BaseClient {
  private readonly _id?: CacheID = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _id?: CacheID
  ) {
    super(parent)

    this._id = _id
  }
  async id(): Promise<CacheID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<CacheID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * An OCI-compatible container, also known as a docker container.
 */
export class Container extends BaseClient {
  private readonly _endpoint?: string = undefined
  private readonly _envVariable?: string = undefined
  private readonly _export?: boolean = undefined
  private readonly _hostname?: string = undefined
  private readonly _id?: ContainerID = undefined
  private readonly _imageRef?: string = undefined
  private readonly _label?: string = undefined
  private readonly _platform?: Platform = undefined
  private readonly _publish?: string = undefined
  private readonly _sbom?: string = undefined
  private readonly _shellEndpoint?: string = undefined
  private readonly _stderr?: string = undefined
  private readonly _stdout?: string = undefined
  private readonly _sync?: ContainerID = undefined
  private readonly _user?: string = undefined
  private readonly _version?: string = undefined
  private readonly _workdir?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _endpoint?: string,
    _envVariable?: string,
    _export?: boolean,
    _hostname?: string,
    _id?: ContainerID,
    _imageRef?: string,
    _label?: string,
    _platform?: Platform,
    _publish?: string,
    _sbom?: string,
    _shellEndpoint?: string,
    _stderr?: string,
    _stdout?: string,
    _sync?: ContainerID,
    _user?: string,
    _version?: string,
    _workdir?: string
  ) {
    super(parent)

    this._endpoint = _endpoint
    this._envVariable = _envVariable
    this._export = _export
    this._hostname = _hostname
    this._id = _id
    this._imageRef = _imageRef
    this._label = _label
    this._platform = _platform
    this._publish = _publish
    this._sbom = _sbom
    this._shellEndpoint = _shellEndpoint
    this._stderr = _stderr
    this._stdout = _stdout
    this._sync = _sync
    this._user = _user
    this._version = _version
    this._workdir = _workdir
  }

  /**
   * Initializes this container from a Dockerfile build.
   * @param context Directory context used by the Dockerfile.
   * @param opts.dockerfile Path to the Dockerfile to use.
   *
   * Default: './Dockerfile'.
   * @param opts.buildArgs Additional build arguments.
   * @param opts.target Target build stage to build.
   * @param opts.secrets Secrets to pass to the build.
   *
   * They will be mounted at /run/secrets/[secret-name].
   */
  build(context: Directory, opts?: ContainerBuildOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "build",
          args: { context, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves default arguments for future commands.
   */
  async defaultArgs(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "defaultArgs",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a directory at the given path.
   *
   * Mounts are included.
   * @param path The path of the directory to retrieve (e.g., "./src").
   */
  directory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves an endpoint that clients can use to reach this container.
   *
   * If no port is specified, the first exposed port is used. If none exist an error is returned.
   *
   * If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   * @param opts.port The exposed port number for the endpoint
   * @param opts.scheme Return a URL with the given scheme, eg. http for http://
   */
  async endpoint(opts?: ContainerEndpointOpts): Promise<string> {
    if (this._endpoint) {
      return this._endpoint
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "endpoint",
          args: { ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves entrypoint to be prepended to the arguments of all commands.
   */
  async entrypoint(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "entrypoint",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the value of the specified environment variable.
   * @param name The name of the environment variable to retrieve (e.g., "PATH").
   */
  async envVariable(name: string): Promise<string> {
    if (this._envVariable) {
      return this._envVariable
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "envVariable",
          args: { name },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the list of environment variables passed to commands.
   */
  async envVariables(): Promise<EnvVariable[]> {
    type envVariables = {
      name: string
      value: string
    }

    const response: Awaited<envVariables[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "envVariables",
        },
        {
          operation: "name value",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvVariable(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.name,
          r.value
        )
    )
  }

  /**
   * Writes the container as an OCI tarball to the destination file path on the host for the specified platform variants.
   *
   * Return true on success.
   * It can also publishes platform variants.
   * @param path Host's destination path (e.g., "./tarball").
   * Path can be relative to the engine's workdir or absolute.
   * @param opts.platformVariants Identifiers for other platform specific containers.
   * Used for multi-platform image.
   * @param opts.forcedCompression Force each layer of the exported image to use the specified compression algorithm.
   * If this is unset, then if a layer already has a compressed blob in the engine's
   * cache, that will be used (this can result in a mix of compression algorithms for
   * different layers). If this is unset and a layer has no compressed blob in the
   * engine's cache, then it will be compressed using Gzip.
   * @param opts.mediaTypes Use the specified media types for the exported image's layers. Defaults to OCI, which
   * is largely compatible with most recent container runtimes, but Docker may be needed
   * for older runtimes without OCI support.
   */
  async export(path: string, opts?: ContainerExportOpts): Promise<boolean> {
    if (this._export) {
      return this._export
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path, ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the list of exposed ports.
   *
   * This includes ports already exposed by the image, even if not
   * explicitly added with dagger.
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   */
  async exposedPorts(): Promise<Port[]> {
    type exposedPorts = {
      description: string
      port: number
      protocol: NetworkProtocol
    }

    const response: Awaited<exposedPorts[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "exposedPorts",
        },
        {
          operation: "description port protocol",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new Port(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.description,
          r.port,
          r.protocol
        )
    )
  }

  /**
   * Retrieves a file at the given path.
   *
   * Mounts are included.
   * @param path The path of the file to retrieve (e.g., "./README.md").
   */
  file(path: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Initializes this container from a pulled base image.
   * @param address Image's address from its registry.
   *
   * Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
   */
  from(address: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "from",
          args: { address },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves a hostname which can be used by clients to reach this container.
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   */
  async hostname(): Promise<string> {
    if (this._hostname) {
      return this._hostname
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "hostname",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * A unique identifier for this container.
   */
  async id(): Promise<ContainerID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<ContainerID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The unique image reference which can only be retrieved immediately after the 'Container.From' call.
   */
  async imageRef(): Promise<string> {
    if (this._imageRef) {
      return this._imageRef
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "imageRef",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Reads the container from an OCI tarball.
   *
   * NOTE: this involves unpacking the tarball to an OCI store on the host at
   * $XDG_CACHE_DIR/dagger/oci. This directory can be removed whenever you like.
   * @param source File to read the container from.
   * @param opts.tag Identifies the tag to import from the archive, if the archive bundles
   * multiple tags.
   */
  import(source: File, opts?: ContainerImportOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "import",
          args: { source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves the value of the specified label.
   */
  async label(name: string): Promise<string> {
    if (this._label) {
      return this._label
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "label",
          args: { name },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the list of labels passed to container.
   */
  async labels(): Promise<Label[]> {
    type labels = {
      name: string
      value: string
    }

    const response: Awaited<labels[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "labels",
        },
        {
          operation: "name value",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new Label(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.name,
          r.value
        )
    )
  }

  /**
   * Retrieves the list of paths where a directory is mounted.
   */
  async mounts(): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "mounts",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Creates a named sub-pipeline
   * @param name Pipeline name.
   * @param opts.description Pipeline description.
   * @param opts.labels Pipeline labels.
   */
  pipeline(name: string, opts?: ContainerPipelineOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "pipeline",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The platform this container executes and publishes as.
   */
  async platform(): Promise<Platform> {
    if (this._platform) {
      return this._platform
    }

    const response: Awaited<Platform> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "platform",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Publishes this container as a new image to the specified address.
   *
   * Publish returns a fully qualified ref.
   * It can also publish platform variants.
   * @param address Registry's address to publish the image to.
   *
   * Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
   * @param opts.platformVariants Identifiers for other platform specific containers.
   * Used for multi-platform image.
   * @param opts.forcedCompression Force each layer of the published image to use the specified compression algorithm.
   * If this is unset, then if a layer already has a compressed blob in the engine's
   * cache, that will be used (this can result in a mix of compression algorithms for
   * different layers). If this is unset and a layer has no compressed blob in the
   * engine's cache, then it will be compressed using Gzip.
   * @param opts.mediaTypes Use the specified media types for the published image's layers. Defaults to OCI, which
   * is largely compatible with most recent registries, but Docker may be needed for older
   * registries without OCI support.
   */
  async publish(address: string, opts?: ContainerPublishOpts): Promise<string> {
    if (this._publish) {
      return this._publish
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "publish",
          args: { address, ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves this container's root filesystem. Mounts are not included.
   */
  rootfs(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "rootfs",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  async sbom(): Promise<string> {
    if (this._sbom) {
      return this._sbom
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sbom",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async shellEndpoint(): Promise<string> {
    if (this._shellEndpoint) {
      return this._shellEndpoint
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "shellEndpoint",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The error stream of the last executed command.
   *
   * Will execute default command if none is set, or error if there's no default.
   */
  async stderr(): Promise<string> {
    if (this._stderr) {
      return this._stderr
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "stderr",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The output stream of the last executed command.
   *
   * Will execute default command if none is set, or error if there's no default.
   */
  async stdout(): Promise<string> {
    if (this._stdout) {
      return this._stdout
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "stdout",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Forces evaluation of the pipeline in the engine.
   *
   * It doesn't run the default command if no exec has been set.
   */
  async sync(): Promise<Container> {
    await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sync",
        },
      ],
      this.client
    )

    return this
  }

  /**
   * Retrieves the user to be set for all commands.
   */
  async user(): Promise<string> {
    if (this._user) {
      return this._user
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "user",
        },
      ],
      this.client
    )

    return response
  }
  async version(): Promise<string> {
    if (this._version) {
      return this._version
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "version",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Configures default arguments for future commands.
   * @param opts.args Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
   */
  withDefaultArgs(opts?: ContainerWithDefaultArgsOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDefaultArgs",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a directory written at the given path.
   * @param path Location of the written directory (e.g., "/tmp/directory").
   * @param directory Identifier of the directory to write
   * @param opts.exclude Patterns to exclude in the written directory (e.g., ["node_modules/**", ".gitignore", ".git/"]).
   * @param opts.include Patterns to include in the written directory (e.g., ["*.go", "go.mod", "go.sum"]).
   * @param opts.owner A user:group to set for the directory and its contents.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withDirectory(
    path: string,
    directory: Directory,
    opts?: ContainerWithDirectoryOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDirectory",
          args: { path, directory, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container but with a different command entrypoint.
   * @param args Entrypoint to use for future executions (e.g., ["go", "run"]).
   */
  withEntrypoint(args: string[]): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withEntrypoint",
          args: { args },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus the given environment variable.
   * @param name The name of the environment variable (e.g., "HOST").
   * @param value The value of the environment variable. (e.g., "localhost").
   * @param opts.expand Replace ${VAR} or $VAR in the value according to the current environment
   * variables defined in the container (e.g., "/opt/bin:$PATH").
   */
  withEnvVariable(
    name: string,
    value: string,
    opts?: ContainerWithEnvVariableOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withEnvVariable",
          args: { name, value, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container after executing the specified command inside it.
   * @param args Command to run instead of the container's default command (e.g., ["run", "main.go"]).
   *
   * If empty, the container's default command is used.
   * @param opts.skipEntrypoint If the container has an entrypoint, ignore it for args rather than using it to wrap them.
   * @param opts.stdin Content to write to the command's standard input before closing (e.g., "Hello world").
   * @param opts.redirectStdout Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
   * @param opts.redirectStderr Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
   * @param opts.experimentalPrivilegedNesting Provides dagger access to the executed command.
   *
   * Do not use this option unless you trust the command being executed.
   * The command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
   * @param opts.insecureRootCapabilities Execute the command with all root capabilities. This is similar to running a command
   * with "sudo" or executing `docker run` with the `--privileged` flag. Containerization
   * does not provide any security guarantees when using this option. It should only be used
   * when absolutely necessary and only with trusted commands.
   */
  withExec(args: string[], opts?: ContainerWithExecOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withExec",
          args: { args, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Expose a network port.
   *
   * Exposed ports serve two purposes:
   *   - For health checks and introspection, when running services
   *   - For setting the EXPOSE OCI field when publishing the container
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   * @param port Port number to expose
   * @param opts.protocol Transport layer network protocol
   * @param opts.description Optional port description
   */
  withExposedPort(
    port: number,
    opts?: ContainerWithExposedPortOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withExposedPort",
          args: { port, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus the contents of the given file copied to the given path.
   * @param path Location of the copied file (e.g., "/tmp/file.txt").
   * @param source Identifier of the file to copy.
   * @param opts.permissions Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   * @param opts.owner A user:group to set for the file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withFile(
    path: string,
    source: File,
    opts?: ContainerWithFileOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFile",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Indicate that subsequent operations should be featured more prominently in
   * the UI.
   */
  withFocus(): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFocus",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus the given label.
   * @param name The name of the label (e.g., "org.opencontainers.artifact.created").
   * @param value The value of the label (e.g., "2023-01-01T00:00:00Z").
   */
  withLabel(name: string, value: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withLabel",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a cache volume mounted at the given path.
   * @param path Location of the cache directory (e.g., "/cache/node_modules").
   * @param cache Identifier of the cache volume to mount.
   * @param opts.source Identifier of the directory to use as the cache volume's root.
   * @param opts.sharing Sharing mode of the cache volume.
   * @param opts.owner A user:group to set for the mounted cache directory.
   *
   * Note that this changes the ownership of the specified mount along with the
   * initial filesystem provided by source (if any). It does not have any effect
   * if/when the cache has already been created.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withMountedCache(
    path: string,
    cache: CacheVolume,
    opts?: ContainerWithMountedCacheOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedCache",
          args: { path, cache, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a directory mounted at the given path.
   * @param path Location of the mounted directory (e.g., "/mnt/directory").
   * @param source Identifier of the mounted directory.
   * @param opts.owner A user:group to set for the mounted directory and its contents.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withMountedDirectory(
    path: string,
    source: Directory,
    opts?: ContainerWithMountedDirectoryOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedDirectory",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a file mounted at the given path.
   * @param path Location of the mounted file (e.g., "/tmp/file.txt").
   * @param source Identifier of the mounted file.
   * @param opts.owner A user or user:group to set for the mounted file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withMountedFile(
    path: string,
    source: File,
    opts?: ContainerWithMountedFileOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedFile",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a secret mounted into a file at the given path.
   * @param path Location of the secret file (e.g., "/tmp/secret.txt").
   * @param source Identifier of the secret to mount.
   * @param opts.owner A user:group to set for the mounted secret.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withMountedSecret(
    path: string,
    source: Secret,
    opts?: ContainerWithMountedSecretOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedSecret",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a temporary directory mounted at the given path.
   * @param path Location of the temporary directory (e.g., "/tmp/temp_dir").
   */
  withMountedTemp(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withMountedTemp",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a new file written at the given path.
   * @param path Location of the written file (e.g., "/tmp/file.txt").
   * @param opts.contents Content of the file to write (e.g., "Hello world!").
   * @param opts.permissions Permission given to the written file (e.g., 0600).
   *
   * Default: 0644.
   * @param opts.owner A user:group to set for the file.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withNewFile(path: string, opts?: ContainerWithNewFileOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewFile",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a registry authentication for a given address.
   * @param address Registry's address to bind the authentication to.
   * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
   * @param username The username of the registry's account (e.g., "Dagger").
   * @param secret The API key, password or token to authenticate to this registry.
   */
  withRegistryAuth(
    address: string,
    username: string,
    secret: Secret
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withRegistryAuth",
          args: { address, username, secret },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Initializes this container from this DirectoryID.
   */
  withRootfs(directory: Directory): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withRootfs",
          args: { directory },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus an env variable containing the given secret.
   * @param name The name of the secret variable (e.g., "API_SECRET").
   * @param secret The identifier of the secret value.
   */
  withSecretVariable(name: string, secret: Secret): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withSecretVariable",
          args: { name, secret },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Establish a runtime dependency on a service.
   *
   * The service will be started automatically when needed and detached when it is
   * no longer needed, executing the default command if none is set.
   *
   * The service will be reachable from the container via the provided hostname alias.
   *
   * The service dependency will also convey to any files or directories produced by the container.
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   * @param alias A name that can be used to reach the service from the container
   * @param service Identifier of the service container
   */
  withServiceBinding(alias: string, service: Container): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withServiceBinding",
          args: { alias, service },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container plus a socket forwarded to the given Unix socket path.
   * @param path Location of the forwarded Unix socket (e.g., "/tmp/socket").
   * @param source Identifier of the socket to forward.
   * @param opts.owner A user:group to set for the mounted socket.
   *
   * The user and group can either be an ID (1000:1000) or a name (foo:bar).
   *
   * If the group is omitted, it defaults to the same as the user.
   */
  withUnixSocket(
    path: string,
    source: Socket,
    opts?: ContainerWithUnixSocketOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withUnixSocket",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a different command user.
   * @param name The user to set (e.g., "root").
   */
  withUser(name: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withUser",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withVersion(version: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withVersion",
          args: { version },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a different working directory.
   * @param path The path to set as the working directory (e.g., "/app").
   */
  withWorkdir(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withWorkdir",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container minus the given environment variable.
   * @param name The name of the environment variable (e.g., "HOST").
   */
  withoutEnvVariable(name: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutEnvVariable",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Unexpose a previously exposed port.
   *
   * Currently experimental; set _EXPERIMENTAL_DAGGER_SERVICES_DNS=0 to disable.
   * @param port Port number to unexpose
   * @param opts.protocol Port protocol to unexpose
   */
  withoutExposedPort(
    port: number,
    opts?: ContainerWithoutExposedPortOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutExposedPort",
          args: { port, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Indicate that subsequent operations should not be featured more prominently
   * in the UI.
   *
   * This is the initial state of all containers.
   */
  withoutFocus(): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutFocus",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container minus the given environment label.
   * @param name The name of the label to remove (e.g., "org.opencontainers.artifact.created").
   */
  withoutLabel(name: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutLabel",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container after unmounting everything at the given path.
   * @param path Location of the cache directory (e.g., "/cache/node_modules").
   */
  withoutMount(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutMount",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container without the registry authentication of a given address.
   * @param address Registry's address to remove the authentication from.
   * Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
   */
  withoutRegistryAuth(address: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutRegistryAuth",
          args: { address },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this container with a previously added Unix socket removed.
   * @param path Location of the socket to remove (e.g., "/tmp/socket").
   */
  withoutUnixSocket(path: string): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutUnixSocket",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves the working directory for all commands.
   */
  async workdir(): Promise<string> {
    if (this._workdir) {
      return this._workdir
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "workdir",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Call the provided function with current Container.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: Container) => Container) {
    return arg(this)
  }
}

export class Dagger extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * Build the Dagger CLI
   */
  cli(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "cli",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  devShell(): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "devShell",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Lint the Dagger engine code
   */
  engineLint(): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "engineLint",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Lint the Nodejs SDK
   */
  nodejsLint(): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "nodejsLint",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

export class Daggergo extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * Lint the Dagger Go SDK
   * TODO: once namespacing is in place, can just name this "Lint"
   */
  goLint(): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "goLint",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

export class Daggerpython extends BaseClient {
  private readonly _publish?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _publish?: string
  ) {
    super(parent)

    this._publish = _publish
  }

  /**
   * Lint the Python SDK
   */
  lint(): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "lint",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Publish the client.
   */
  async publish(): Promise<string> {
    if (this._publish) {
      return this._publish
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "publish",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A directory.
 */
export class Directory extends BaseClient {
  private readonly _export?: boolean = undefined
  private readonly _id?: DirectoryID = undefined
  private readonly _sbom?: string = undefined
  private readonly _sync?: DirectoryID = undefined
  private readonly _version?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _export?: boolean,
    _id?: DirectoryID,
    _sbom?: string,
    _sync?: DirectoryID,
    _version?: string
  ) {
    super(parent)

    this._export = _export
    this._id = _id
    this._sbom = _sbom
    this._sync = _sync
    this._version = _version
  }

  /**
   * Gets the difference between this directory and an another directory.
   * @param other Identifier of the directory to compare.
   */
  diff(other: Directory): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "diff",
          args: { other },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves a directory at the given path.
   * @param path Location of the directory to retrieve (e.g., "/src").
   */
  directory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Builds a new Docker container from this directory.
   * @param opts.dockerfile Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
   *
   * Defaults: './Dockerfile'.
   * @param opts.platform The platform to build.
   * @param opts.buildArgs Build arguments to use in the build.
   * @param opts.target Target build stage to build.
   * @param opts.secrets Secrets to pass to the build.
   *
   * They will be mounted at /run/secrets/[secret-name].
   */
  dockerBuild(opts?: DirectoryDockerBuildOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "dockerBuild",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns a list of files and directories at the given path.
   * @param opts.path Location of the directory to look at (e.g., "/src").
   */
  async entries(opts?: DirectoryEntriesOpts): Promise<string[]> {
    const response: Awaited<string[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "entries",
          args: { ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Writes the contents of the directory to a path on the host.
   * @param path Location of the copied directory (e.g., "logs/").
   */
  async export(path: string): Promise<boolean> {
    if (this._export) {
      return this._export
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves a file at the given path.
   * @param path Location of the file to retrieve (e.g., "README.md").
   */
  file(path: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The content-addressed identifier of the directory.
   */
  async id(): Promise<DirectoryID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<DirectoryID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
  async labels(): Promise<Label[]> {
    type labels = {
      name: string
      value: string
    }

    const response: Awaited<labels[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "labels",
        },
        {
          operation: "name value",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new Label(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.name,
          r.value
        )
    )
  }

  /**
   * Creates a named sub-pipeline
   * @param name Pipeline name.
   * @param opts.description Pipeline description.
   * @param opts.labels Pipeline labels.
   */
  pipeline(name: string, opts?: DirectoryPipelineOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "pipeline",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  async sbom(): Promise<string> {
    if (this._sbom) {
      return this._sbom
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sbom",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Force evaluation in the engine.
   */
  async sync(): Promise<Directory> {
    await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sync",
        },
      ],
      this.client
    )

    return this
  }

  /**
   * TODO
   */
  async version(): Promise<string> {
    if (this._version) {
      return this._version
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "version",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves this directory plus a directory written at the given path.
   * @param path Location of the written directory (e.g., "/src/").
   * @param directory Identifier of the directory to copy.
   * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
   * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
   */
  withDirectory(
    path: string,
    directory: Directory,
    opts?: DirectoryWithDirectoryOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDirectory",
          args: { path, directory, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus the contents of the given file copied to the given path.
   * @param path Location of the copied file (e.g., "/file.txt").
   * @param source Identifier of the file to copy.
   * @param opts.permissions Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   */
  withFile(
    path: string,
    source: File,
    opts?: DirectoryWithFileOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFile",
          args: { path, source, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withLabel(name: string, value: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withLabel",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus a new directory created at the given path.
   * @param path Location of the directory created (e.g., "/logs").
   * @param opts.permissions Permission granted to the created directory (e.g., 0777).
   *
   * Default: 0755.
   */
  withNewDirectory(
    path: string,
    opts?: DirectoryWithNewDirectoryOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewDirectory",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory plus a new file written at the given path.
   * @param path Location of the written file (e.g., "/file.txt").
   * @param contents Content of the written file (e.g., "Hello world!").
   * @param opts.permissions Permission given to the copied file (e.g., 0600).
   *
   * Default: 0644.
   */
  withNewFile(
    path: string,
    contents: string,
    opts?: DirectoryWithNewFileOpts
  ): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withNewFile",
          args: { path, contents, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with all file/dir timestamps set to the given time.
   * @param timestamp Timestamp to set dir/files in.
   *
   * Formatted in seconds following Unix epoch (e.g., 1672531199).
   */
  withTimestamps(timestamp: number): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withTimestamps",
          args: { timestamp },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withVersion(version: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withVersion",
          args: { version },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with the directory at the given path removed.
   * @param path Location of the directory to remove (e.g., ".github/").
   */
  withoutDirectory(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutDirectory",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this directory with the file at the given path removed.
   * @param path Location of the file to remove (e.g., "/file.txt").
   */
  withoutFile(path: string): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withoutFile",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current Directory.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: Directory) => Directory) {
    return arg(this)
  }
}

/**
 * A simple key value object that represents an environment variable.
 */
export class EnvVariable extends BaseClient {
  private readonly _name?: string = undefined
  private readonly _value?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _name?: string,
    _value?: string
  ) {
    super(parent)

    this._name = _name
    this._value = _value
  }

  /**
   * The environment variable name.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The environment variable value.
   */
  async value(): Promise<string> {
    if (this._value) {
      return this._value
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "value",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A collection of Dagger resources that can be queried and invoked.
 */
export class Environment extends BaseClient {
  private readonly _id?: EnvironmentID = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _id?: EnvironmentID,
    _name?: string
  ) {
    super(parent)

    this._id = _id
    this._name = _name
  }
  artifact(name: string): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "artifact",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  async artifacts(): Promise<EnvironmentArtifact[]> {
    type artifacts = {
      id: EnvironmentArtifactID
    }

    const response: Awaited<artifacts[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "artifacts",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentArtifact(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }

  /**
   * TODO
   */
  check(name: string): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "check",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  async checks(): Promise<EnvironmentCheck[]> {
    type checks = {
      id: EnvironmentCheckID
    }

    const response: Awaited<checks[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "checks",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCheck(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }

  /**
   * TODO
   */
  command(name: string): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "command",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Commands provided by this environment
   */
  async commands(): Promise<EnvironmentCommand[]> {
    type commands = {
      id: EnvironmentCommandID
    }

    const response: Awaited<commands[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "commands",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCommand(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }

  /**
   * A unique identifier for this environment.
   */
  async id(): Promise<EnvironmentID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Initialize this environment from the given directory and config path
   */
  load(source: Directory, configPath: string): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "load",
          args: { source, configPath },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Name of the environment
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO: the runtime container for the environment
   */
  runtime(): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "runtime",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  shell(name: string): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "shell",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  async shells(): Promise<EnvironmentShell[]> {
    type shells = {
      id: EnvironmentShellID
    }

    const response: Awaited<shells[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "shells",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentShell(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }
  withArtifact(id: EnvironmentArtifact): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withArtifact",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withCheck(id: EnvironmentCheck): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withCheck",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withCommand(id: EnvironmentCommand): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withCommand",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withExtension(id: Environment, namespace: string): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withExtension",
          args: { id, namespace },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withFunction(id: EnvironmentFunction): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFunction",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withShell(id: EnvironmentShell): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withShell",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current Environment.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: Environment) => Environment) {
    return arg(this)
  }
}

export class EnvironmentArtifact extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _export?: boolean = undefined
  private readonly _id?: EnvironmentArtifactID = undefined
  private readonly _name?: string = undefined
  private readonly _sbom?: string = undefined
  private readonly _version?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _export?: boolean,
    _id?: EnvironmentArtifactID,
    _name?: string,
    _sbom?: string,
    _version?: string
  ) {
    super(parent)

    this._description = _description
    this._export = _export
    this._id = _id
    this._name = _name
    this._sbom = _sbom
    this._version = _version
  }

  /**
   * TODO
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async export(path: string): Promise<boolean> {
    if (this._export) {
      return this._export
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Flags accepted by this artifact.
   */
  async flags(): Promise<EnvironmentArtifactFlag[]> {
    type flags = {
      description: string
      name: string
    }

    const response: Awaited<flags[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "flags",
        },
        {
          operation: "description name",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentArtifactFlag(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.description,
          r.name
        )
    )
  }
  async id(): Promise<EnvironmentArtifactID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentArtifactID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async labels(): Promise<Label[]> {
    type labels = {
      name: string
      value: string
    }

    const response: Awaited<labels[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "labels",
        },
        {
          operation: "name value",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new Label(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.name,
          r.value
        )
    )
  }

  /**
   * TODO
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async sbom(): Promise<string> {
    if (this._sbom) {
      return this._sbom
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sbom",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  setStringFlag(name: string, value: string): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setStringFlag",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  async version(): Promise<string> {
    if (this._version) {
      return this._version
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "version",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO: this doesn't feel right, has to be a better way w/ unions or interfaces
   */
  withContainer(container: Container): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withContainer",
          args: { container },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withDescription(description: string): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDescription",
          args: { description },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withDirectory(directory: Directory): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDirectory",
          args: { directory },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withFile(file: File): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFile",
          args: { file },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withFlag(
    name: string,
    opts?: EnvironmentArtifactWithFlagOpts
  ): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFlag",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withName(name: string): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentArtifact.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentArtifact) => EnvironmentArtifact) {
    return arg(this)
  }
}

export class EnvironmentArtifactFlag extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._name = _name
  }

  /**
   * Documentation for what this flag sets.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the flag.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * TODO
 */
export class EnvironmentCheck extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _id?: EnvironmentCheckID = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _id?: EnvironmentCheckID,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._id = _id
    this._name = _name
  }

  /**
   * Documentation for what this check checks.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Flags accepted by this check.
   */
  async flags(): Promise<EnvironmentCheckFlag[]> {
    type flags = {
      description: string
      name: string
    }

    const response: Awaited<flags[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "flags",
        },
        {
          operation: "description name",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCheckFlag(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.description,
          r.name
        )
    )
  }

  /**
   * A unique identifier for this check.
   */
  async id(): Promise<EnvironmentCheckID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentCheckID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the check.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  result(): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "result",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  setStringFlag(name: string, value: string): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setStringFlag",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  async subchecks(): Promise<EnvironmentCheck[]> {
    type subchecks = {
      id: EnvironmentCheckID
    }

    const response: Awaited<subchecks[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "subchecks",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCheck(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }

  /**
   * TODO
   */
  withContainer(id: Container): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withContainer",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withDescription(description: string): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDescription",
          args: { description },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withFlag(
    name: string,
    opts?: EnvironmentCheckWithFlagOpts
  ): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFlag",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withName(name: string): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withSubcheck(id: EnvironmentCheck): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withSubcheck",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentCheck.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentCheck) => EnvironmentCheck) {
    return arg(this)
  }
}

/**
 * A flag accepted by a environment check.
 */
export class EnvironmentCheckFlag extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._name = _name
  }

  /**
   * Documentation for what this flag sets.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the flag.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * TODO
 */
export class EnvironmentCheckResult extends BaseClient {
  private readonly _id?: EnvironmentCheckResultID = undefined
  private readonly _name?: string = undefined
  private readonly _output?: string = undefined
  private readonly _success?: boolean = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _id?: EnvironmentCheckResultID,
    _name?: string,
    _output?: string,
    _success?: boolean
  ) {
    super(parent)

    this._id = _id
    this._name = _name
    this._output = _output
    this._success = _success
  }
  async id(): Promise<EnvironmentCheckResultID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentCheckResultID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
  async output(): Promise<string> {
    if (this._output) {
      return this._output
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "output",
        },
      ],
      this.client
    )

    return response
  }
  async subresults(): Promise<EnvironmentCheckResult[]> {
    type subresults = {
      id: EnvironmentCheckResultID
    }

    const response: Awaited<subresults[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "subresults",
        },
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCheckResult(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.id
        )
    )
  }
  async success(): Promise<boolean> {
    if (this._success) {
      return this._success
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "success",
        },
      ],
      this.client
    )

    return response
  }
  withName(name: string): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withOutput(output: string): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withOutput",
          args: { output },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withSubresult(result: EnvironmentCheckResult): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withSubresult",
          args: { result },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withSuccess(success: boolean): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withSuccess",
          args: { success },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentCheckResult.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentCheckResult) => EnvironmentCheckResult) {
    return arg(this)
  }
}

/**
 * A command defined in a environment that can be invoked from the CLI.
 */
export class EnvironmentCommand extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _id?: EnvironmentCommandID = undefined
  private readonly _name?: string = undefined
  private readonly _resultType?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _id?: EnvironmentCommandID,
    _name?: string,
    _resultType?: string
  ) {
    super(parent)

    this._description = _description
    this._id = _id
    this._name = _name
    this._resultType = _resultType
  }

  /**
   * Documentation for what this command does.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Flags accepted by this command.
   */
  async flags(): Promise<EnvironmentCommandFlag[]> {
    type flags = {
      description: string
      name: string
    }

    const response: Awaited<flags[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "flags",
        },
        {
          operation: "description name",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentCommandFlag(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.description,
          r.name
        )
    )
  }

  /**
   * A unique identifier for this command.
   */
  async id(): Promise<EnvironmentCommandID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentCommandID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  invoke(): InvokeCommandResult {
    return new InvokeCommandResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "invoke",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The name of the command.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the type returned by this command.
   */
  async resultType(): Promise<string> {
    if (this._resultType) {
      return this._resultType
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "resultType",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO, can we make an input that's like map[string]any?
   */
  setStringFlag(name: string, value: string): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setStringFlag",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withDescription(description: string): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDescription",
          args: { description },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withFlag(
    name: string,
    opts?: EnvironmentCommandWithFlagOpts
  ): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFlag",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withName(name: string): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withResultType(name: string): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withResultType",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentCommand.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentCommand) => EnvironmentCommand) {
    return arg(this)
  }
}

/**
 * A flag accepted by a environment command.
 */
export class EnvironmentCommandFlag extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._name = _name
  }

  /**
   * Documentation for what this flag sets.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the flag.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * TODO
 */
export class EnvironmentFunction extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _id?: EnvironmentFunctionID = undefined
  private readonly _name?: string = undefined
  private readonly _resultType?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _id?: EnvironmentFunctionID,
    _name?: string,
    _resultType?: string
  ) {
    super(parent)

    this._description = _description
    this._id = _id
    this._name = _name
    this._resultType = _resultType
  }

  /**
   * TODO
   */
  async args(): Promise<EnvironmentFunctionArg[]> {
    type args = {
      argType: string
      description: string
      isList: boolean
      name: string
    }

    const response: Awaited<args[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "args",
        },
        {
          operation: "argType description isList name",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentFunctionArg(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.argType,
          r.description,
          r.isList,
          r.name
        )
    )
  }

  /**
   * TODO
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * A unique identifier for this function.
   */
  async id(): Promise<EnvironmentFunctionID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentFunctionID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the function.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the type returned by this function.
   */
  async resultType(): Promise<string> {
    if (this._resultType) {
      return this._resultType
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "resultType",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  withArg(
    name: string,
    argType: string,
    isList: boolean,
    opts?: EnvironmentFunctionWithArgOpts
  ): EnvironmentFunction {
    return new EnvironmentFunction({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withArg",
          args: { name, argType, isList, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withDescription(description: string): EnvironmentFunction {
    return new EnvironmentFunction({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDescription",
          args: { description },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withName(name: string): EnvironmentFunction {
    return new EnvironmentFunction({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withResultType(name: string): EnvironmentFunction {
    return new EnvironmentFunction({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withResultType",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentFunction.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentFunction) => EnvironmentFunction) {
    return arg(this)
  }
}

/**
 * TODO
 */
export class EnvironmentFunctionArg extends BaseClient {
  private readonly _argType?: string = undefined
  private readonly _description?: string = undefined
  private readonly _isList?: boolean = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _argType?: string,
    _description?: string,
    _isList?: boolean,
    _name?: string
  ) {
    super(parent)

    this._argType = _argType
    this._description = _description
    this._isList = _isList
    this._name = _name
  }

  /**
   * TODO, should be enum
   */
  async argType(): Promise<string> {
    if (this._argType) {
      return this._argType
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "argType",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Documentation for what this arg sets.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async isList(): Promise<boolean> {
    if (this._isList) {
      return this._isList
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "isList",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the arg.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * TODO
 */
export class EnvironmentShell extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _endpoint?: string = undefined
  private readonly _id?: EnvironmentShellID = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _endpoint?: string,
    _id?: EnvironmentShellID,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._endpoint = _endpoint
    this._id = _id
    this._name = _name
  }

  /**
   * Documentation for what this shell shells. TODO: fix
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  async endpoint(): Promise<string> {
    if (this._endpoint) {
      return this._endpoint
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "endpoint",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Flags accepted by this shell.
   */
  async flags(): Promise<EnvironmentShellFlag[]> {
    type flags = {
      description: string
      name: string
    }

    const response: Awaited<flags[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "flags",
        },
        {
          operation: "description name",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new EnvironmentShellFlag(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.description,
          r.name
        )
    )
  }

  /**
   * A unique identifier for this shell.
   */
  async id(): Promise<EnvironmentShellID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<EnvironmentShellID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the shell.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * TODO
   */
  setStringFlag(name: string, value: string): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setStringFlag",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withDescription(description: string): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withDescription",
          args: { description },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withFlag(
    name: string,
    opts?: EnvironmentShellWithFlagOpts
  ): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withFlag",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  withName(name: string): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withName",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current EnvironmentShell.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: EnvironmentShell) => EnvironmentShell) {
    return arg(this)
  }
}

/**
 * A flag accepted by a environment shell.
 */
export class EnvironmentShellFlag extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _name?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _name?: string
  ) {
    super(parent)

    this._description = _description
    this._name = _name
  }

  /**
   * Documentation for what this flag sets.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The name of the flag.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * TODO
 */
export class Extensions extends BaseClient {
  private readonly _dummy?: boolean = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _dummy?: boolean
  ) {
    super(parent)

    this._dummy = _dummy
  }

  /**
   * TODO: needed?
   */
  async dummy(): Promise<boolean> {
    if (this._dummy) {
      return this._dummy
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "dummy",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A file.
 */
export class File extends BaseClient {
  private readonly _contents?: string = undefined
  private readonly _export?: boolean = undefined
  private readonly _id?: FileID = undefined
  private readonly _sbom?: string = undefined
  private readonly _size?: number = undefined
  private readonly _sync?: FileID = undefined
  private readonly _version?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _contents?: string,
    _export?: boolean,
    _id?: FileID,
    _sbom?: string,
    _size?: number,
    _sync?: FileID,
    _version?: string
  ) {
    super(parent)

    this._contents = _contents
    this._export = _export
    this._id = _id
    this._sbom = _sbom
    this._size = _size
    this._sync = _sync
    this._version = _version
  }

  /**
   * Retrieves the contents of the file.
   */
  async contents(): Promise<string> {
    if (this._contents) {
      return this._contents
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "contents",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Writes the file to a file path on the host.
   * @param path Location of the written directory (e.g., "output.txt").
   * @param opts.allowParentDirPath If allowParentDirPath is true, the path argument can be a directory path, in which case
   * the file will be created in that directory.
   */
  async export(path: string, opts?: FileExportOpts): Promise<boolean> {
    if (this._export) {
      return this._export
    }

    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "export",
          args: { path, ...opts },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Retrieves the content-addressed identifier of the file.
   */
  async id(): Promise<FileID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<FileID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
  async labels(): Promise<Label[]> {
    type labels = {
      name: string
      value: string
    }

    const response: Awaited<labels[]> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "labels",
        },
        {
          operation: "name value",
        },
      ],
      this.client
    )

    return response.map(
      (r) =>
        new Label(
          {
            queryTree: this.queryTree,
            host: this.clientHost,
            sessionToken: this.sessionToken,
          },
          r.name,
          r.value
        )
    )
  }
  async sbom(): Promise<string> {
    if (this._sbom) {
      return this._sbom
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sbom",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Gets the size of the file, in bytes.
   */
  async size(): Promise<number> {
    if (this._size) {
      return this._size
    }

    const response: Awaited<number> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "size",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Force evaluation in the engine.
   */
  async sync(): Promise<File> {
    await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "sync",
        },
      ],
      this.client
    )

    return this
  }

  /**
   * TODO
   */
  async version(): Promise<string> {
    if (this._version) {
      return this._version
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "version",
        },
      ],
      this.client
    )

    return response
  }
  withLabel(name: string, value: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withLabel",
          args: { name, value },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Retrieves this file with its created/modified timestamps set to the given time.
   * @param timestamp Timestamp to set dir/files in.
   *
   * Formatted in seconds following Unix epoch (e.g., 1672531199).
   */
  withTimestamps(timestamp: number): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withTimestamps",
          args: { timestamp },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  withVersion(version: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "withVersion",
          args: { version },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current File.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: File) => File) {
    return arg(this)
  }
}

/**
 * A git ref (tag, branch or commit).
 */
export class GitRef extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * The filesystem tree at this ref.
   */
  tree(opts?: GitRefTreeOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "tree",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * A git repository.
 */
export class GitRepository extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * Returns details on one branch.
   * @param name Branch's name (e.g., "main").
   */
  branch(name: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "branch",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns details on one commit.
   * @param id Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
   */
  commit(id: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "commit",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns details on one tag.
   * @param name Tag's name (e.g., "v0.3.9").
   */
  tag(name: string): GitRef {
    return new GitRef({
      queryTree: [
        ...this._queryTree,
        {
          operation: "tag",
          args: { name },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

export class Go extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * BinPath sets $GOBIN to /go/bin and prepends it to $PATH.
   */
  binPath(ctr: Container): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "binPath",
          args: { ctr },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  build(base: Container, src: Directory, opts?: GoBuildOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "build",
          args: { base, src, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  generate(base: Container, src: Directory): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "generate",
          args: { base, src },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * GlobalCache sets $GOMODCACHE to /go/pkg/mod and $GOCACHE to /go/build-cache
   * and mounts cache volumes to both.
   *
   * The cache volumes are named "go-mod" and "go-build" respectively.
   */
  globalCache(ctr: Container): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "globalCache",
          args: { ctr },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  golangCilint(
    base: Container,
    src: Directory,
    opts?: GoGolangCilintOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "golangCilint",
          args: { base, src, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  gotestsum(
    base: Container,
    src: Directory,
    opts?: GoGotestsumOpts
  ): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "gotestsum",
          args: { base, src, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  test(base: Container, src: Directory, opts?: GoTestOpts): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "test",
          args: { base, src, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * Information about the host execution environment.
 */
export class Host extends BaseClient {
  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(parent?: {
    queryTree?: QueryTree[]
    host?: string
    sessionToken?: string
  }) {
    super(parent)
  }

  /**
   * Accesses a directory on the host.
   * @param path Location of the directory to access (e.g., ".").
   * @param opts.exclude Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
   * @param opts.include Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
   */
  directory(path: string, opts?: HostDirectoryOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { path, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Accesses a file on the host.
   * @param path Location of the file to retrieve (e.g., "README.md").
   */
  file(path: string): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Sets a secret given a user-defined name and the file path on the host, and returns the secret.
   * The file is limited to a size of 512000 bytes.
   * @param name The user defined name for this secret.
   * @param path Location of the file to set as a secret.
   */
  setSecretFile(name: string, path: string): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setSecretFile",
          args: { name, path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Accesses a Unix socket on the host.
   * @param path Location of the Unix socket (e.g., "/var/run/docker.sock").
   */
  unixSocket(path: string): Socket {
    return new Socket({
      queryTree: [
        ...this._queryTree,
        {
          operation: "unixSocket",
          args: { path },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
}

/**
 * TODO
 */
export class InvokeCommandResult extends BaseClient {
  private readonly _string?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _string?: string
  ) {
    super(parent)

    this._string = _string
  }

  /**
   * TODO
   */
  directory(): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  file(): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  async string(): Promise<string> {
    if (this._string) {
      return this._string
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "string",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A simple key value object that represents a label.
 */
export class Label extends BaseClient {
  private readonly _name?: string = undefined
  private readonly _value?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _name?: string,
    _value?: string
  ) {
    super(parent)

    this._name = _name
    this._value = _value
  }

  /**
   * The label name.
   */
  async name(): Promise<string> {
    if (this._name) {
      return this._name
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "name",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The label value.
   */
  async value(): Promise<string> {
    if (this._value) {
      return this._value
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "value",
        },
      ],
      this.client
    )

    return response
  }
}

/**
 * A port exposed by a container.
 */
export class Port extends BaseClient {
  private readonly _description?: string = undefined
  private readonly _port?: number = undefined
  private readonly _protocol?: NetworkProtocol = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _description?: string,
    _port?: number,
    _protocol?: NetworkProtocol
  ) {
    super(parent)

    this._description = _description
    this._port = _port
    this._protocol = _protocol
  }

  /**
   * The port description.
   */
  async description(): Promise<string> {
    if (this._description) {
      return this._description
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "description",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The port number.
   */
  async port(): Promise<number> {
    if (this._port) {
      return this._port
    }

    const response: Awaited<number> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "port",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The transport layer network protocol.
   */
  async protocol(): Promise<NetworkProtocol> {
    if (this._protocol) {
      return this._protocol
    }

    const response: Awaited<NetworkProtocol> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "protocol",
        },
      ],
      this.client
    )

    return response
  }
}

export class Client extends BaseClient {
  private readonly _checkVersionCompatibility?: boolean = undefined
  private readonly _defaultPlatform?: Platform = undefined
  private readonly _loadUniverse?: boolean = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _checkVersionCompatibility?: boolean,
    _defaultPlatform?: Platform,
    _loadUniverse?: boolean
  ) {
    super(parent)

    this._checkVersionCompatibility = _checkVersionCompatibility
    this._defaultPlatform = _defaultPlatform
    this._loadUniverse = _loadUniverse
  }
  apko(): Apko {
    return new Apko({
      queryTree: [
        ...this._queryTree,
        {
          operation: "apko",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Constructs a cache volume for a given cache key.
   * @param key A string identifier to target this cache volume (e.g., "modules-cache").
   */
  cacheVolume(key: string): CacheVolume {
    return new CacheVolume({
      queryTree: [
        ...this._queryTree,
        {
          operation: "cacheVolume",
          args: { key },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Checks if the current Dagger Engine is compatible with an SDK's required version.
   * @param version The SDK's required version.
   */
  async checkVersionCompatibility(version: string): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "checkVersionCompatibility",
          args: { version },
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Loads a container from ID.
   *
   * Null ID returns an empty container (scratch).
   * Optional platform argument initializes new containers to execute and publish as that platform.
   * Platform defaults to that of the builder's host.
   */
  container(opts?: ClientContainerOpts): Container {
    return new Container({
      queryTree: [
        ...this._queryTree,
        {
          operation: "container",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Return the current environment being executed in.
   */
  currentEnvironment(): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "currentEnvironment",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  dagger(): Dagger {
    return new Dagger({
      queryTree: [
        ...this._queryTree,
        {
          operation: "dagger",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  daggergo(): Daggergo {
    return new Daggergo({
      queryTree: [
        ...this._queryTree,
        {
          operation: "daggergo",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  daggerpython(): Daggerpython {
    return new Daggerpython({
      queryTree: [
        ...this._queryTree,
        {
          operation: "daggerpython",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * The default platform of the builder.
   */
  async defaultPlatform(): Promise<Platform> {
    const response: Awaited<Platform> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "defaultPlatform",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Load a directory by ID. No argument produces an empty directory.
   */
  directory(opts?: ClientDirectoryOpts): Directory {
    return new Directory({
      queryTree: [
        ...this._queryTree,
        {
          operation: "directory",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Load a environment from ID.
   */
  environment(opts?: ClientEnvironmentOpts): Environment {
    return new Environment({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environment",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  environmentArtifact(
    opts?: ClientEnvironmentArtifactOpts
  ): EnvironmentArtifact {
    return new EnvironmentArtifact({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentArtifact",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Load a environment check from ID.
   */
  environmentCheck(opts?: ClientEnvironmentCheckOpts): EnvironmentCheck {
    return new EnvironmentCheck({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentCheck",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Create a new environment check result.
   */
  environmentCheckResult(
    opts?: ClientEnvironmentCheckResultOpts
  ): EnvironmentCheckResult {
    return new EnvironmentCheckResult({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentCheckResult",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Load a environment command from ID.
   */
  environmentCommand(opts?: ClientEnvironmentCommandOpts): EnvironmentCommand {
    return new EnvironmentCommand({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentCommand",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Load a environment function from ID.
   */
  environmentFunction(
    opts?: ClientEnvironmentFunctionOpts
  ): EnvironmentFunction {
    return new EnvironmentFunction({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentFunction",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Load a environment shell from ID.
   */
  environmentShell(opts?: ClientEnvironmentShellOpts): EnvironmentShell {
    return new EnvironmentShell({
      queryTree: [
        ...this._queryTree,
        {
          operation: "environmentShell",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO
   */
  extensions(): Extensions {
    return new Extensions({
      queryTree: [
        ...this._queryTree,
        {
          operation: "extensions",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a file by ID.
   */
  file(id: FileID): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "file",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Queries a git repository.
   * @param url Url of the git repository.
   * Can be formatted as https://{host}/{owner}/{repo}, git@{host}/{owner}/{repo}
   * Suffix ".git" is optional.
   * @param opts.keepGitDir Set to true to keep .git directory.
   * @param opts.experimentalServiceHost A service which must be started before the repo is fetched.
   */
  git(url: string, opts?: ClientGitOpts): GitRepository {
    return new GitRepository({
      queryTree: [
        ...this._queryTree,
        {
          operation: "git",
          args: { url, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }
  go(): Go {
    return new Go({
      queryTree: [
        ...this._queryTree,
        {
          operation: "go",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Queries the host environment.
   */
  host(): Host {
    return new Host({
      queryTree: [
        ...this._queryTree,
        {
          operation: "host",
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Returns a file containing an http remote url content.
   * @param url HTTP url to get the content from (e.g., "https://docs.dagger.io").
   * @param opts.experimentalServiceHost A service which must be started before the URL is fetched.
   */
  http(url: string, opts?: ClientHttpOpts): File {
    return new File({
      queryTree: [
        ...this._queryTree,
        {
          operation: "http",
          args: { url, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * TODO: temp hack, should make each env load lazily (with some cache backend too)
   */
  async loadUniverse(): Promise<boolean> {
    const response: Awaited<boolean> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "loadUniverse",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * Creates a named sub-pipeline.
   * @param name Pipeline name.
   * @param opts.description Pipeline description.
   * @param opts.labels Pipeline labels.
   */
  pipeline(name: string, opts?: ClientPipelineOpts): Client {
    return new Client({
      queryTree: [
        ...this._queryTree,
        {
          operation: "pipeline",
          args: { name, ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a secret from its ID.
   */
  secret(id: SecretID): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "secret",
          args: { id },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Sets a secret given a user defined name to its plaintext and returns the secret.
   * The plaintext value is limited to a size of 128000 bytes.
   * @param name The user defined name for this secret
   * @param plaintext The plaintext of the secret
   */
  setSecret(name: string, plaintext: string): Secret {
    return new Secret({
      queryTree: [
        ...this._queryTree,
        {
          operation: "setSecret",
          args: { name, plaintext },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Loads a socket by its ID.
   */
  socket(opts?: ClientSocketOpts): Socket {
    return new Socket({
      queryTree: [
        ...this._queryTree,
        {
          operation: "socket",
          args: { ...opts },
        },
      ],
      host: this.clientHost,
      sessionToken: this.sessionToken,
    })
  }

  /**
   * Call the provided function with current Client.
   *
   * This is useful for reusability and readability by not breaking the calling chain.
   */
  with(arg: (param: Client) => Client) {
    return arg(this)
  }
}

/**
 * A reference to a secret value, which can be handled more safely than the value itself.
 */
export class Secret extends BaseClient {
  private readonly _id?: SecretID = undefined
  private readonly _plaintext?: string = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _id?: SecretID,
    _plaintext?: string
  ) {
    super(parent)

    this._id = _id
    this._plaintext = _plaintext
  }

  /**
   * The identifier for this secret.
   */
  async id(): Promise<SecretID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<SecretID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }

  /**
   * The value of this secret.
   */
  async plaintext(): Promise<string> {
    if (this._plaintext) {
      return this._plaintext
    }

    const response: Awaited<string> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "plaintext",
        },
      ],
      this.client
    )

    return response
  }
}

export class Socket extends BaseClient {
  private readonly _id?: SocketID = undefined

  /**
   * Constructor is used for internal usage only, do not create object from it.
   */
  constructor(
    parent?: { queryTree?: QueryTree[]; host?: string; sessionToken?: string },
    _id?: SocketID
  ) {
    super(parent)

    this._id = _id
  }

  /**
   * The content-addressed identifier of the socket.
   */
  async id(): Promise<SocketID> {
    if (this._id) {
      return this._id
    }

    const response: Awaited<SocketID> = await computeQuery(
      [
        ...this._queryTree,
        {
          operation: "id",
        },
      ],
      this.client
    )

    return response
  }
}
