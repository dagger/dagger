<?php

/**
 * This class has been generated by dagger-php-sdk. DO NOT EDIT.
 */

declare(strict_types=1);

namespace Dagger;

/**
 * An OCI-compatible container, also known as a Docker container.
 */
class Container extends Client\AbstractObject implements Client\IdAble
{
    /**
     * Turn the container into a Service.
     *
     * Be sure to set any exposed ports before this conversion.
     */
    public function asService(
        ?array $args = null,
        ?bool $useEntrypoint = false,
        ?bool $experimentalPrivilegedNesting = false,
        ?bool $insecureRootCapabilities = false,
        ?bool $expand = false,
        ?bool $noInit = false,
    ): Service {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('asService');
        if (null !== $args) {
        $innerQueryBuilder->setArgument('args', $args);
        }
        if (null !== $useEntrypoint) {
        $innerQueryBuilder->setArgument('useEntrypoint', $useEntrypoint);
        }
        if (null !== $experimentalPrivilegedNesting) {
        $innerQueryBuilder->setArgument('experimentalPrivilegedNesting', $experimentalPrivilegedNesting);
        }
        if (null !== $insecureRootCapabilities) {
        $innerQueryBuilder->setArgument('insecureRootCapabilities', $insecureRootCapabilities);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        if (null !== $noInit) {
        $innerQueryBuilder->setArgument('noInit', $noInit);
        }
        return new \Dagger\Service($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Package the container state as an OCI image, and return it as a tar archive
     */
    public function asTarball(
        ?array $platformVariants = null,
        ?ImageLayerCompression $forcedCompression = null,
        ?ImageMediaTypes $mediaTypes = null,
    ): File {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('asTarball');
        if (null !== $platformVariants) {
        $innerQueryBuilder->setArgument('platformVariants', $platformVariants);
        }
        if (null !== $forcedCompression) {
        $innerQueryBuilder->setArgument('forcedCompression', $forcedCompression);
        }
        if (null !== $mediaTypes) {
        $innerQueryBuilder->setArgument('mediaTypes', $mediaTypes);
        }
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The combined buffered standard output and standard error stream of the last executed command
     *
     * Returns an error if no command was executed
     */
    public function combinedOutput(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('combinedOutput');
        return (string)$this->queryLeaf($leafQueryBuilder, 'combinedOutput');
    }

    /**
     * Return the container's default arguments.
     */
    public function defaultArgs(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('defaultArgs');
        return (array)$this->queryLeaf($leafQueryBuilder, 'defaultArgs');
    }

    /**
     * Retrieve a directory from the container's root filesystem
     *
     * Mounts are included.
     */
    public function directory(string $path, ?bool $expand = false): Directory
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('directory');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Directory($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return the container's OCI entrypoint.
     */
    public function entrypoint(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('entrypoint');
        return (array)$this->queryLeaf($leafQueryBuilder, 'entrypoint');
    }

    /**
     * Retrieves the value of the specified environment variable.
     */
    public function envVariable(string $name): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('envVariable');
        $leafQueryBuilder->setArgument('name', $name);
        return (string)$this->queryLeaf($leafQueryBuilder, 'envVariable');
    }

    /**
     * Retrieves the list of environment variables passed to commands.
     */
    public function envVariables(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('envVariables');
        return (array)$this->queryLeaf($leafQueryBuilder, 'envVariables');
    }

    /**
     * check if a file or directory exists
     */
    public function exists(string $path, ?ExistsType $expectedType = null, ?bool $doNotFollowSymlinks = false): bool
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('exists');
        $leafQueryBuilder->setArgument('path', $path);
        if (null !== $expectedType) {
        $leafQueryBuilder->setArgument('expectedType', $expectedType);
        }
        if (null !== $doNotFollowSymlinks) {
        $leafQueryBuilder->setArgument('doNotFollowSymlinks', $doNotFollowSymlinks);
        }
        return (bool)$this->queryLeaf($leafQueryBuilder, 'exists');
    }

    /**
     * The exit code of the last executed command
     *
     * Returns an error if no command was executed
     */
    public function exitCode(): int
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('exitCode');
        return (int)$this->queryLeaf($leafQueryBuilder, 'exitCode');
    }

    /**
     * EXPERIMENTAL API! Subject to change/removal at any time.
     *
     * Configures all available GPUs on the host to be accessible to this container.
     *
     * This currently works for Nvidia devices only.
     */
    public function experimentalWithAllGPUs(): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('experimentalWithAllGPUs');
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * EXPERIMENTAL API! Subject to change/removal at any time.
     *
     * Configures the provided list of devices to be accessible to this container.
     *
     * This currently works for Nvidia devices only.
     */
    public function experimentalWithGPU(array $devices): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('experimentalWithGPU');
        $innerQueryBuilder->setArgument('devices', $devices);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Writes the container as an OCI tarball to the destination file path on the host.
     *
     * It can also export platform variants.
     */
    public function export(
        string $path,
        ?array $platformVariants = null,
        ?ImageLayerCompression $forcedCompression = null,
        ?ImageMediaTypes $mediaTypes = null,
        ?bool $expand = false,
    ): string {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('export');
        $leafQueryBuilder->setArgument('path', $path);
        if (null !== $platformVariants) {
        $leafQueryBuilder->setArgument('platformVariants', $platformVariants);
        }
        if (null !== $forcedCompression) {
        $leafQueryBuilder->setArgument('forcedCompression', $forcedCompression);
        }
        if (null !== $mediaTypes) {
        $leafQueryBuilder->setArgument('mediaTypes', $mediaTypes);
        }
        if (null !== $expand) {
        $leafQueryBuilder->setArgument('expand', $expand);
        }
        return (string)$this->queryLeaf($leafQueryBuilder, 'export');
    }

    /**
     * Exports the container as an image to the host's container image store.
     */
    public function exportImage(
        string $name,
        ?array $platformVariants = null,
        ?ImageLayerCompression $forcedCompression = null,
        ?ImageMediaTypes $mediaTypes = null,
    ): void {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('exportImage');
        $leafQueryBuilder->setArgument('name', $name);
        if (null !== $platformVariants) {
        $leafQueryBuilder->setArgument('platformVariants', $platformVariants);
        }
        if (null !== $forcedCompression) {
        $leafQueryBuilder->setArgument('forcedCompression', $forcedCompression);
        }
        if (null !== $mediaTypes) {
        $leafQueryBuilder->setArgument('mediaTypes', $mediaTypes);
        }
        $this->queryLeaf($leafQueryBuilder, 'exportImage');
    }

    /**
     * Retrieves the list of exposed ports.
     *
     * This includes ports already exposed by the image, even if not explicitly added with dagger.
     */
    public function exposedPorts(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('exposedPorts');
        return (array)$this->queryLeaf($leafQueryBuilder, 'exposedPorts');
    }

    /**
     * Retrieves a file at the given path.
     *
     * Mounts are included.
     */
    public function file(string $path, ?bool $expand = false): File
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('file');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Download a container image, and apply it to the container state. All previous state will be lost.
     */
    public function from(string $address): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('from');
        $innerQueryBuilder->setArgument('address', $address);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * A unique identifier for this Container.
     */
    public function id(): ContainerId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('id');
        return new \Dagger\ContainerId((string)$this->queryLeaf($leafQueryBuilder, 'id'));
    }

    /**
     * The unique image reference which can only be retrieved immediately after the 'Container.From' call.
     */
    public function imageRef(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('imageRef');
        return (string)$this->queryLeaf($leafQueryBuilder, 'imageRef');
    }

    /**
     * Reads the container from an OCI tarball.
     */
    public function import(FileId|File $source, ?string $tag = ''): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('import');
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $tag) {
        $innerQueryBuilder->setArgument('tag', $tag);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves the value of the specified label.
     */
    public function label(string $name): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('label');
        $leafQueryBuilder->setArgument('name', $name);
        return (string)$this->queryLeaf($leafQueryBuilder, 'label');
    }

    /**
     * Retrieves the list of labels passed to container.
     */
    public function labels(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('labels');
        return (array)$this->queryLeaf($leafQueryBuilder, 'labels');
    }

    /**
     * Retrieves the list of paths where a directory is mounted.
     */
    public function mounts(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('mounts');
        return (array)$this->queryLeaf($leafQueryBuilder, 'mounts');
    }

    /**
     * The platform this container executes and publishes as.
     */
    public function platform(): Platform
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('platform');
        return new \Dagger\Platform((string)$this->queryLeaf($leafQueryBuilder, 'platform'));
    }

    /**
     * Package the container state as an OCI image, and publish it to a registry
     *
     * Returns the fully qualified address of the published image, with digest
     */
    public function publish(
        string $address,
        ?array $platformVariants = null,
        ?ImageLayerCompression $forcedCompression = null,
        ?ImageMediaTypes $mediaTypes = null,
    ): string {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('publish');
        $leafQueryBuilder->setArgument('address', $address);
        if (null !== $platformVariants) {
        $leafQueryBuilder->setArgument('platformVariants', $platformVariants);
        }
        if (null !== $forcedCompression) {
        $leafQueryBuilder->setArgument('forcedCompression', $forcedCompression);
        }
        if (null !== $mediaTypes) {
        $leafQueryBuilder->setArgument('mediaTypes', $mediaTypes);
        }
        return (string)$this->queryLeaf($leafQueryBuilder, 'publish');
    }

    /**
     * Return a snapshot of the container's root filesystem. The snapshot can be modified then written back using withRootfs. Use that method for filesystem modifications.
     */
    public function rootfs(): Directory
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('rootfs');
        return new \Dagger\Directory($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The buffered standard error stream of the last executed command
     *
     * Returns an error if no command was executed
     */
    public function stderr(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('stderr');
        return (string)$this->queryLeaf($leafQueryBuilder, 'stderr');
    }

    /**
     * The buffered standard output stream of the last executed command
     *
     * Returns an error if no command was executed
     */
    public function stdout(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('stdout');
        return (string)$this->queryLeaf($leafQueryBuilder, 'stdout');
    }

    /**
     * Forces evaluation of the pipeline in the engine.
     *
     * It doesn't run the default command if no exec has been set.
     */
    public function sync(): ContainerId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('sync');
        return new \Dagger\ContainerId((string)$this->queryLeaf($leafQueryBuilder, 'sync'));
    }

    /**
     * Opens an interactive terminal for this container using its configured default terminal command if not overridden by args (or sh as a fallback default).
     */
    public function terminal(
        ?array $cmd = null,
        ?bool $experimentalPrivilegedNesting = false,
        ?bool $insecureRootCapabilities = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('terminal');
        if (null !== $cmd) {
        $innerQueryBuilder->setArgument('cmd', $cmd);
        }
        if (null !== $experimentalPrivilegedNesting) {
        $innerQueryBuilder->setArgument('experimentalPrivilegedNesting', $experimentalPrivilegedNesting);
        }
        if (null !== $insecureRootCapabilities) {
        $innerQueryBuilder->setArgument('insecureRootCapabilities', $insecureRootCapabilities);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Starts a Service and creates a tunnel that forwards traffic from the caller's network to that service.
     *
     * Be sure to set any exposed ports before calling this api.
     */
    public function up(
        ?bool $random = false,
        ?array $ports = null,
        ?array $args = null,
        ?bool $useEntrypoint = false,
        ?bool $experimentalPrivilegedNesting = false,
        ?bool $insecureRootCapabilities = false,
        ?bool $expand = false,
        ?bool $noInit = false,
    ): void {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('up');
        if (null !== $random) {
        $leafQueryBuilder->setArgument('random', $random);
        }
        if (null !== $ports) {
        $leafQueryBuilder->setArgument('ports', $ports);
        }
        if (null !== $args) {
        $leafQueryBuilder->setArgument('args', $args);
        }
        if (null !== $useEntrypoint) {
        $leafQueryBuilder->setArgument('useEntrypoint', $useEntrypoint);
        }
        if (null !== $experimentalPrivilegedNesting) {
        $leafQueryBuilder->setArgument('experimentalPrivilegedNesting', $experimentalPrivilegedNesting);
        }
        if (null !== $insecureRootCapabilities) {
        $leafQueryBuilder->setArgument('insecureRootCapabilities', $insecureRootCapabilities);
        }
        if (null !== $expand) {
        $leafQueryBuilder->setArgument('expand', $expand);
        }
        if (null !== $noInit) {
        $leafQueryBuilder->setArgument('noInit', $noInit);
        }
        $this->queryLeaf($leafQueryBuilder, 'up');
    }

    /**
     * Retrieves the user to be set for all commands.
     */
    public function user(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('user');
        return (string)$this->queryLeaf($leafQueryBuilder, 'user');
    }

    /**
     * Retrieves this container plus the given OCI anotation.
     */
    public function withAnnotation(string $name, string $value): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withAnnotation');
        $innerQueryBuilder->setArgument('name', $name);
        $innerQueryBuilder->setArgument('value', $value);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Configures default arguments for future commands. Like CMD in Dockerfile.
     */
    public function withDefaultArgs(array $args): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withDefaultArgs');
        $innerQueryBuilder->setArgument('args', $args);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Set the default command to invoke for the container's terminal API.
     */
    public function withDefaultTerminalCmd(
        array $args,
        ?bool $experimentalPrivilegedNesting = false,
        ?bool $insecureRootCapabilities = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withDefaultTerminalCmd');
        $innerQueryBuilder->setArgument('args', $args);
        if (null !== $experimentalPrivilegedNesting) {
        $innerQueryBuilder->setArgument('experimentalPrivilegedNesting', $experimentalPrivilegedNesting);
        }
        if (null !== $insecureRootCapabilities) {
        $innerQueryBuilder->setArgument('insecureRootCapabilities', $insecureRootCapabilities);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a new container snapshot, with a directory added to its filesystem
     */
    public function withDirectory(
        string $path,
        DirectoryId|Directory $source,
        ?array $exclude = null,
        ?array $include = null,
        ?bool $gitignore = false,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withDirectory');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $exclude) {
        $innerQueryBuilder->setArgument('exclude', $exclude);
        }
        if (null !== $include) {
        $innerQueryBuilder->setArgument('include', $include);
        }
        if (null !== $gitignore) {
        $innerQueryBuilder->setArgument('gitignore', $gitignore);
        }
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Set an OCI-style entrypoint. It will be included in the container's OCI configuration. Note, withExec ignores the entrypoint by default.
     */
    public function withEntrypoint(array $args, ?bool $keepDefaultArgs = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withEntrypoint');
        $innerQueryBuilder->setArgument('args', $args);
        if (null !== $keepDefaultArgs) {
        $innerQueryBuilder->setArgument('keepDefaultArgs', $keepDefaultArgs);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Set a new environment variable in the container.
     */
    public function withEnvVariable(string $name, string $value, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withEnvVariable');
        $innerQueryBuilder->setArgument('name', $name);
        $innerQueryBuilder->setArgument('value', $value);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Raise an error.
     */
    public function withError(string $err): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withError');
        $innerQueryBuilder->setArgument('err', $err);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Execute a command in the container, and return a new snapshot of the container state after execution.
     */
    public function withExec(
        array $args,
        ?bool $useEntrypoint = false,
        ?string $stdin = '',
        ?string $redirectStdin = '',
        ?string $redirectStdout = '',
        ?string $redirectStderr = '',
        ?ReturnType $expect = null,
        ?bool $experimentalPrivilegedNesting = false,
        ?bool $insecureRootCapabilities = false,
        ?bool $expand = false,
        ?bool $noInit = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withExec');
        $innerQueryBuilder->setArgument('args', $args);
        if (null !== $useEntrypoint) {
        $innerQueryBuilder->setArgument('useEntrypoint', $useEntrypoint);
        }
        if (null !== $stdin) {
        $innerQueryBuilder->setArgument('stdin', $stdin);
        }
        if (null !== $redirectStdin) {
        $innerQueryBuilder->setArgument('redirectStdin', $redirectStdin);
        }
        if (null !== $redirectStdout) {
        $innerQueryBuilder->setArgument('redirectStdout', $redirectStdout);
        }
        if (null !== $redirectStderr) {
        $innerQueryBuilder->setArgument('redirectStderr', $redirectStderr);
        }
        if (null !== $expect) {
        $innerQueryBuilder->setArgument('expect', $expect);
        }
        if (null !== $experimentalPrivilegedNesting) {
        $innerQueryBuilder->setArgument('experimentalPrivilegedNesting', $experimentalPrivilegedNesting);
        }
        if (null !== $insecureRootCapabilities) {
        $innerQueryBuilder->setArgument('insecureRootCapabilities', $insecureRootCapabilities);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        if (null !== $noInit) {
        $innerQueryBuilder->setArgument('noInit', $noInit);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Expose a network port. Like EXPOSE in Dockerfile (but with healthcheck support)
     *
     * Exposed ports serve two purposes:
     *
     * - For health checks and introspection, when running services
     *
     * - For setting the EXPOSE OCI field when publishing the container
     */
    public function withExposedPort(
        int $port,
        ?NetworkProtocol $protocol = null,
        ?string $description = null,
        ?bool $experimentalSkipHealthcheck = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withExposedPort');
        $innerQueryBuilder->setArgument('port', $port);
        if (null !== $protocol) {
        $innerQueryBuilder->setArgument('protocol', $protocol);
        }
        if (null !== $description) {
        $innerQueryBuilder->setArgument('description', $description);
        }
        if (null !== $experimentalSkipHealthcheck) {
        $innerQueryBuilder->setArgument('experimentalSkipHealthcheck', $experimentalSkipHealthcheck);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a container snapshot with a file added
     */
    public function withFile(
        string $path,
        FileId|File $source,
        ?int $permissions = null,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withFile');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $permissions) {
        $innerQueryBuilder->setArgument('permissions', $permissions);
        }
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus the contents of the given files copied to the given path.
     */
    public function withFiles(
        string $path,
        array $sources,
        ?int $permissions = null,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withFiles');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('sources', $sources);
        if (null !== $permissions) {
        $innerQueryBuilder->setArgument('permissions', $permissions);
        }
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus the given label.
     */
    public function withLabel(string $name, string $value): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withLabel');
        $innerQueryBuilder->setArgument('name', $name);
        $innerQueryBuilder->setArgument('value', $value);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a cache volume mounted at the given path.
     */
    public function withMountedCache(
        string $path,
        CacheVolumeId|CacheVolume $cache,
        DirectoryId|Directory|null $source = null,
        ?CacheSharingMode $sharing = null,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedCache');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('cache', $cache);
        if (null !== $source) {
        $innerQueryBuilder->setArgument('source', $source);
        }
        if (null !== $sharing) {
        $innerQueryBuilder->setArgument('sharing', $sharing);
        }
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a directory mounted at the given path.
     */
    public function withMountedDirectory(
        string $path,
        DirectoryId|Directory $source,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedDirectory');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a file mounted at the given path.
     */
    public function withMountedFile(
        string $path,
        FileId|File $source,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedFile');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a host directory mounted at the given path.
     */
    public function withMountedHostDirectory(string $source, string $path): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedHostDirectory');
        $innerQueryBuilder->setArgument('source', $source);
        $innerQueryBuilder->setArgument('path', $path);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a secret mounted into a file at the given path.
     */
    public function withMountedSecret(
        string $path,
        SecretId|Secret $source,
        ?string $owner = '',
        ?int $mode = 256,
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedSecret');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $mode) {
        $innerQueryBuilder->setArgument('mode', $mode);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a temporary directory mounted at the given path. Any writes will be ephemeral to a single withExec call; they will not be persisted to subsequent withExecs.
     */
    public function withMountedTemp(string $path, ?int $size = null, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withMountedTemp');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $size) {
        $innerQueryBuilder->setArgument('size', $size);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a new container snapshot, with a file added to its filesystem with text content
     */
    public function withNewFile(
        string $path,
        string $contents,
        ?int $permissions = 420,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withNewFile');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('contents', $contents);
        if (null !== $permissions) {
        $innerQueryBuilder->setArgument('permissions', $permissions);
        }
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Attach credentials for future publishing to a registry. Use in combination with publish
     */
    public function withRegistryAuth(string $address, string $username, SecretId|Secret $secret): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withRegistryAuth');
        $innerQueryBuilder->setArgument('address', $address);
        $innerQueryBuilder->setArgument('username', $username);
        $innerQueryBuilder->setArgument('secret', $secret);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Change the container's root filesystem. The previous root filesystem will be lost.
     */
    public function withRootfs(DirectoryId|Directory $directory): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withRootfs');
        $innerQueryBuilder->setArgument('directory', $directory);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Set a new environment variable, using a secret value
     */
    public function withSecretVariable(string $name, SecretId|Secret $secret): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withSecretVariable');
        $innerQueryBuilder->setArgument('name', $name);
        $innerQueryBuilder->setArgument('secret', $secret);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Establish a runtime dependency from a container to a network service.
     *
     * The service will be started automatically when needed and detached when it is no longer needed, executing the default command if none is set.
     *
     * The service will be reachable from the container via the provided hostname alias.
     *
     * The service dependency will also convey to any files or directories produced by the container.
     */
    public function withServiceBinding(string $alias, ServiceId|Service $service): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withServiceBinding');
        $innerQueryBuilder->setArgument('alias', $alias);
        $innerQueryBuilder->setArgument('service', $service);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a snapshot with a symlink
     */
    public function withSymlink(string $target, string $linkName, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withSymlink');
        $innerQueryBuilder->setArgument('target', $target);
        $innerQueryBuilder->setArgument('linkName', $linkName);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus a socket forwarded to the given Unix socket path.
     */
    public function withUnixSocket(
        string $path,
        SocketId|Socket $source,
        ?string $owner = '',
        ?bool $expand = false,
    ): Container {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUnixSocket');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('source', $source);
        if (null !== $owner) {
        $innerQueryBuilder->setArgument('owner', $owner);
        }
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container with a different command user.
     */
    public function withUser(string $name): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUser');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container plus an engine-managed volume mounted at the given path.
     */
    public function withVolumeMount(string $path, VolumeId|Volume $volume): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withVolumeMount');
        $innerQueryBuilder->setArgument('path', $path);
        $innerQueryBuilder->setArgument('volume', $volume);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Change the container's working directory. Like WORKDIR in Dockerfile.
     */
    public function withWorkdir(string $path, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withWorkdir');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container minus the given OCI annotation.
     */
    public function withoutAnnotation(string $name): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutAnnotation');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Remove the container's default arguments.
     */
    public function withoutDefaultArgs(): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutDefaultArgs');
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a new container snapshot, with a directory removed from its filesystem
     */
    public function withoutDirectory(string $path, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutDirectory');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Reset the container's OCI entrypoint.
     */
    public function withoutEntrypoint(?bool $keepDefaultArgs = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutEntrypoint');
        if (null !== $keepDefaultArgs) {
        $innerQueryBuilder->setArgument('keepDefaultArgs', $keepDefaultArgs);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container minus the given environment variable.
     */
    public function withoutEnvVariable(string $name): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutEnvVariable');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Unexpose a previously exposed port.
     */
    public function withoutExposedPort(int $port, ?NetworkProtocol $protocol = null): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutExposedPort');
        $innerQueryBuilder->setArgument('port', $port);
        if (null !== $protocol) {
        $innerQueryBuilder->setArgument('protocol', $protocol);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container with the file at the given path removed.
     */
    public function withoutFile(string $path, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutFile');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Return a new container spanshot with specified files removed
     */
    public function withoutFiles(array $paths, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutFiles');
        $innerQueryBuilder->setArgument('paths', $paths);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container minus the given environment label.
     */
    public function withoutLabel(string $name): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutLabel');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container after unmounting everything at the given path.
     */
    public function withoutMount(string $path, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutMount');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container without the registry authentication of a given address.
     */
    public function withoutRegistryAuth(string $address): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutRegistryAuth');
        $innerQueryBuilder->setArgument('address', $address);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container minus the given environment variable containing the secret.
     */
    public function withoutSecretVariable(string $name): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutSecretVariable');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container with a previously added Unix socket removed.
     */
    public function withoutUnixSocket(string $path, ?bool $expand = false): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutUnixSocket');
        $innerQueryBuilder->setArgument('path', $path);
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this container with an unset command user.
     *
     * Should default to root.
     */
    public function withoutUser(): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutUser');
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Unset the container's working directory.
     *
     * Should default to "/".
     */
    public function withoutWorkdir(): Container
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutWorkdir');
        return new \Dagger\Container($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves the working directory for all commands.
     */
    public function workdir(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('workdir');
        return (string)$this->queryLeaf($leafQueryBuilder, 'workdir');
    }
}
