<?php

/**
 * This class has been generated by dagger-php-sdk. DO NOT EDIT.
 */

declare(strict_types=1);

namespace Dagger;

/**
 * A file.
 */
class File extends Client\AbstractObject implements Client\IdAble
{
    /**
     * Parse as an env file
     */
    public function asEnvFile(?bool $expand = null): EnvFile
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('asEnvFile');
        if (null !== $expand) {
        $innerQueryBuilder->setArgument('expand', $expand);
        }
        return new \Dagger\EnvFile($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves the contents of the file.
     */
    public function contents(?int $offsetLines = null, ?int $limitLines = null): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('contents');
        if (null !== $offsetLines) {
        $leafQueryBuilder->setArgument('offsetLines', $offsetLines);
        }
        if (null !== $limitLines) {
        $leafQueryBuilder->setArgument('limitLines', $limitLines);
        }
        return (string)$this->queryLeaf($leafQueryBuilder, 'contents');
    }

    /**
     * Return the file's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
     */
    public function digest(?bool $excludeMetadata = false): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('digest');
        if (null !== $excludeMetadata) {
        $leafQueryBuilder->setArgument('excludeMetadata', $excludeMetadata);
        }
        return (string)$this->queryLeaf($leafQueryBuilder, 'digest');
    }

    /**
     * Writes the file to a file path on the host.
     */
    public function export(string $path, ?bool $allowParentDirPath = false): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('export');
        $leafQueryBuilder->setArgument('path', $path);
        if (null !== $allowParentDirPath) {
        $leafQueryBuilder->setArgument('allowParentDirPath', $allowParentDirPath);
        }
        return (string)$this->queryLeaf($leafQueryBuilder, 'export');
    }

    /**
     * A unique identifier for this File.
     */
    public function id(): FileId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('id');
        return new \Dagger\FileId((string)$this->queryLeaf($leafQueryBuilder, 'id'));
    }

    /**
     * Retrieves the name of the file.
     */
    public function name(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('name');
        return (string)$this->queryLeaf($leafQueryBuilder, 'name');
    }

    /**
     * Searches for content matching the given regular expression or literal string.
     *
     * Uses Rust regex syntax; escape literal ., [, ], {, }, | with backslashes.
     */
    public function search(
        string $pattern,
        ?bool $literal = false,
        ?bool $multiline = false,
        ?bool $dotall = false,
        ?bool $insensitive = false,
        ?bool $skipIgnored = false,
        ?bool $skipHidden = false,
        ?bool $filesOnly = false,
        ?int $limit = null,
        ?array $paths = null,
        ?array $globs = null,
    ): array {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('search');
        $leafQueryBuilder->setArgument('pattern', $pattern);
        if (null !== $literal) {
        $leafQueryBuilder->setArgument('literal', $literal);
        }
        if (null !== $multiline) {
        $leafQueryBuilder->setArgument('multiline', $multiline);
        }
        if (null !== $dotall) {
        $leafQueryBuilder->setArgument('dotall', $dotall);
        }
        if (null !== $insensitive) {
        $leafQueryBuilder->setArgument('insensitive', $insensitive);
        }
        if (null !== $skipIgnored) {
        $leafQueryBuilder->setArgument('skipIgnored', $skipIgnored);
        }
        if (null !== $skipHidden) {
        $leafQueryBuilder->setArgument('skipHidden', $skipHidden);
        }
        if (null !== $filesOnly) {
        $leafQueryBuilder->setArgument('filesOnly', $filesOnly);
        }
        if (null !== $limit) {
        $leafQueryBuilder->setArgument('limit', $limit);
        }
        if (null !== $paths) {
        $leafQueryBuilder->setArgument('paths', $paths);
        }
        if (null !== $globs) {
        $leafQueryBuilder->setArgument('globs', $globs);
        }
        return (array)$this->queryLeaf($leafQueryBuilder, 'search');
    }

    /**
     * Retrieves the size of the file, in bytes.
     */
    public function size(): int
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('size');
        return (int)$this->queryLeaf($leafQueryBuilder, 'size');
    }

    /**
     * Force evaluation in the engine.
     */
    public function sync(): FileId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('sync');
        return new \Dagger\FileId((string)$this->queryLeaf($leafQueryBuilder, 'sync'));
    }

    /**
     * Retrieves this file with its name set to the given name.
     */
    public function withName(string $name): File
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withName');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves the file with content replaced with the given text.
     *
     * If 'all' is true, all occurrences of the pattern will be replaced.
     *
     * If 'firstAfter' is specified, only the first match starting at the specified line will be replaced.
     *
     * If neither are specified, and there are multiple matches for the pattern, this will error.
     *
     * If there are no matches for the pattern, this will error.
     */
    public function withReplaced(
        string $search,
        string $replacement,
        ?bool $all = false,
        ?int $firstFrom = null,
    ): File {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withReplaced');
        $innerQueryBuilder->setArgument('search', $search);
        $innerQueryBuilder->setArgument('replacement', $replacement);
        if (null !== $all) {
        $innerQueryBuilder->setArgument('all', $all);
        }
        if (null !== $firstFrom) {
        $innerQueryBuilder->setArgument('firstFrom', $firstFrom);
        }
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Retrieves this file with its created/modified timestamps set to the given time.
     */
    public function withTimestamps(int $timestamp): File
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withTimestamps');
        $innerQueryBuilder->setArgument('timestamp', $timestamp);
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }
}
