<?php

/**
 * This class has been generated by dagger-php-sdk. DO NOT EDIT.
 */

declare(strict_types=1);

namespace Dagger;

/**
 * The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
 */
class ModuleSource extends Client\AbstractObject implements Client\IdAble
{
    /**
     * Load the source as a module. If this is a local source, the parent directory must have been provided during module source creation
     */
    public function asModule(): Module
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('asModule');
        return new \Dagger\Module($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * A human readable ref string representation of this module source.
     */
    public function asString(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('asString');
        return (string)$this->queryLeaf($leafQueryBuilder, 'asString');
    }

    /**
     * The blueprint referenced by the module source.
     */
    public function blueprint(): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('blueprint');
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The ref to clone the root of the git repo from. Only valid for git sources.
     */
    public function cloneRef(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('cloneRef');
        return (string)$this->queryLeaf($leafQueryBuilder, 'cloneRef');
    }

    /**
     * The resolved commit of the git repo this source points to.
     */
    public function commit(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('commit');
        return (string)$this->queryLeaf($leafQueryBuilder, 'commit');
    }

    /**
     * The clients generated for the module.
     */
    public function configClients(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('configClients');
        return (array)$this->queryLeaf($leafQueryBuilder, 'configClients');
    }

    /**
     * Whether an existing dagger.json for the module was found.
     */
    public function configExists(): bool
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('configExists');
        return (bool)$this->queryLeaf($leafQueryBuilder, 'configExists');
    }

    /**
     * The full directory loaded for the module source, including the source code as a subdirectory.
     */
    public function contextDirectory(): Directory
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('contextDirectory');
        return new \Dagger\Directory($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The dependencies of the module source.
     */
    public function dependencies(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('dependencies');
        return (array)$this->queryLeaf($leafQueryBuilder, 'dependencies');
    }

    /**
     * A content-hash of the module source. Module sources with the same digest will output the same generated context and convert into the same module instance.
     */
    public function digest(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('digest');
        return (string)$this->queryLeaf($leafQueryBuilder, 'digest');
    }

    /**
     * The directory containing the module configuration and source code (source code may be in a subdir).
     */
    public function directory(string $path): Directory
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('directory');
        $innerQueryBuilder->setArgument('path', $path);
        return new \Dagger\Directory($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The engine version of the module.
     */
    public function engineVersion(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('engineVersion');
        return (string)$this->queryLeaf($leafQueryBuilder, 'engineVersion');
    }

    /**
     * The generated files and directories made on top of the module source's context directory.
     */
    public function generatedContextDirectory(): Directory
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('generatedContextDirectory');
        return new \Dagger\Directory($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The URL to access the web view of the repository (e.g., GitHub, GitLab, Bitbucket).
     */
    public function htmlRepoURL(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('htmlRepoURL');
        return (string)$this->queryLeaf($leafQueryBuilder, 'htmlRepoURL');
    }

    /**
     * The URL to the source's git repo in a web browser. Only valid for git sources.
     */
    public function htmlURL(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('htmlURL');
        return (string)$this->queryLeaf($leafQueryBuilder, 'htmlURL');
    }

    /**
     * A unique identifier for this ModuleSource.
     */
    public function id(): ModuleSourceId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('id');
        return new \Dagger\ModuleSourceId((string)$this->queryLeaf($leafQueryBuilder, 'id'));
    }

    /**
     * The introspection schema JSON file for this module source.
     *
     * This file represents the schema visible to the module's source code, including all core types and those from the dependencies.
     *
     * Note: this is in the context of a module, so some core types may be hidden.
     */
    public function introspectionSchemaJSON(): File
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('introspectionSchemaJSON');
        return new \Dagger\File($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The kind of module source (currently local, git or dir).
     */
    public function kind(): ModuleSourceKind
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('kind');
        return \Dagger\ModuleSourceKind::from((string)$this->queryLeaf($leafQueryBuilder, 'kind'));
    }

    /**
     * The full absolute path to the context directory on the caller's host filesystem that this module source is loaded from. Only valid for local module sources.
     */
    public function localContextDirectoryPath(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('localContextDirectoryPath');
        return (string)$this->queryLeaf($leafQueryBuilder, 'localContextDirectoryPath');
    }

    /**
     * The name of the module, including any setting via the withName API.
     */
    public function moduleName(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('moduleName');
        return (string)$this->queryLeaf($leafQueryBuilder, 'moduleName');
    }

    /**
     * The original name of the module as read from the module's dagger.json (or set for the first time with the withName API).
     */
    public function moduleOriginalName(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('moduleOriginalName');
        return (string)$this->queryLeaf($leafQueryBuilder, 'moduleOriginalName');
    }

    /**
     * The original subpath used when instantiating this module source, relative to the context directory.
     */
    public function originalSubpath(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('originalSubpath');
        return (string)$this->queryLeaf($leafQueryBuilder, 'originalSubpath');
    }

    /**
     * The pinned version of this module source.
     */
    public function pin(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('pin');
        return (string)$this->queryLeaf($leafQueryBuilder, 'pin');
    }

    /**
     * The import path corresponding to the root of the git repo this source points to. Only valid for git sources.
     */
    public function repoRootPath(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('repoRootPath');
        return (string)$this->queryLeaf($leafQueryBuilder, 'repoRootPath');
    }

    /**
     * The SDK configuration of the module.
     */
    public function sdk(): SDKConfig
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('sdk');
        return new \Dagger\SDKConfig($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The path, relative to the context directory, that contains the module's dagger.json.
     */
    public function sourceRootSubpath(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('sourceRootSubpath');
        return (string)$this->queryLeaf($leafQueryBuilder, 'sourceRootSubpath');
    }

    /**
     * The path to the directory containing the module's source code, relative to the context directory.
     */
    public function sourceSubpath(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('sourceSubpath');
        return (string)$this->queryLeaf($leafQueryBuilder, 'sourceSubpath');
    }

    /**
     * Forces evaluation of the module source, including any loading into the engine and associated validation.
     */
    public function sync(): ModuleSourceId
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('sync');
        return new \Dagger\ModuleSourceId((string)$this->queryLeaf($leafQueryBuilder, 'sync'));
    }

    /**
     * The toolchains referenced by the module source.
     */
    public function toolchains(): array
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('toolchains');
        return (array)$this->queryLeaf($leafQueryBuilder, 'toolchains');
    }

    /**
     * User-defined defaults read from local .env files
     */
    public function userDefaults(): EnvFile
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('userDefaults');
        return new \Dagger\EnvFile($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * The specified version of the git repo this source points to.
     */
    public function version(): string
    {
        $leafQueryBuilder = new \Dagger\Client\QueryBuilder('version');
        return (string)$this->queryLeaf($leafQueryBuilder, 'version');
    }

    /**
     * Set a blueprint for the module source.
     */
    public function withBlueprint(ModuleSourceId|ModuleSource $blueprint): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withBlueprint');
        $innerQueryBuilder->setArgument('blueprint', $blueprint);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the module source with a new client to generate.
     */
    public function withClient(string $generator, string $outputDir): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withClient');
        $innerQueryBuilder->setArgument('generator', $generator);
        $innerQueryBuilder->setArgument('outputDir', $outputDir);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Append the provided dependencies to the module source's dependency list.
     */
    public function withDependencies(array $dependencies): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withDependencies');
        $innerQueryBuilder->setArgument('dependencies', $dependencies);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Upgrade the engine version of the module to the given value.
     */
    public function withEngineVersion(string $version): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withEngineVersion');
        $innerQueryBuilder->setArgument('version', $version);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Enable the experimental features for the module source.
     */
    public function withExperimentalFeatures(array $features): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withExperimentalFeatures');
        $innerQueryBuilder->setArgument('features', $features);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the module source with additional include patterns for files+directories from its context that are required for building it
     */
    public function withIncludes(array $patterns): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withIncludes');
        $innerQueryBuilder->setArgument('patterns', $patterns);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the module source with a new name.
     */
    public function withName(string $name): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withName');
        $innerQueryBuilder->setArgument('name', $name);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the module source with a new SDK.
     */
    public function withSDK(string $source): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withSDK');
        $innerQueryBuilder->setArgument('source', $source);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the module source with a new source subpath.
     */
    public function withSourceSubpath(string $path): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withSourceSubpath');
        $innerQueryBuilder->setArgument('path', $path);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Add toolchains to the module source.
     */
    public function withToolchains(array $toolchains): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withToolchains');
        $innerQueryBuilder->setArgument('toolchains', $toolchains);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update the blueprint module to the latest version.
     */
    public function withUpdateBlueprint(): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUpdateBlueprint');
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update one or more module dependencies.
     */
    public function withUpdateDependencies(array $dependencies): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUpdateDependencies');
        $innerQueryBuilder->setArgument('dependencies', $dependencies);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update one or more toolchains.
     */
    public function withUpdateToolchains(array $toolchains): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUpdateToolchains');
        $innerQueryBuilder->setArgument('toolchains', $toolchains);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Update one or more clients.
     */
    public function withUpdatedClients(array $clients): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withUpdatedClients');
        $innerQueryBuilder->setArgument('clients', $clients);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Remove the current blueprint from the module source.
     */
    public function withoutBlueprint(): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutBlueprint');
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Remove a client from the module source.
     */
    public function withoutClient(string $path): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutClient');
        $innerQueryBuilder->setArgument('path', $path);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Remove the provided dependencies from the module source's dependency list.
     */
    public function withoutDependencies(array $dependencies): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutDependencies');
        $innerQueryBuilder->setArgument('dependencies', $dependencies);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Disable experimental features for the module source.
     */
    public function withoutExperimentalFeatures(array $features): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutExperimentalFeatures');
        $innerQueryBuilder->setArgument('features', $features);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }

    /**
     * Remove the provided toolchains from the module source.
     */
    public function withoutToolchains(array $toolchains): ModuleSource
    {
        $innerQueryBuilder = new \Dagger\Client\QueryBuilder('withoutToolchains');
        $innerQueryBuilder->setArgument('toolchains', $toolchains);
        return new \Dagger\ModuleSource($this->client, $this->queryBuilderChain->chain($innerQueryBuilder));
    }
}
