import re
from abc import ABC, abstractmethod
from datetime import date, datetime, time
from decimal import Decimal
from enum import Enum
from functools import partial
from keyword import iskeyword
from operator import attrgetter
from textwrap import dedent
from textwrap import indent as base_indent
from typing import Generic, TypeVar

from attrs import Factory, define
from graphql import (
    GraphQLArgument,
    GraphQLField,
    GraphQLInputField,
    GraphQLInputObjectType,
    GraphQLInputType,
    GraphQLNamedType,
    GraphQLObjectType,
    GraphQLOutputType,
    GraphQLScalarType,
    GraphQLSchema,
    Undefined,
    is_input_object_type,
    is_leaf_type,
    is_list_type,
    is_non_null_type,
    is_object_type,
    is_scalar_type,
    is_wrapping_type,
)
from graphql.pyutils import camel_to_snake

ACRONYM_RE = re.compile(r"([A-Z\d]+)(?=[A-Z\d]|$)")

indent = partial(base_indent, prefix=" " * 4)


class Scalars(Enum):
    ID = str
    Int = int
    String = str
    Float = float
    Boolean = bool
    Date = date
    DateTime = datetime
    Time = time
    Decimal = Decimal

    @classmethod
    def from_type(cls, t: GraphQLNamedType) -> str:
        if not is_scalar_type(t):
            return t.name
        try:
            return cls[t.name].value.__name__
        except KeyError:
            return t.name


def is_custom_scalar_type(t: GraphQLNamedType):
    return is_scalar_type(t) and t.name not in Scalars.__members__


def is_output_leaf_type(t: GraphQLOutputType) -> bool:
    return is_leaf_type(t) or (is_wrapping_type(t) and is_output_leaf_type(t.of_type))


def format_name(s: str) -> str:
    # rewrite acronyms, initialisms and abbreviations
    s = ACRONYM_RE.sub(lambda m: m.group(0).title(), s)
    s = camel_to_snake(s)
    if iskeyword(s):
        s += "_"
    return s


def format_input_type(t: GraphQLInputType) -> str:
    if is_non_null_type(t):
        t = t.of_type
        fmt = "%s"
    else:
        fmt = "%s | None"

    if is_list_type(t):
        return fmt % f"list[{format_input_type(t.of_type)}]"

    return fmt % Scalars.from_type(t)


def format_output_type(t: GraphQLOutputType) -> str:
    # only wrap optional and list when ready to execute
    if is_output_leaf_type(t):
        return format_input_type(t)

    # when building the query return shouldn't be None
    # even if optional to not break the chain
    if is_wrapping_type(t):
        return format_output_type(t.of_type)

    return Scalars.from_type(t)


def doc(s: str) -> str:
    return f'"""\n{s}\n"""'


def generate(schema: GraphQLSchema) -> str:
    handlers: tuple[Handler, ...] = (
        Scalar(),
        Input(),
        Object(),
    )

    for t in sorted(schema.type_map.values(), key=attrgetter("name")):
        # internal GraphQL type
        if t.name.startswith("__"):
            continue
        for handler in handlers:
            if handler.predicate(t):
                handler.render(t)
                break

    code = [
        dedent(
            """\
        # Code generated by dagger. DO NOT EDIT.

        from typing import NewType

        from dagger.client.api import Arg, Type

        """
        )
    ]

    for handler in handlers:
        code.extend(handler.output)

    return "\n".join(code)


class _Field:
    def __init__(self, name: str) -> None:
        self.graphql_name = name
        self.name = format_name(name)


class _InputField(_Field):
    """Input object field or object field argument."""

    def __init__(self, name: str, graphql: GraphQLInputField | GraphQLArgument) -> None:
        super().__init__(name)
        self.graphql = graphql
        self.type = format_input_type(graphql.type)
        self.description = graphql.description

        self.has_default = graphql.default_value is not Undefined
        self.default_value = graphql.default_value

        if not is_non_null_type(graphql.type) and not self.has_default:
            self.default_value = None
            self.has_default = True

    def __str__(self) -> str:
        """Output for an InputObject field."""
        sig = self.as_param()
        if self.description:
            return f"{sig}\n{doc(self.description)}"
        return sig

    def as_param(self) -> str:
        """As a parameter in a function signature."""
        out = f"{self.name}: {self.type}"
        if self.has_default:
            out = f"{out} = {repr(self.default_value)}"
        return out

    def as_arg(self) -> str:
        """As a Arg object for the query builder."""
        params = [f"'{self.graphql_name}'", self.name]
        if self.has_default:
            params.append(repr(self.default_value))
        return f"Arg({', '.join(params)}),"


class _ObjectField(_Field):
    def __init__(self, name: str, field: GraphQLField) -> None:
        super().__init__(name)
        self.graphql = field
        self.args = sorted(
            (_InputField(name, arg) for name, arg in field.args.items()),
            key=lambda i: (i.has_default, i.name),
        )
        self.description = field.description
        self.is_leaf = is_output_leaf_type(field.type)
        self.type = format_output_type(field.type)

    def __str__(self) -> str:
        return f"{self.func_signature()}:\n{indent(self.func_body())}\n"

    def func_signature(self) -> str:
        params = ", ".join(["self"] + [a.as_param() for a in self.args])
        return f'def {self.name}({params}) -> "{self.type}"'

    def func_body(self) -> str:
        out = []
        if self.description:
            out.append(doc(self.description))

        if not self.args:
            out.append("_args = []")
        else:
            out.extend(["_args = [", indent("\n".join(arg.as_arg() for arg in self.args)), "]"])
        out.append(f'_ctx = self._select("{self.graphql_name}", _args)')

        if self.is_leaf:
            out.append(f"return _ctx.execute({self.type})")
        else:
            out.append(f"return {self.type}(_ctx)")

        return "\n".join(out)


H = TypeVar("H", bound=GraphQLNamedType)


@define
class Handler(ABC, Generic[H]):
    # Each render will add to the handler's output so that types can
    # be processed in random order but output contiguously for each kind.
    output: list[str] = Factory(list)

    @staticmethod
    def predicate(t: H) -> bool:
        """Does this handler render the given type?"""
        return True

    def render(self, t: H) -> None:
        self.output.append(f"{self.render_head(t)}\n{self.render_body(t)}")

    @abstractmethod
    def render_head(self, t: H) -> str:
        ...

    def render_body(self, t: H) -> str:
        return f"{doc(t.description)}\n\n" if t.description else ""


@define
class Scalar(Handler[GraphQLScalarType]):
    predicate = staticmethod(is_custom_scalar_type)

    def render_head(self, t: GraphQLScalarType) -> str:
        return f'{t.name} = NewType("{t.name}", str)'


T = TypeVar("T", GraphQLInputObjectType, GraphQLObjectType)
F = TypeVar("F", bound=_Field)


class Type(Handler[T]):
    field_type: type[F]

    def render_head(self, t: T) -> str:
        return f"class {t.name}(Type):"

    def render_body(self, t: T) -> list[str]:
        body = sorted(
            (self.field_type(n, f) for n, f in t.fields.items()),
            key=attrgetter("name"),
        )
        return indent(super().render_body(t) + "\n".join(map(str, body)))


class Input(Type[GraphQLInputObjectType]):
    field_type: _InputField
    predicate = staticmethod(is_input_object_type)


class Object(Type[GraphQLObjectType]):
    field_type = _ObjectField
    predicate = staticmethod(is_object_type)
