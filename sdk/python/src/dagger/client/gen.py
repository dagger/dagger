# Code generated by dagger. DO NOT EDIT.

import warnings
from collections.abc import Callable, Sequence
from dataclasses import dataclass

from ._core import Arg, Root
from ._guards import typecheck
from .base import Enum, Input, Scalar, Type


class CacheVolumeID(Scalar):
    """The `CacheVolumeID` scalar type represents an identifier for an
    object of type CacheVolume."""


class ContainerID(Scalar):
    """The `ContainerID` scalar type represents an identifier for an
    object of type Container."""


class DirectoryID(Scalar):
    """The `DirectoryID` scalar type represents an identifier for an
    object of type Directory."""


class EnvVariableID(Scalar):
    """The `EnvVariableID` scalar type represents an identifier for an
    object of type EnvVariable."""


class FieldTypeDefID(Scalar):
    """The `FieldTypeDefID` scalar type represents an identifier for an
    object of type FieldTypeDef."""


class FileID(Scalar):
    """The `FileID` scalar type represents an identifier for an object of
    type File."""


class FunctionArgID(Scalar):
    """The `FunctionArgID` scalar type represents an identifier for an
    object of type FunctionArg."""


class FunctionCallArgValueID(Scalar):
    """The `FunctionCallArgValueID` scalar type represents an identifier
    for an object of type FunctionCallArgValue."""


class FunctionCallID(Scalar):
    """The `FunctionCallID` scalar type represents an identifier for an
    object of type FunctionCall."""


class FunctionID(Scalar):
    """The `FunctionID` scalar type represents an identifier for an object
    of type Function."""


class GeneratedCodeID(Scalar):
    """The `GeneratedCodeID` scalar type represents an identifier for an
    object of type GeneratedCode."""


class GitRefID(Scalar):
    """The `GitRefID` scalar type represents an identifier for an object
    of type GitRef."""


class GitRepositoryID(Scalar):
    """The `GitRepositoryID` scalar type represents an identifier for an
    object of type GitRepository."""


class HostID(Scalar):
    """The `HostID` scalar type represents an identifier for an object of
    type Host."""


class InterfaceTypeDefID(Scalar):
    """The `InterfaceTypeDefID` scalar type represents an identifier for
    an object of type InterfaceTypeDef."""


class JSON(Scalar):
    """An arbitrary JSON-encoded value."""


class LabelID(Scalar):
    """The `LabelID` scalar type represents an identifier for an object of
    type Label."""


class ListTypeDefID(Scalar):
    """The `ListTypeDefID` scalar type represents an identifier for an
    object of type ListTypeDef."""


class ModuleConfigID(Scalar):
    """The `ModuleConfigID` scalar type represents an identifier for an
    object of type ModuleConfig."""


class ModuleID(Scalar):
    """The `ModuleID` scalar type represents an identifier for an object
    of type Module."""


class ObjectTypeDefID(Scalar):
    """The `ObjectTypeDefID` scalar type represents an identifier for an
    object of type ObjectTypeDef."""


class Platform(Scalar):
    """The platform config OS and architecture in a Container.  The format
    is [os]/[platform]/[version] (e.g., "darwin/arm64/v7",
    "windows/amd64", "linux/arm64")."""


class PortID(Scalar):
    """The `PortID` scalar type represents an identifier for an object of
    type Port."""


class SecretID(Scalar):
    """The `SecretID` scalar type represents an identifier for an object
    of type Secret."""


class ServiceID(Scalar):
    """The `ServiceID` scalar type represents an identifier for an object
    of type Service."""


class SocketID(Scalar):
    """The `SocketID` scalar type represents an identifier for an object
    of type Socket."""


class TypeDefID(Scalar):
    """The `TypeDefID` scalar type represents an identifier for an object
    of type TypeDef."""


class Void(Scalar):
    """The absence of a value.  A Null Void is used as a placeholder for
    resolvers that do not return anything."""


class CacheSharingMode(Enum):
    """Sharing mode of the cache volume."""

    LOCKED = "LOCKED"
    """Shares the cache volume amongst many build pipelines, but will serialize the writes"""

    PRIVATE = "PRIVATE"
    """Keeps a cache volume for a single build pipeline"""

    SHARED = "SHARED"
    """Shares the cache volume amongst many build pipelines"""


class ImageLayerCompression(Enum):
    """Compression algorithm to use for image layers."""

    EStarGZ = "EStarGZ"

    Gzip = "Gzip"

    Uncompressed = "Uncompressed"

    Zstd = "Zstd"


class ImageMediaTypes(Enum):
    """Mediatypes to use in published or exported image metadata."""

    DockerMediaTypes = "DockerMediaTypes"

    OCIMediaTypes = "OCIMediaTypes"


class NetworkProtocol(Enum):
    """Transport layer network protocol associated to a port."""

    TCP = "TCP"

    UDP = "UDP"


class TypeDefKind(Enum):
    """Distinguishes the different kinds of TypeDefs."""

    BOOLEAN_KIND = "BOOLEAN_KIND"
    """A boolean value."""

    INTEGER_KIND = "INTEGER_KIND"
    """An integer value."""

    INTERFACE_KIND = "INTERFACE_KIND"
    """A named type of functions that can be matched+implemented by other objects+interfaces.

    Always paired with an InterfaceTypeDef.
    """

    LIST_KIND = "LIST_KIND"
    """A list of values all having the same type.

    Always paired with a ListTypeDef.
    """

    OBJECT_KIND = "OBJECT_KIND"
    """A named type defined in the GraphQL schema, with fields and functions.

    Always paired with an ObjectTypeDef.
    """

    STRING_KIND = "STRING_KIND"
    """A string value."""

    VOID_KIND = "VOID_KIND"
    """A special kind used to signify that no value is returned.

    This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
    """


@dataclass(slots=True)
class BuildArg(Input):
    """Key value object that represents a build argument."""

    name: str
    """The build argument name."""

    value: str
    """The build argument value."""


@dataclass(slots=True)
class PipelineLabel(Input):
    """Key value object that represents a pipeline label."""

    name: str
    """Label name."""

    value: str
    """Label value."""


@dataclass(slots=True)
class PortForward(Input):
    """Port forwarding rules for tunneling network traffic."""

    backend: int
    """Destination port for traffic."""

    frontend: int | None = None
    """Port to expose to clients. If unspecified, a default will be chosen."""

    protocol: NetworkProtocol | None = "TCP"
    """Transport layer protocol to use for traffic."""


class CacheVolume(Type):
    """A directory whose contents persist across runs."""

    @typecheck
    async def id(self) -> CacheVolumeID:
        """A unique identifier for this CacheVolume.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        CacheVolumeID
            The `CacheVolumeID` scalar type represents an identifier for an
            object of type CacheVolume.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(CacheVolumeID)


class Container(Type):
    """An OCI-compatible container, also known as a Docker container."""

    @typecheck
    def as_service(self) -> "Service":
        """Turn the container into a Service.

        Be sure to set any exposed ports before this conversion.
        """
        _args: list[Arg] = []
        _ctx = self._select("asService", _args)
        return Service(_ctx)

    @typecheck
    def as_tarball(
        self,
        *,
        platform_variants: Sequence["Container"] | None = [],
        forced_compression: ImageLayerCompression | None = None,
        media_types: ImageMediaTypes | None = "OCIMediaTypes",
    ) -> "File":
        """Returns a File representing the container serialized to a tarball.

        Parameters
        ----------
        platform_variants:
            Identifiers for other platform specific containers.
            Used for multi-platform images.
        forced_compression:
            Force each layer of the image to use the specified compression
            algorithm.
            If this is unset, then if a layer already has a compressed blob in
            the engine's cache, that will be used (this can result in a mix of
            compression algorithms for different layers). If this is unset and
            a layer has no compressed blob in the engine's cache, then it will
            be compressed using Gzip.
        media_types:
            Use the specified media types for the image's layers.
            Defaults to OCI, which is largely compatible with most recent
            container runtimes, but Docker may be needed for older runtimes
            without OCI support.
        """
        _args = [
            Arg("platformVariants", platform_variants, []),
            Arg("forcedCompression", forced_compression, None),
            Arg("mediaTypes", media_types, "OCIMediaTypes"),
        ]
        _ctx = self._select("asTarball", _args)
        return File(_ctx)

    @typecheck
    def build(
        self,
        context: "Directory",
        *,
        dockerfile: str | None = "Dockerfile",
        target: str | None = "",
        build_args: Sequence[BuildArg] | None = [],
        secrets: Sequence["Secret"] | None = [],
    ) -> "Container":
        """Initializes this container from a Dockerfile build.

        Parameters
        ----------
        context:
            Directory context used by the Dockerfile.
        dockerfile:
            Path to the Dockerfile to use.
        target:
            Target build stage to build.
        build_args:
            Additional build arguments.
        secrets:
            Secrets to pass to the build.
            They will be mounted at /run/secrets/[secret-name] in the build
            container
            They can be accessed in the Dockerfile using the "secret" mount
            type and mount path /run/secrets/[secret-name], e.g. RUN
            --mount=type=secret,id=my-secret curl
            http://example.com?token=$(cat /run/secrets/my-secret)
        """
        _args = [
            Arg("context", context),
            Arg("dockerfile", dockerfile, "Dockerfile"),
            Arg("target", target, ""),
            Arg("buildArgs", build_args, []),
            Arg("secrets", secrets, []),
        ]
        _ctx = self._select("build", _args)
        return Container(_ctx)

    @typecheck
    async def default_args(self) -> list[str]:
        """Retrieves default arguments for future commands.

        Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("defaultArgs", _args)
        return await _ctx.execute(list[str])

    @typecheck
    def directory(self, path: str) -> "Directory":
        """Retrieves a directory at the given path.

        Mounts are included.

        Parameters
        ----------
        path:
            The path of the directory to retrieve (e.g., "./src").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("directory", _args)
        return Directory(_ctx)

    @typecheck
    async def entrypoint(self) -> list[str]:
        """Retrieves entrypoint to be prepended to the arguments of all commands.

        Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("entrypoint", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def env_variable(self, name: str) -> str | None:
        """Retrieves the value of the specified environment variable.

        Parameters
        ----------
        name:
            The name of the environment variable to retrieve (e.g., "PATH").

        Returns
        -------
        str | None
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("envVariable", _args)
        return await _ctx.execute(str | None)

    @typecheck
    async def env_variables(self) -> list["EnvVariable"]:
        """Retrieves the list of environment variables passed to commands."""
        _args: list[Arg] = []
        _ctx = self._select("envVariables", _args)
        _ctx = EnvVariable(_ctx)._select_multiple(
            _name="name",
            _value="value",
        )
        return await _ctx.execute(list[EnvVariable])

    @typecheck
    def experimental_with_all_gp_us(self) -> "Container":
        """EXPERIMENTAL API! Subject to change/removal at any time.

        Configures all available GPUs on the host to be accessible to this
        container.

        This currently works for Nvidia devices only.
        """
        _args: list[Arg] = []
        _ctx = self._select("experimentalWithAllGPUs", _args)
        return Container(_ctx)

    @typecheck
    def experimental_with_gpu(self, devices: Sequence[str]) -> "Container":
        """EXPERIMENTAL API! Subject to change/removal at any time.

        Configures the provided list of devices to be accesible to this
        container.

        This currently works for Nvidia devices only.

        Parameters
        ----------
        devices:
            List of devices to be accessible to this container.
        """
        _args = [
            Arg("devices", devices),
        ]
        _ctx = self._select("experimentalWithGPU", _args)
        return Container(_ctx)

    @typecheck
    async def export(
        self,
        path: str,
        *,
        platform_variants: Sequence["Container"] | None = [],
        forced_compression: ImageLayerCompression | None = None,
        media_types: ImageMediaTypes | None = "OCIMediaTypes",
    ) -> bool:
        """Writes the container as an OCI tarball to the destination file path on
        the host.

        Return true on success.

        It can also export platform variants.

        Parameters
        ----------
        path:
            Host's destination path (e.g., "./tarball").
            Path can be relative to the engine's workdir or absolute.
        platform_variants:
            Identifiers for other platform specific containers.
            Used for multi-platform image.
        forced_compression:
            Force each layer of the exported image to use the specified
            compression algorithm.
            If this is unset, then if a layer already has a compressed blob in
            the engine's cache, that will be used (this can result in a mix of
            compression algorithms for different layers). If this is unset and
            a layer has no compressed blob in the engine's cache, then it will
            be compressed using Gzip.
        media_types:
            Use the specified media types for the exported image's layers.
            Defaults to OCI, which is largely compatible with most recent
            container runtimes, but Docker may be needed for older runtimes
            without OCI support.

        Returns
        -------
        bool
            The `Boolean` scalar type represents `true` or `false`.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("path", path),
            Arg("platformVariants", platform_variants, []),
            Arg("forcedCompression", forced_compression, None),
            Arg("mediaTypes", media_types, "OCIMediaTypes"),
        ]
        _ctx = self._select("export", _args)
        return await _ctx.execute(bool)

    @typecheck
    async def exposed_ports(self) -> list["Port"]:
        """Retrieves the list of exposed ports.

        This includes ports already exposed by the image, even if not
        explicitly added with dagger.
        """
        _args: list[Arg] = []
        _ctx = self._select("exposedPorts", _args)
        _ctx = Port(_ctx)._select_multiple(
            _description="description",
            _port="port",
            _protocol="protocol",
        )
        return await _ctx.execute(list[Port])

    @typecheck
    def file(self, path: str) -> "File":
        """Retrieves a file at the given path.

        Mounts are included.

        Parameters
        ----------
        path:
            The path of the file to retrieve (e.g., "./README.md").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("file", _args)
        return File(_ctx)

    @typecheck
    def from_(self, address: str) -> "Container":
        """Initializes this container from a pulled base image.

        Parameters
        ----------
        address:
            Image's address from its registry.
            Formatted as [host]/[user]/[repo]:[tag] (e.g.,
            "docker.io/dagger/dagger:main").
        """
        _args = [
            Arg("address", address),
        ]
        _ctx = self._select("from", _args)
        return Container(_ctx)

    @typecheck
    async def id(self) -> ContainerID:
        """A unique identifier for this Container.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ContainerID
            The `ContainerID` scalar type represents an identifier for an
            object of type Container.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ContainerID)

    @typecheck
    async def image_ref(self) -> str:
        """The unique image reference which can only be retrieved immediately
        after the 'Container.From' call.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("imageRef", _args)
        return await _ctx.execute(str)

    @typecheck
    def import_(
        self,
        source: "File",
        *,
        tag: str | None = "",
    ) -> "Container":
        """Reads the container from an OCI tarball.

        Parameters
        ----------
        source:
            File to read the container from.
        tag:
            Identifies the tag to import from the archive, if the archive
            bundles multiple tags.
        """
        _args = [
            Arg("source", source),
            Arg("tag", tag, ""),
        ]
        _ctx = self._select("import", _args)
        return Container(_ctx)

    @typecheck
    async def label(self, name: str) -> str | None:
        """Retrieves the value of the specified label.

        Parameters
        ----------
        name:
            The name of the label (e.g.,
            "org.opencontainers.artifact.created").

        Returns
        -------
        str | None
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("label", _args)
        return await _ctx.execute(str | None)

    @typecheck
    async def labels(self) -> list["Label"]:
        """Retrieves the list of labels passed to container."""
        _args: list[Arg] = []
        _ctx = self._select("labels", _args)
        _ctx = Label(_ctx)._select_multiple(
            _name="name",
            _value="value",
        )
        return await _ctx.execute(list[Label])

    @typecheck
    async def mounts(self) -> list[str]:
        """Retrieves the list of paths where a directory is mounted.

        Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("mounts", _args)
        return await _ctx.execute(list[str])

    @typecheck
    def pipeline(
        self,
        name: str,
        *,
        description: str | None = "",
        labels: Sequence[PipelineLabel] | None = [],
    ) -> "Container":
        """Creates a named sub-pipeline.

        Parameters
        ----------
        name:
            Name of the sub-pipeline.
        description:
            Description of the sub-pipeline.
        labels:
            Labels to apply to the sub-pipeline.
        """
        _args = [
            Arg("name", name),
            Arg("description", description, ""),
            Arg("labels", labels, []),
        ]
        _ctx = self._select("pipeline", _args)
        return Container(_ctx)

    @typecheck
    async def platform(self) -> Platform:
        """The platform this container executes and publishes as.

        Returns
        -------
        Platform
            The platform config OS and architecture in a Container.  The
            format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7",
            "windows/amd64", "linux/arm64").

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("platform", _args)
        return await _ctx.execute(Platform)

    @typecheck
    async def publish(
        self,
        address: str,
        *,
        platform_variants: Sequence["Container"] | None = [],
        forced_compression: ImageLayerCompression | None = None,
        media_types: ImageMediaTypes | None = "OCIMediaTypes",
    ) -> str:
        """Publishes this container as a new image to the specified address.

        Publish returns a fully qualified ref.

        It can also publish platform variants.

        Parameters
        ----------
        address:
            Registry's address to publish the image to.
            Formatted as [host]/[user]/[repo]:[tag] (e.g.
            "docker.io/dagger/dagger:main").
        platform_variants:
            Identifiers for other platform specific containers.
            Used for multi-platform image.
        forced_compression:
            Force each layer of the published image to use the specified
            compression algorithm.
            If this is unset, then if a layer already has a compressed blob in
            the engine's cache, that will be used (this can result in a mix of
            compression algorithms for different layers). If this is unset and
            a layer has no compressed blob in the engine's cache, then it will
            be compressed using Gzip.
        media_types:
            Use the specified media types for the published image's layers.
            Defaults to OCI, which is largely compatible with most recent
            registries, but Docker may be needed for older registries without
            OCI support.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("address", address),
            Arg("platformVariants", platform_variants, []),
            Arg("forcedCompression", forced_compression, None),
            Arg("mediaTypes", media_types, "OCIMediaTypes"),
        ]
        _ctx = self._select("publish", _args)
        return await _ctx.execute(str)

    @typecheck
    def rootfs(self) -> "Directory":
        """Retrieves this container's root filesystem. Mounts are not included."""
        _args: list[Arg] = []
        _ctx = self._select("rootfs", _args)
        return Directory(_ctx)

    @typecheck
    async def shell_endpoint(self) -> str:
        """Return a websocket endpoint that, if connected to, will start the
        container with a TTY streamed over the websocket.

        Primarily intended for internal use with the dagger CLI.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("shellEndpoint", _args)
        return await _ctx.execute(str)

    @typecheck
    async def stderr(self) -> str:
        """The error stream of the last executed command.

        Will execute default command if none is set, or error if there's no
        default.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("stderr", _args)
        return await _ctx.execute(str)

    @typecheck
    async def stdout(self) -> str:
        """The output stream of the last executed command.

        Will execute default command if none is set, or error if there's no
        default.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("stdout", _args)
        return await _ctx.execute(str)

    @typecheck
    async def sync(self) -> "Container":
        """Forces evaluation of the pipeline in the engine.

        It doesn't run the default command if no exec has been set.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sync", _args)
        _id = await _ctx.execute(ContainerID)
        _ctx = Client.from_context(_ctx)._select(
            "loadContainerFromID", [Arg("id", _id)]
        )
        return Container(_ctx)

    def __await__(self):
        return self.sync().__await__()

    @typecheck
    async def user(self) -> str:
        """Retrieves the user to be set for all commands.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("user", _args)
        return await _ctx.execute(str)

    @typecheck
    def with_default_args(self, args: Sequence[str]) -> "Container":
        """Configures default arguments for future commands.

        Parameters
        ----------
        args:
            Arguments to prepend to future executions (e.g., ["-v", "--no-
            cache"]).
        """
        _args = [
            Arg("args", args),
        ]
        _ctx = self._select("withDefaultArgs", _args)
        return Container(_ctx)

    @typecheck
    def with_directory(
        self,
        path: str,
        directory: "Directory",
        *,
        exclude: Sequence[str] | None = [],
        include: Sequence[str] | None = [],
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a directory written at the given path.

        Parameters
        ----------
        path:
            Location of the written directory (e.g., "/tmp/directory").
        directory:
            Identifier of the directory to write
        exclude:
            Patterns to exclude in the written directory (e.g.
            ["node_modules/**", ".gitignore", ".git/"]).
        include:
            Patterns to include in the written directory (e.g. ["*.go",
            "go.mod", "go.sum"]).
        owner:
            A user:group to set for the directory and its contents.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("directory", directory),
            Arg("exclude", exclude, []),
            Arg("include", include, []),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withDirectory", _args)
        return Container(_ctx)

    @typecheck
    def with_entrypoint(
        self,
        args: Sequence[str],
        *,
        keep_default_args: bool | None = False,
    ) -> "Container":
        """Retrieves this container but with a different command entrypoint.

        Parameters
        ----------
        args:
            Entrypoint to use for future executions (e.g., ["go", "run"]).
        keep_default_args:
            Don't remove the default arguments when setting the entrypoint.
        """
        _args = [
            Arg("args", args),
            Arg("keepDefaultArgs", keep_default_args, False),
        ]
        _ctx = self._select("withEntrypoint", _args)
        return Container(_ctx)

    @typecheck
    def with_env_variable(
        self,
        name: str,
        value: str,
        *,
        expand: bool | None = False,
    ) -> "Container":
        """Retrieves this container plus the given environment variable.

        Parameters
        ----------
        name:
            The name of the environment variable (e.g., "HOST").
        value:
            The value of the environment variable. (e.g., "localhost").
        expand:
            Replace `${VAR}` or `$VAR` in the value according to the current
            environment variables defined in the container (e.g.,
            "/opt/bin:$PATH").
        """
        _args = [
            Arg("name", name),
            Arg("value", value),
            Arg("expand", expand, False),
        ]
        _ctx = self._select("withEnvVariable", _args)
        return Container(_ctx)

    @typecheck
    def with_exec(
        self,
        args: Sequence[str],
        *,
        skip_entrypoint: bool | None = False,
        stdin: str | None = "",
        redirect_stdout: str | None = "",
        redirect_stderr: str | None = "",
        experimental_privileged_nesting: bool | None = False,
        insecure_root_capabilities: bool | None = False,
    ) -> "Container":
        """Retrieves this container after executing the specified command inside
        it.

        Parameters
        ----------
        args:
            Command to run instead of the container's default command (e.g.,
            ["run", "main.go"]).
            If empty, the container's default command is used.
        skip_entrypoint:
            If the container has an entrypoint, ignore it for args rather than
            using it to wrap them.
        stdin:
            Content to write to the command's standard input before closing
            (e.g., "Hello world").
        redirect_stdout:
            Redirect the command's standard output to a file in the container
            (e.g., "/tmp/stdout").
        redirect_stderr:
            Redirect the command's standard error to a file in the container
            (e.g., "/tmp/stderr").
        experimental_privileged_nesting:
            Provides dagger access to the executed command.
            Do not use this option unless you trust the command being
            executed; the command being executed WILL BE GRANTED FULL ACCESS
            TO YOUR HOST FILESYSTEM.
        insecure_root_capabilities:
            Execute the command with all root capabilities. This is similar to
            running a command with "sudo" or executing "docker run" with the "
            --privileged" flag. Containerization does not provide any security
            guarantees when using this option. It should only be used when
            absolutely necessary and only with trusted commands.
        """
        _args = [
            Arg("args", args),
            Arg("skipEntrypoint", skip_entrypoint, False),
            Arg("stdin", stdin, ""),
            Arg("redirectStdout", redirect_stdout, ""),
            Arg("redirectStderr", redirect_stderr, ""),
            Arg(
                "experimentalPrivilegedNesting", experimental_privileged_nesting, False
            ),
            Arg("insecureRootCapabilities", insecure_root_capabilities, False),
        ]
        _ctx = self._select("withExec", _args)
        return Container(_ctx)

    @typecheck
    def with_exposed_port(
        self,
        port: int,
        *,
        protocol: NetworkProtocol | None = "TCP",
        description: str | None = None,
    ) -> "Container":
        """Expose a network port.

        Exposed ports serve two purposes:

        - For health checks and introspection, when running services

        - For setting the EXPOSE OCI field when publishing the container

        Parameters
        ----------
        port:
            Port number to expose
        protocol:
            Transport layer network protocol
        description:
            Optional port description
        """
        _args = [
            Arg("port", port),
            Arg("protocol", protocol, "TCP"),
            Arg("description", description, None),
        ]
        _ctx = self._select("withExposedPort", _args)
        return Container(_ctx)

    @typecheck
    def with_file(
        self,
        path: str,
        source: "File",
        *,
        permissions: int | None = None,
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus the contents of the given file copied to
        the given path.

        Parameters
        ----------
        path:
            Location of the copied file (e.g., "/tmp/file.txt").
        source:
            Identifier of the file to copy.
        permissions:
            Permission given to the copied file (e.g., 0600).
        owner:
            A user:group to set for the file.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("permissions", permissions, None),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withFile", _args)
        return Container(_ctx)

    @typecheck
    def with_focus(self) -> "Container":
        """Indicate that subsequent operations should be featured more
        prominently in the UI.
        """
        _args: list[Arg] = []
        _ctx = self._select("withFocus", _args)
        return Container(_ctx)

    @typecheck
    def with_label(self, name: str, value: str) -> "Container":
        """Retrieves this container plus the given label.

        Parameters
        ----------
        name:
            The name of the label (e.g.,
            "org.opencontainers.artifact.created").
        value:
            The value of the label (e.g., "2023-01-01T00:00:00Z").
        """
        _args = [
            Arg("name", name),
            Arg("value", value),
        ]
        _ctx = self._select("withLabel", _args)
        return Container(_ctx)

    @typecheck
    def with_mounted_cache(
        self,
        path: str,
        cache: CacheVolume,
        *,
        source: "Directory | None" = None,
        sharing: CacheSharingMode | None = "SHARED",
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a cache volume mounted at the given
        path.

        Parameters
        ----------
        path:
            Location of the cache directory (e.g., "/cache/node_modules").
        cache:
            Identifier of the cache volume to mount.
        source:
            Identifier of the directory to use as the cache volume's root.
        sharing:
            Sharing mode of the cache volume.
        owner:
            A user:group to set for the mounted cache directory.
            Note that this changes the ownership of the specified mount along
            with the initial filesystem provided by source (if any). It does
            not have any effect if/when the cache has already been created.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("cache", cache),
            Arg("source", source, None),
            Arg("sharing", sharing, "SHARED"),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withMountedCache", _args)
        return Container(_ctx)

    @typecheck
    def with_mounted_directory(
        self,
        path: str,
        source: "Directory",
        *,
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a directory mounted at the given path.

        Parameters
        ----------
        path:
            Location of the mounted directory (e.g., "/mnt/directory").
        source:
            Identifier of the mounted directory.
        owner:
            A user:group to set for the mounted directory and its contents.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withMountedDirectory", _args)
        return Container(_ctx)

    @typecheck
    def with_mounted_file(
        self,
        path: str,
        source: "File",
        *,
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a file mounted at the given path.

        Parameters
        ----------
        path:
            Location of the mounted file (e.g., "/tmp/file.txt").
        source:
            Identifier of the mounted file.
        owner:
            A user or user:group to set for the mounted file.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withMountedFile", _args)
        return Container(_ctx)

    @typecheck
    def with_mounted_secret(
        self,
        path: str,
        source: "Secret",
        *,
        owner: str | None = "",
        mode: int | None = 256,
    ) -> "Container":
        """Retrieves this container plus a secret mounted into a file at the
        given path.

        Parameters
        ----------
        path:
            Location of the secret file (e.g., "/tmp/secret.txt").
        source:
            Identifier of the secret to mount.
        owner:
            A user:group to set for the mounted secret.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        mode:
            Permission given to the mounted secret (e.g., 0600).
            This option requires an owner to be set to be active.
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("owner", owner, ""),
            Arg("mode", mode, 256),
        ]
        _ctx = self._select("withMountedSecret", _args)
        return Container(_ctx)

    @typecheck
    def with_mounted_temp(self, path: str) -> "Container":
        """Retrieves this container plus a temporary directory mounted at the
        given path.

        Parameters
        ----------
        path:
            Location of the temporary directory (e.g., "/tmp/temp_dir").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withMountedTemp", _args)
        return Container(_ctx)

    @typecheck
    def with_new_file(
        self,
        path: str,
        *,
        contents: str | None = "",
        permissions: int | None = 420,
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a new file written at the given path.

        Parameters
        ----------
        path:
            Location of the written file (e.g., "/tmp/file.txt").
        contents:
            Content of the file to write (e.g., "Hello world!").
        permissions:
            Permission given to the written file (e.g., 0600).
        owner:
            A user:group to set for the file.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("contents", contents, ""),
            Arg("permissions", permissions, 420),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withNewFile", _args)
        return Container(_ctx)

    @typecheck
    def with_registry_auth(
        self,
        address: str,
        username: str,
        secret: "Secret",
    ) -> "Container":
        """Retrieves this container with a registry authentication for a given
        address.

        Parameters
        ----------
        address:
            Registry's address to bind the authentication to.
            Formatted as [host]/[user]/[repo]:[tag] (e.g.
            docker.io/dagger/dagger:main).
        username:
            The username of the registry's account (e.g., "Dagger").
        secret:
            The API key, password or token to authenticate to this registry.
        """
        _args = [
            Arg("address", address),
            Arg("username", username),
            Arg("secret", secret),
        ]
        _ctx = self._select("withRegistryAuth", _args)
        return Container(_ctx)

    @typecheck
    def with_rootfs(self, directory: "Directory") -> "Container":
        """Retrieves the container with the given directory mounted to /.

        Parameters
        ----------
        directory:
            Directory to mount.
        """
        _args = [
            Arg("directory", directory),
        ]
        _ctx = self._select("withRootfs", _args)
        return Container(_ctx)

    @typecheck
    def with_secret_variable(self, name: str, secret: "Secret") -> "Container":
        """Retrieves this container plus an env variable containing the given
        secret.

        Parameters
        ----------
        name:
            The name of the secret variable (e.g., "API_SECRET").
        secret:
            The identifier of the secret value.
        """
        _args = [
            Arg("name", name),
            Arg("secret", secret),
        ]
        _ctx = self._select("withSecretVariable", _args)
        return Container(_ctx)

    @typecheck
    def with_service_binding(self, alias: str, service: "Service") -> "Container":
        """Establish a runtime dependency on a service.

        The service will be started automatically when needed and detached
        when it is no longer needed, executing the default command if none is
        set.

        The service will be reachable from the container via the provided
        hostname alias.

        The service dependency will also convey to any files or directories
        produced by the container.

        Parameters
        ----------
        alias:
            A name that can be used to reach the service from the container
        service:
            Identifier of the service container
        """
        _args = [
            Arg("alias", alias),
            Arg("service", service),
        ]
        _ctx = self._select("withServiceBinding", _args)
        return Container(_ctx)

    @typecheck
    def with_unix_socket(
        self,
        path: str,
        source: "Socket",
        *,
        owner: str | None = "",
    ) -> "Container":
        """Retrieves this container plus a socket forwarded to the given Unix
        socket path.

        Parameters
        ----------
        path:
            Location of the forwarded Unix socket (e.g., "/tmp/socket").
        source:
            Identifier of the socket to forward.
        owner:
            A user:group to set for the mounted socket.
            The user and group can either be an ID (1000:1000) or a name
            (foo:bar).
            If the group is omitted, it defaults to the same as the user.
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("owner", owner, ""),
        ]
        _ctx = self._select("withUnixSocket", _args)
        return Container(_ctx)

    @typecheck
    def with_user(self, name: str) -> "Container":
        """Retrieves this container with a different command user.

        Parameters
        ----------
        name:
            The user to set (e.g., "root").
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("withUser", _args)
        return Container(_ctx)

    @typecheck
    def with_workdir(self, path: str) -> "Container":
        """Retrieves this container with a different working directory.

        Parameters
        ----------
        path:
            The path to set as the working directory (e.g., "/app").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withWorkdir", _args)
        return Container(_ctx)

    @typecheck
    def without_default_args(self) -> "Container":
        """Retrieves this container with unset default arguments for future
        commands.
        """
        _args: list[Arg] = []
        _ctx = self._select("withoutDefaultArgs", _args)
        return Container(_ctx)

    @typecheck
    def without_entrypoint(
        self,
        *,
        keep_default_args: bool | None = False,
    ) -> "Container":
        """Retrieves this container with an unset command entrypoint.

        Parameters
        ----------
        keep_default_args:
            Don't remove the default arguments when unsetting the entrypoint.
        """
        _args = [
            Arg("keepDefaultArgs", keep_default_args, False),
        ]
        _ctx = self._select("withoutEntrypoint", _args)
        return Container(_ctx)

    @typecheck
    def without_env_variable(self, name: str) -> "Container":
        """Retrieves this container minus the given environment variable.

        Parameters
        ----------
        name:
            The name of the environment variable (e.g., "HOST").
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("withoutEnvVariable", _args)
        return Container(_ctx)

    @typecheck
    def without_exposed_port(
        self,
        port: int,
        *,
        protocol: NetworkProtocol | None = "TCP",
    ) -> "Container":
        """Unexpose a previously exposed port.

        Parameters
        ----------
        port:
            Port number to unexpose
        protocol:
            Port protocol to unexpose
        """
        _args = [
            Arg("port", port),
            Arg("protocol", protocol, "TCP"),
        ]
        _ctx = self._select("withoutExposedPort", _args)
        return Container(_ctx)

    @typecheck
    def without_focus(self) -> "Container":
        """Indicate that subsequent operations should not be featured more
        prominently in the UI.

        This is the initial state of all containers.
        """
        _args: list[Arg] = []
        _ctx = self._select("withoutFocus", _args)
        return Container(_ctx)

    @typecheck
    def without_label(self, name: str) -> "Container":
        """Retrieves this container minus the given environment label.

        Parameters
        ----------
        name:
            The name of the label to remove (e.g.,
            "org.opencontainers.artifact.created").
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("withoutLabel", _args)
        return Container(_ctx)

    @typecheck
    def without_mount(self, path: str) -> "Container":
        """Retrieves this container after unmounting everything at the given
        path.

        Parameters
        ----------
        path:
            Location of the cache directory (e.g., "/cache/node_modules").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withoutMount", _args)
        return Container(_ctx)

    @typecheck
    def without_registry_auth(self, address: str) -> "Container":
        """Retrieves this container without the registry authentication of a
        given address.

        Parameters
        ----------
        address:
            Registry's address to remove the authentication from.
            Formatted as [host]/[user]/[repo]:[tag] (e.g.
            docker.io/dagger/dagger:main).
        """
        _args = [
            Arg("address", address),
        ]
        _ctx = self._select("withoutRegistryAuth", _args)
        return Container(_ctx)

    @typecheck
    def without_unix_socket(self, path: str) -> "Container":
        """Retrieves this container with a previously added Unix socket removed.

        Parameters
        ----------
        path:
            Location of the socket to remove (e.g., "/tmp/socket").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withoutUnixSocket", _args)
        return Container(_ctx)

    @typecheck
    def without_user(self) -> "Container":
        """Retrieves this container with an unset command user.

        Should default to root.
        """
        _args: list[Arg] = []
        _ctx = self._select("withoutUser", _args)
        return Container(_ctx)

    @typecheck
    def without_workdir(self) -> "Container":
        """Retrieves this container with an unset working directory.

        Should default to "/".
        """
        _args: list[Arg] = []
        _ctx = self._select("withoutWorkdir", _args)
        return Container(_ctx)

    @typecheck
    async def workdir(self) -> str:
        """Retrieves the working directory for all commands.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("workdir", _args)
        return await _ctx.execute(str)

    def with_(self, cb: Callable[["Container"], "Container"]) -> "Container":
        """Call the provided callable with current Container.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class Directory(Type):
    """A directory."""

    @typecheck
    def as_module(self, *, source_subpath: str | None = "") -> "Module":
        """Load the directory as a Dagger module

        Parameters
        ----------
        source_subpath:
            An optional subpath of the directory which contains the module's
            source code.
            This is needed when the module code is in a subdirectory but
            requires parent directories to be loaded in order to execute. For
            example, the module source code may need a go.mod, project.toml,
            package.json, etc. file from a parent directory.
            If not set, the module source code is loaded from the root of the
            directory.
        """
        _args = [
            Arg("sourceSubpath", source_subpath, ""),
        ]
        _ctx = self._select("asModule", _args)
        return Module(_ctx)

    @typecheck
    def diff(self, other: "Directory") -> "Directory":
        """Gets the difference between this directory and an another directory.

        Parameters
        ----------
        other:
            Identifier of the directory to compare.
        """
        _args = [
            Arg("other", other),
        ]
        _ctx = self._select("diff", _args)
        return Directory(_ctx)

    @typecheck
    def directory(self, path: str) -> "Directory":
        """Retrieves a directory at the given path.

        Parameters
        ----------
        path:
            Location of the directory to retrieve (e.g., "/src").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("directory", _args)
        return Directory(_ctx)

    @typecheck
    def docker_build(
        self,
        *,
        platform: Platform | None = None,
        dockerfile: str | None = "Dockerfile",
        target: str | None = "",
        build_args: Sequence[BuildArg] | None = [],
        secrets: Sequence["Secret"] | None = [],
    ) -> Container:
        """Builds a new Docker container from this directory.

        Parameters
        ----------
        platform:
            The platform to build.
        dockerfile:
            Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
        target:
            Target build stage to build.
        build_args:
            Build arguments to use in the build.
        secrets:
            Secrets to pass to the build.
            They will be mounted at /run/secrets/[secret-name].
        """
        _args = [
            Arg("platform", platform, None),
            Arg("dockerfile", dockerfile, "Dockerfile"),
            Arg("target", target, ""),
            Arg("buildArgs", build_args, []),
            Arg("secrets", secrets, []),
        ]
        _ctx = self._select("dockerBuild", _args)
        return Container(_ctx)

    @typecheck
    async def entries(self, *, path: str | None = None) -> list[str]:
        """Returns a list of files and directories at the given path.

        Parameters
        ----------
        path:
            Location of the directory to look at (e.g., "/src").

        Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("path", path, None),
        ]
        _ctx = self._select("entries", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def export(self, path: str) -> bool:
        """Writes the contents of the directory to a path on the host.

        Parameters
        ----------
        path:
            Location of the copied directory (e.g., "logs/").

        Returns
        -------
        bool
            The `Boolean` scalar type represents `true` or `false`.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("export", _args)
        return await _ctx.execute(bool)

    @typecheck
    def file(self, path: str) -> "File":
        """Retrieves a file at the given path.

        Parameters
        ----------
        path:
            Location of the file to retrieve (e.g., "README.md").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("file", _args)
        return File(_ctx)

    @typecheck
    async def glob(self, pattern: str) -> list[str]:
        """Returns a list of files and directories that matche the given pattern.

        Parameters
        ----------
        pattern:
            Pattern to match (e.g., "*.md").

        Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("pattern", pattern),
        ]
        _ctx = self._select("glob", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def id(self) -> DirectoryID:
        """A unique identifier for this Directory.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        DirectoryID
            The `DirectoryID` scalar type represents an identifier for an
            object of type Directory.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(DirectoryID)

    @typecheck
    def pipeline(
        self,
        name: str,
        *,
        description: str | None = "",
        labels: Sequence[PipelineLabel] | None = [],
    ) -> "Directory":
        """Creates a named sub-pipeline.

        Parameters
        ----------
        name:
            Name of the sub-pipeline.
        description:
            Description of the sub-pipeline.
        labels:
            Labels to apply to the sub-pipeline.
        """
        _args = [
            Arg("name", name),
            Arg("description", description, ""),
            Arg("labels", labels, []),
        ]
        _ctx = self._select("pipeline", _args)
        return Directory(_ctx)

    @typecheck
    async def sync(self) -> "Directory":
        """Force evaluation in the engine.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sync", _args)
        _id = await _ctx.execute(DirectoryID)
        _ctx = Client.from_context(_ctx)._select(
            "loadDirectoryFromID", [Arg("id", _id)]
        )
        return Directory(_ctx)

    def __await__(self):
        return self.sync().__await__()

    @typecheck
    def with_directory(
        self,
        path: str,
        directory: "Directory",
        *,
        exclude: Sequence[str] | None = [],
        include: Sequence[str] | None = [],
    ) -> "Directory":
        """Retrieves this directory plus a directory written at the given path.

        Parameters
        ----------
        path:
            Location of the written directory (e.g., "/src/").
        directory:
            Identifier of the directory to copy.
        exclude:
            Exclude artifacts that match the given pattern (e.g.,
            ["node_modules/", ".git*"]).
        include:
            Include only artifacts that match the given pattern (e.g.,
            ["app/", "package.*"]).
        """
        _args = [
            Arg("path", path),
            Arg("directory", directory),
            Arg("exclude", exclude, []),
            Arg("include", include, []),
        ]
        _ctx = self._select("withDirectory", _args)
        return Directory(_ctx)

    @typecheck
    def with_file(
        self,
        path: str,
        source: "File",
        *,
        permissions: int | None = None,
    ) -> "Directory":
        """Retrieves this directory plus the contents of the given file copied to
        the given path.

        Parameters
        ----------
        path:
            Location of the copied file (e.g., "/file.txt").
        source:
            Identifier of the file to copy.
        permissions:
            Permission given to the copied file (e.g., 0600).
        """
        _args = [
            Arg("path", path),
            Arg("source", source),
            Arg("permissions", permissions, None),
        ]
        _ctx = self._select("withFile", _args)
        return Directory(_ctx)

    @typecheck
    def with_new_directory(
        self,
        path: str,
        *,
        permissions: int | None = 420,
    ) -> "Directory":
        """Retrieves this directory plus a new directory created at the given
        path.

        Parameters
        ----------
        path:
            Location of the directory created (e.g., "/logs").
        permissions:
            Permission granted to the created directory (e.g., 0777).
        """
        _args = [
            Arg("path", path),
            Arg("permissions", permissions, 420),
        ]
        _ctx = self._select("withNewDirectory", _args)
        return Directory(_ctx)

    @typecheck
    def with_new_file(
        self,
        path: str,
        contents: str,
        *,
        permissions: int | None = 420,
    ) -> "Directory":
        """Retrieves this directory plus a new file written at the given path.

        Parameters
        ----------
        path:
            Location of the written file (e.g., "/file.txt").
        contents:
            Content of the written file (e.g., "Hello world!").
        permissions:
            Permission given to the copied file (e.g., 0600).
        """
        _args = [
            Arg("path", path),
            Arg("contents", contents),
            Arg("permissions", permissions, 420),
        ]
        _ctx = self._select("withNewFile", _args)
        return Directory(_ctx)

    @typecheck
    def with_timestamps(self, timestamp: int) -> "Directory":
        """Retrieves this directory with all file/dir timestamps set to the given
        time.

        Parameters
        ----------
        timestamp:
            Timestamp to set dir/files in.
            Formatted in seconds following Unix epoch (e.g., 1672531199).
        """
        _args = [
            Arg("timestamp", timestamp),
        ]
        _ctx = self._select("withTimestamps", _args)
        return Directory(_ctx)

    @typecheck
    def without_directory(self, path: str) -> "Directory":
        """Retrieves this directory with the directory at the given path removed.

        Parameters
        ----------
        path:
            Location of the directory to remove (e.g., ".github/").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withoutDirectory", _args)
        return Directory(_ctx)

    @typecheck
    def without_file(self, path: str) -> "Directory":
        """Retrieves this directory with the file at the given path removed.

        Parameters
        ----------
        path:
            Location of the file to remove (e.g., "/file.txt").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("withoutFile", _args)
        return Directory(_ctx)

    def with_(self, cb: Callable[["Directory"], "Directory"]) -> "Directory":
        """Call the provided callable with current Directory.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class EnvVariable(Type):
    """An environment variable name and value."""

    __slots__ = (
        "_name",
        "_value",
    )

    _name: str | None
    _value: str | None

    @typecheck
    async def id(self) -> EnvVariableID:
        """A unique identifier for this EnvVariable.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        EnvVariableID
            The `EnvVariableID` scalar type represents an identifier for an
            object of type EnvVariable.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(EnvVariableID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def value(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_value"):
            return self._value
        _args: list[Arg] = []
        _ctx = self._select("value", _args)
        return await _ctx.execute(str)


class FieldTypeDef(Type):
    """A definition of a field on a custom object defined in a Module.  A
    field on an object has a static value, as opposed to a function on an
    object whose value is computed by invoking code (and can accept
    arguments)."""

    __slots__ = (
        "_description",
        "_name",
    )

    _description: str | None
    _name: str | None

    @typecheck
    async def description(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_description"):
            return self._description
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str)

    @typecheck
    async def id(self) -> FieldTypeDefID:
        """A unique identifier for this FieldTypeDef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FieldTypeDefID
            The `FieldTypeDefID` scalar type represents an identifier for an
            object of type FieldTypeDef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FieldTypeDefID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    def type_def(self) -> "TypeDef":
        _args: list[Arg] = []
        _ctx = self._select("typeDef", _args)
        return TypeDef(_ctx)


class File(Type):
    """A file."""

    @typecheck
    async def contents(self) -> str:
        """Retrieves the contents of the file.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("contents", _args)
        return await _ctx.execute(str)

    @typecheck
    async def export(
        self,
        path: str,
        *,
        allow_parent_dir_path: bool | None = False,
    ) -> bool:
        """Writes the file to a file path on the host.

        Parameters
        ----------
        path:
            Location of the written directory (e.g., "output.txt").
        allow_parent_dir_path:
            If allowParentDirPath is true, the path argument can be a
            directory path, in which case the file will be created in that
            directory.

        Returns
        -------
        bool
            The `Boolean` scalar type represents `true` or `false`.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("path", path),
            Arg("allowParentDirPath", allow_parent_dir_path, False),
        ]
        _ctx = self._select("export", _args)
        return await _ctx.execute(bool)

    @typecheck
    async def id(self) -> FileID:
        """A unique identifier for this File.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FileID
            The `FileID` scalar type represents an identifier for an object of
            type File.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FileID)

    @typecheck
    async def name(self) -> str:
        """Retrieves the name of the file.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def size(self) -> int:
        """Retrieves the size of the file, in bytes.

        Returns
        -------
        int
            The `Int` scalar type represents non-fractional signed whole
            numeric values. Int can represent values between -(2^31) and 2^31
            - 1.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("size", _args)
        return await _ctx.execute(int)

    @typecheck
    async def sync(self) -> "File":
        """Force evaluation in the engine.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sync", _args)
        _id = await _ctx.execute(FileID)
        _ctx = Client.from_context(_ctx)._select("loadFileFromID", [Arg("id", _id)])
        return File(_ctx)

    def __await__(self):
        return self.sync().__await__()

    @typecheck
    def with_timestamps(self, timestamp: int) -> "File":
        """Retrieves this file with its created/modified timestamps set to the
        given time.

        Parameters
        ----------
        timestamp:
            Timestamp to set dir/files in.
            Formatted in seconds following Unix epoch (e.g., 1672531199).
        """
        _args = [
            Arg("timestamp", timestamp),
        ]
        _ctx = self._select("withTimestamps", _args)
        return File(_ctx)

    def with_(self, cb: Callable[["File"], "File"]) -> "File":
        """Call the provided callable with current File.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class Function(Type):
    """Function represents a resolver provided by a Module.  A function
    always evaluates against a parent object and is given a set of named
    arguments."""

    __slots__ = (
        "_description",
        "_name",
    )

    _description: str | None
    _name: str | None

    @typecheck
    async def args(self) -> list["FunctionArg"]:
        _args: list[Arg] = []
        _ctx = self._select("args", _args)
        _ctx = FunctionArg(_ctx)._select_multiple(
            _default_value="defaultValue",
            _description="description",
            _name="name",
        )
        return await _ctx.execute(list[FunctionArg])

    @typecheck
    async def description(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_description"):
            return self._description
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str)

    @typecheck
    async def id(self) -> FunctionID:
        """A unique identifier for this Function.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FunctionID
            The `FunctionID` scalar type represents an identifier for an
            object of type Function.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FunctionID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    def return_type(self) -> "TypeDef":
        _args: list[Arg] = []
        _ctx = self._select("returnType", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_arg(
        self,
        name: str,
        type_def: "TypeDef",
        *,
        description: str | None = "",
        default_value: JSON | None = None,
    ) -> "Function":
        """Returns the function with the provided argument

        Parameters
        ----------
        name:
            The name of the argument
        type_def:
            The type of the argument
        description:
            A doc string for the argument, if any
        default_value:
            A default value to use for this argument if not explicitly set by
            the caller, if any
        """
        _args = [
            Arg("name", name),
            Arg("typeDef", type_def),
            Arg("description", description, ""),
            Arg("defaultValue", default_value, None),
        ]
        _ctx = self._select("withArg", _args)
        return Function(_ctx)

    @typecheck
    def with_description(self, description: str) -> "Function":
        """Returns the function with the given doc string.

        Parameters
        ----------
        description:
            The doc string to set.
        """
        _args = [
            Arg("description", description),
        ]
        _ctx = self._select("withDescription", _args)
        return Function(_ctx)

    def with_(self, cb: Callable[["Function"], "Function"]) -> "Function":
        """Call the provided callable with current Function.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class FunctionArg(Type):
    """An argument accepted by a function.  This is a specification for an
    argument at function definition time, not an argument passed at
    function call time."""

    __slots__ = (
        "_default_value",
        "_description",
        "_name",
    )

    _default_value: JSON | None
    _description: str | None
    _name: str | None

    @typecheck
    async def default_value(self) -> JSON:
        """Returns
        -------
        JSON
            An arbitrary JSON-encoded value.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_default_value"):
            return self._default_value
        _args: list[Arg] = []
        _ctx = self._select("defaultValue", _args)
        return await _ctx.execute(JSON)

    @typecheck
    async def description(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_description"):
            return self._description
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str)

    @typecheck
    async def id(self) -> FunctionArgID:
        """A unique identifier for this FunctionArg.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FunctionArgID
            The `FunctionArgID` scalar type represents an identifier for an
            object of type FunctionArg.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FunctionArgID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    def type_def(self) -> "TypeDef":
        _args: list[Arg] = []
        _ctx = self._select("typeDef", _args)
        return TypeDef(_ctx)


class FunctionCall(Type):
    """An active function call."""

    @typecheck
    async def id(self) -> FunctionCallID:
        """A unique identifier for this FunctionCall.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FunctionCallID
            The `FunctionCallID` scalar type represents an identifier for an
            object of type FunctionCall.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FunctionCallID)

    @typecheck
    async def input_args(self) -> list["FunctionCallArgValue"]:
        _args: list[Arg] = []
        _ctx = self._select("inputArgs", _args)
        _ctx = FunctionCallArgValue(_ctx)._select_multiple(
            _name="name",
            _value="value",
        )
        return await _ctx.execute(list[FunctionCallArgValue])

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def parent(self) -> JSON:
        """Returns
        -------
        JSON
            An arbitrary JSON-encoded value.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("parent", _args)
        return await _ctx.execute(JSON)

    @typecheck
    async def parent_name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("parentName", _args)
        return await _ctx.execute(str)

    @typecheck
    async def return_value(self, value: JSON) -> Void | None:
        """Set the return value of the function call to the provided value.

        Parameters
        ----------
        value:
            JSON serialization of the return value.

        Returns
        -------
        Void | None
            The absence of a value.  A Null Void is used as a placeholder for
            resolvers that do not return anything.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("value", value),
        ]
        _ctx = self._select("returnValue", _args)
        return await _ctx.execute(Void | None)


class FunctionCallArgValue(Type):
    """A value passed as a named argument to a function call."""

    __slots__ = (
        "_name",
        "_value",
    )

    _name: str | None
    _value: JSON | None

    @typecheck
    async def id(self) -> FunctionCallArgValueID:
        """A unique identifier for this FunctionCallArgValue.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        FunctionCallArgValueID
            The `FunctionCallArgValueID` scalar type represents an identifier
            for an object of type FunctionCallArgValue.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(FunctionCallArgValueID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def value(self) -> JSON:
        """Returns
        -------
        JSON
            An arbitrary JSON-encoded value.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_value"):
            return self._value
        _args: list[Arg] = []
        _ctx = self._select("value", _args)
        return await _ctx.execute(JSON)


class GeneratedCode(Type):
    """The result of running an SDK's codegen."""

    @typecheck
    def code(self) -> Directory:
        _args: list[Arg] = []
        _ctx = self._select("code", _args)
        return Directory(_ctx)

    @typecheck
    async def id(self) -> GeneratedCodeID:
        """A unique identifier for this GeneratedCode.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        GeneratedCodeID
            The `GeneratedCodeID` scalar type represents an identifier for an
            object of type GeneratedCode.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(GeneratedCodeID)

    @typecheck
    async def vcs_generated_paths(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("vcsGeneratedPaths", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def vcs_ignored_paths(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("vcsIgnoredPaths", _args)
        return await _ctx.execute(list[str])

    @typecheck
    def with_vcs_generated_paths(self, paths: Sequence[str]) -> "GeneratedCode":
        """Set the list of paths to mark generated in version control."""
        _args = [
            Arg("paths", paths),
        ]
        _ctx = self._select("withVCSGeneratedPaths", _args)
        return GeneratedCode(_ctx)

    @typecheck
    def with_vcs_ignored_paths(self, paths: Sequence[str]) -> "GeneratedCode":
        """Set the list of paths to ignore in version control."""
        _args = [
            Arg("paths", paths),
        ]
        _ctx = self._select("withVCSIgnoredPaths", _args)
        return GeneratedCode(_ctx)

    def with_(
        self, cb: Callable[["GeneratedCode"], "GeneratedCode"]
    ) -> "GeneratedCode":
        """Call the provided callable with current GeneratedCode.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class GitRef(Type):
    """A git ref (tag, branch, or commit)."""

    @typecheck
    async def commit(self) -> str:
        """The resolved commit id at this ref.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("commit", _args)
        return await _ctx.execute(str)

    @typecheck
    async def id(self) -> GitRefID:
        """A unique identifier for this GitRef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        GitRefID
            The `GitRefID` scalar type represents an identifier for an object
            of type GitRef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(GitRefID)

    @typecheck
    def tree(
        self,
        *,
        ssh_known_hosts: str | None = None,
        ssh_auth_socket: "Socket | None" = None,
    ) -> Directory:
        """The filesystem tree at this ref.

        Parameters
        ----------
        ssh_known_hosts:
            DEPRECATED: This option should be passed to `git` instead.
        ssh_auth_socket:
            DEPRECATED: This option should be passed to `git` instead.
        """
        _args = [
            Arg("sshKnownHosts", ssh_known_hosts, None),
            Arg("sshAuthSocket", ssh_auth_socket, None),
        ]
        _ctx = self._select("tree", _args)
        return Directory(_ctx)


class GitRepository(Type):
    """A git repository."""

    @typecheck
    def branch(self, name: str) -> GitRef:
        """Returns details of a branch.

        Parameters
        ----------
        name:
            Branch's name (e.g., "main").
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("branch", _args)
        return GitRef(_ctx)

    @typecheck
    def commit(self, id: str) -> GitRef:
        """Returns details of a commit.

        Parameters
        ----------
        id:
            Identifier of the commit (e.g.,
            "b6315d8f2810962c601af73f86831f6866ea798b").
        """
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("commit", _args)
        return GitRef(_ctx)

    @typecheck
    async def id(self) -> GitRepositoryID:
        """A unique identifier for this GitRepository.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        GitRepositoryID
            The `GitRepositoryID` scalar type represents an identifier for an
            object of type GitRepository.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(GitRepositoryID)

    @typecheck
    def tag(self, name: str) -> GitRef:
        """Returns details of a tag.

        Parameters
        ----------
        name:
            Tag's name (e.g., "v0.3.9").
        """
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("tag", _args)
        return GitRef(_ctx)


class Host(Type):
    """Information about the host environment."""

    @typecheck
    def directory(
        self,
        path: str,
        *,
        exclude: Sequence[str] | None = [],
        include: Sequence[str] | None = [],
    ) -> Directory:
        """Accesses a directory on the host.

        Parameters
        ----------
        path:
            Location of the directory to access (e.g., ".").
        exclude:
            Exclude artifacts that match the given pattern (e.g.,
            ["node_modules/", ".git*"]).
        include:
            Include only artifacts that match the given pattern (e.g.,
            ["app/", "package.*"]).
        """
        _args = [
            Arg("path", path),
            Arg("exclude", exclude, []),
            Arg("include", include, []),
        ]
        _ctx = self._select("directory", _args)
        return Directory(_ctx)

    @typecheck
    def file(self, path: str) -> File:
        """Accesses a file on the host.

        Parameters
        ----------
        path:
            Location of the file to retrieve (e.g., "README.md").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("file", _args)
        return File(_ctx)

    @typecheck
    async def id(self) -> HostID:
        """A unique identifier for this Host.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        HostID
            The `HostID` scalar type represents an identifier for an object of
            type Host.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(HostID)

    @typecheck
    def service(
        self,
        ports: Sequence[PortForward],
        *,
        host: str | None = "localhost",
    ) -> "Service":
        """Creates a service that forwards traffic to a specified address via the
        host.

        Parameters
        ----------
        ports:
            Ports to expose via the service, forwarding through the host
            network.
            If a port's frontend is unspecified or 0, it defaults to the same
            as the backend port.
            An empty set of ports is not valid; an error will be returned.
        host:
            Upstream host to forward traffic to.
        """
        _args = [
            Arg("ports", ports),
            Arg("host", host, "localhost"),
        ]
        _ctx = self._select("service", _args)
        return Service(_ctx)

    @typecheck
    def set_secret_file(self, name: str, path: str) -> "Secret":
        """Sets a secret given a user-defined name and the file path on the host,
        and returns the secret.

        The file is limited to a size of 512000 bytes.

        Parameters
        ----------
        name:
            The user defined name for this secret.
        path:
            Location of the file to set as a secret.
        """
        _args = [
            Arg("name", name),
            Arg("path", path),
        ]
        _ctx = self._select("setSecretFile", _args)
        return Secret(_ctx)

    @typecheck
    def tunnel(
        self,
        service: "Service",
        *,
        ports: Sequence[PortForward] | None = [],
        native: bool | None = False,
    ) -> "Service":
        """Creates a tunnel that forwards traffic from the host to a service.

        Parameters
        ----------
        service:
            Service to send traffic from the tunnel.
        ports:
            Configure explicit port forwarding rules for the tunnel.
            If a port's frontend is unspecified or 0, a random port will be
            chosen by the host.
            If no ports are given, all of the service's ports are forwarded.
            If native is true, each port maps to the same port on the host. If
            native is false, each port maps to a random port chosen by the
            host.
            If ports are given and native is true, the ports are additive.
        native:
            Map each service port to the same port on the host, as if the
            service were running natively.
            Note: enabling may result in port conflicts.
        """
        _args = [
            Arg("service", service),
            Arg("ports", ports, []),
            Arg("native", native, False),
        ]
        _ctx = self._select("tunnel", _args)
        return Service(_ctx)

    @typecheck
    def unix_socket(self, path: str) -> "Socket":
        """Accesses a Unix socket on the host.

        Parameters
        ----------
        path:
            Location of the Unix socket (e.g., "/var/run/docker.sock").
        """
        _args = [
            Arg("path", path),
        ]
        _ctx = self._select("unixSocket", _args)
        return Socket(_ctx)


class InterfaceTypeDef(Type):
    """A definition of a custom interface defined in a Module."""

    @typecheck
    async def description(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str)

    @typecheck
    async def functions(self) -> list[Function]:
        _args: list[Arg] = []
        _ctx = self._select("functions", _args)
        _ctx = Function(_ctx)._select_multiple(
            _description="description",
            _name="name",
        )
        return await _ctx.execute(list[Function])

    @typecheck
    async def id(self) -> InterfaceTypeDefID:
        """A unique identifier for this InterfaceTypeDef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        InterfaceTypeDefID
            The `InterfaceTypeDefID` scalar type represents an identifier for
            an object of type InterfaceTypeDef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(InterfaceTypeDefID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def source_module_name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sourceModuleName", _args)
        return await _ctx.execute(str)


class Label(Type):
    """A simple key value object that represents a label."""

    __slots__ = (
        "_name",
        "_value",
    )

    _name: str | None
    _value: str | None

    @typecheck
    async def id(self) -> LabelID:
        """A unique identifier for this Label.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        LabelID
            The `LabelID` scalar type represents an identifier for an object
            of type Label.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(LabelID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def value(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_value"):
            return self._value
        _args: list[Arg] = []
        _ctx = self._select("value", _args)
        return await _ctx.execute(str)


class ListTypeDef(Type):
    """A definition of a list type in a Module."""

    @typecheck
    def element_type_def(self) -> "TypeDef":
        _args: list[Arg] = []
        _ctx = self._select("elementTypeDef", _args)
        return TypeDef(_ctx)

    @typecheck
    async def id(self) -> ListTypeDefID:
        """A unique identifier for this ListTypeDef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ListTypeDefID
            The `ListTypeDefID` scalar type represents an identifier for an
            object of type ListTypeDef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ListTypeDefID)


class Module(Type):
    """A Dagger module."""

    __slots__ = (
        "_dependency_config",
        "_description",
        "_name",
        "_sdk",
        "_serve",
        "_source_directory_subpath",
    )

    _dependency_config: str | None
    _description: str | None
    _name: str | None
    _sdk: str | None
    _serve: Void | None
    _source_directory_subpath: str | None

    @typecheck
    async def dependencies(self) -> list["Module"]:
        _args: list[Arg] = []
        _ctx = self._select("dependencies", _args)
        _ctx = Module(_ctx)._select_multiple(
            _dependency_config="dependencyConfig",
            _description="description",
            _name="name",
            _sdk="sdk",
            _serve="serve",
            _source_directory_subpath="sourceDirectorySubpath",
        )
        return await _ctx.execute(list[Module])

    @typecheck
    async def dependency_config(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_dependency_config"):
            return self._dependency_config
        _args: list[Arg] = []
        _ctx = self._select("dependencyConfig", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def description(self) -> str | None:
        """Returns
        -------
        str | None
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_description"):
            return self._description
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str | None)

    @typecheck
    def generated_code(self) -> GeneratedCode:
        _args: list[Arg] = []
        _ctx = self._select("generatedCode", _args)
        return GeneratedCode(_ctx)

    @typecheck
    async def id(self) -> ModuleID:
        """A unique identifier for this Module.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ModuleID
            The `ModuleID` scalar type represents an identifier for an object
            of type Module.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ModuleID)

    @typecheck
    def initialize(self) -> "Module":
        """Retrieves the module with the objects loaded via its SDK."""
        _args: list[Arg] = []
        _ctx = self._select("initialize", _args)
        return Module(_ctx)

    @typecheck
    async def interfaces(self) -> list["TypeDef"]:
        _args: list[Arg] = []
        _ctx = self._select("interfaces", _args)
        _ctx = TypeDef(_ctx)._select_multiple(
            _kind="kind",
            _optional="optional",
        )
        return await _ctx.execute(list[TypeDef])

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_name"):
            return self._name
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def objects(self) -> list["TypeDef"]:
        _args: list[Arg] = []
        _ctx = self._select("objects", _args)
        _ctx = TypeDef(_ctx)._select_multiple(
            _kind="kind",
            _optional="optional",
        )
        return await _ctx.execute(list[TypeDef])

    @typecheck
    async def sdk(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_sdk"):
            return self._sdk
        _args: list[Arg] = []
        _ctx = self._select("sdk", _args)
        return await _ctx.execute(str)

    @typecheck
    async def serve(self) -> Void | None:
        """Serve a module's API in the current session.

        Note: this can only be called once per session. In the future, it
        could return a stream or service to remove the side effect.

        Returns
        -------
        Void | None
            The absence of a value.  A Null Void is used as a placeholder for
            resolvers that do not return anything.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_serve"):
            return self._serve
        _args: list[Arg] = []
        _ctx = self._select("serve", _args)
        return await _ctx.execute(Void | None)

    @typecheck
    def source_directory(self) -> Directory:
        _args: list[Arg] = []
        _ctx = self._select("sourceDirectory", _args)
        return Directory(_ctx)

    @typecheck
    async def source_directory_subpath(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_source_directory_subpath"):
            return self._source_directory_subpath
        _args: list[Arg] = []
        _ctx = self._select("sourceDirectorySubpath", _args)
        return await _ctx.execute(str)

    @typecheck
    def with_interface(self, iface: "TypeDef") -> "Module":
        """This module plus the given Interface type and associated functions"""
        _args = [
            Arg("iface", iface),
        ]
        _ctx = self._select("withInterface", _args)
        return Module(_ctx)

    @typecheck
    def with_object(self, object: "TypeDef") -> "Module":
        """This module plus the given Object type and associated functions."""
        _args = [
            Arg("object", object),
        ]
        _ctx = self._select("withObject", _args)
        return Module(_ctx)

    @typecheck
    def with_source(
        self,
        directory: Directory,
        *,
        subpath: str | None = "",
    ) -> "Module":
        """Retrieves the module with basic configuration loaded, ready for
        initialization.

        Parameters
        ----------
        directory:
            The directory containing the module's source code.
        subpath:
            An optional subpath of the directory which contains the module's
            source code.
            This is needed when the module code is in a subdirectory but
            requires parent directories to be loaded in order to execute. For
            example, the module source code may need a go.mod, project.toml,
            package.json, etc. file from a parent directory.
            If not set, the module source code is loaded from the root of the
            directory.
        """
        _args = [
            Arg("directory", directory),
            Arg("subpath", subpath, ""),
        ]
        _ctx = self._select("withSource", _args)
        return Module(_ctx)

    def with_(self, cb: Callable[["Module"], "Module"]) -> "Module":
        """Call the provided callable with current Module.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class ModuleConfig(Type):
    """Static configuration for a module (e.g. parsed contents of
    dagger.json)"""

    @typecheck
    async def dependencies(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("dependencies", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def exclude(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("exclude", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def id(self) -> ModuleConfigID:
        """A unique identifier for this ModuleConfig.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ModuleConfigID
            The `ModuleConfigID` scalar type represents an identifier for an
            object of type ModuleConfig.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ModuleConfigID)

    @typecheck
    async def include(self) -> list[str]:
        """Returns
        -------
        list[str]
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("include", _args)
        return await _ctx.execute(list[str])

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def root(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("root", _args)
        return await _ctx.execute(str)

    @typecheck
    async def sdk(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sdk", _args)
        return await _ctx.execute(str)


class ObjectTypeDef(Type):
    """A definition of a custom object defined in a Module."""

    @typecheck
    def constructor(self) -> Function:
        _args: list[Arg] = []
        _ctx = self._select("constructor", _args)
        return Function(_ctx)

    @typecheck
    async def description(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str)

    @typecheck
    async def fields(self) -> list[FieldTypeDef]:
        _args: list[Arg] = []
        _ctx = self._select("fields", _args)
        _ctx = FieldTypeDef(_ctx)._select_multiple(
            _description="description",
            _name="name",
        )
        return await _ctx.execute(list[FieldTypeDef])

    @typecheck
    async def functions(self) -> list[Function]:
        _args: list[Arg] = []
        _ctx = self._select("functions", _args)
        _ctx = Function(_ctx)._select_multiple(
            _description="description",
            _name="name",
        )
        return await _ctx.execute(list[Function])

    @typecheck
    async def id(self) -> ObjectTypeDefID:
        """A unique identifier for this ObjectTypeDef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ObjectTypeDefID
            The `ObjectTypeDefID` scalar type represents an identifier for an
            object of type ObjectTypeDef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ObjectTypeDefID)

    @typecheck
    async def name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("name", _args)
        return await _ctx.execute(str)

    @typecheck
    async def source_module_name(self) -> str:
        """Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("sourceModuleName", _args)
        return await _ctx.execute(str)


class Port(Type):
    """A port exposed by a container."""

    __slots__ = (
        "_description",
        "_port",
        "_protocol",
    )

    _description: str | None
    _port: int | None
    _protocol: NetworkProtocol | None

    @typecheck
    async def description(self) -> str | None:
        """Returns
        -------
        str | None
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_description"):
            return self._description
        _args: list[Arg] = []
        _ctx = self._select("description", _args)
        return await _ctx.execute(str | None)

    @typecheck
    async def id(self) -> PortID:
        """A unique identifier for this Port.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        PortID
            The `PortID` scalar type represents an identifier for an object of
            type Port.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(PortID)

    @typecheck
    async def port(self) -> int:
        """Returns
        -------
        int
            The `Int` scalar type represents non-fractional signed whole
            numeric values. Int can represent values between -(2^31) and 2^31
            - 1.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_port"):
            return self._port
        _args: list[Arg] = []
        _ctx = self._select("port", _args)
        return await _ctx.execute(int)

    @typecheck
    async def protocol(self) -> NetworkProtocol:
        """Returns
        -------
        NetworkProtocol
            Transport layer network protocol associated to a port.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_protocol"):
            return self._protocol
        _args: list[Arg] = []
        _ctx = self._select("protocol", _args)
        return await _ctx.execute(NetworkProtocol)


class Client(Root):
    """The root of the DAG."""

    @typecheck
    def blob(
        self,
        digest: str,
        size: int,
        media_type: str,
        uncompressed: str,
    ) -> Directory:
        """Retrieves a content-addressed blob.

        Parameters
        ----------
        digest:
            Digest of the blob
        size:
            Size of the blob
        media_type:
            Media type of the blob
        uncompressed:
            Digest of the uncompressed blob
        """
        _args = [
            Arg("digest", digest),
            Arg("size", size),
            Arg("mediaType", media_type),
            Arg("uncompressed", uncompressed),
        ]
        _ctx = self._select("blob", _args)
        return Directory(_ctx)

    @typecheck
    def cache_volume(self, key: str) -> CacheVolume:
        """Constructs a cache volume for a given cache key.

        Parameters
        ----------
        key:
            A string identifier to target this cache volume (e.g., "modules-
            cache").
        """
        _args = [
            Arg("key", key),
        ]
        _ctx = self._select("cacheVolume", _args)
        return CacheVolume(_ctx)

    @typecheck
    async def check_version_compatibility(self, version: str) -> bool:
        """Checks if the current Dagger Engine is compatible with an SDK's
        required version.

        Parameters
        ----------
        version:
            Version required by the SDK.

        Returns
        -------
        bool
            The `Boolean` scalar type represents `true` or `false`.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("version", version),
        ]
        _ctx = self._select("checkVersionCompatibility", _args)
        return await _ctx.execute(bool)

    @typecheck
    def container(
        self,
        *,
        id: ContainerID | None = None,
        platform: Platform | None = None,
    ) -> Container:
        """Creates a scratch container.

        Optional platform argument initializes new containers to execute and
        publish as that platform. Platform defaults to that of the builder's
        host.

        Parameters
        ----------
        id:
            DEPRECATED: Use `loadContainerFromID` instead.
        platform:
            Platform to initialize the container with.
        """
        _args = [
            Arg("id", id, None),
            Arg("platform", platform, None),
        ]
        _ctx = self._select("container", _args)
        return Container(_ctx)

    @typecheck
    def current_function_call(self) -> FunctionCall:
        """The FunctionCall context that the SDK caller is currently executing
        in.

        If the caller is not currently executing in a function, this will
        return an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("currentFunctionCall", _args)
        return FunctionCall(_ctx)

    @typecheck
    def current_module(self) -> Module:
        """The module currently being served in the session, if any."""
        _args: list[Arg] = []
        _ctx = self._select("currentModule", _args)
        return Module(_ctx)

    @typecheck
    async def current_type_defs(self) -> list["TypeDef"]:
        """The TypeDef representations of the objects currently being served in
        the session.
        """
        _args: list[Arg] = []
        _ctx = self._select("currentTypeDefs", _args)
        _ctx = TypeDef(_ctx)._select_multiple(
            _kind="kind",
            _optional="optional",
        )
        return await _ctx.execute(list[TypeDef])

    @typecheck
    async def default_platform(self) -> Platform:
        """The default platform of the engine.

        Returns
        -------
        Platform
            The platform config OS and architecture in a Container.  The
            format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7",
            "windows/amd64", "linux/arm64").

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("defaultPlatform", _args)
        return await _ctx.execute(Platform)

    @typecheck
    def directory(self, *, id: DirectoryID | None = None) -> Directory:
        """Creates an empty directory.

        Parameters
        ----------
        id:
            DEPRECATED: Use `loadDirectoryFromID` isntead.
        """
        _args = [
            Arg("id", id, None),
        ]
        _ctx = self._select("directory", _args)
        return Directory(_ctx)

    @typecheck
    def file(self, id: FileID) -> File:
        """.. deprecated::
        Use :py:meth:`load_file_from_id` instead.
        """
        warnings.warn(
            'Method "file" is deprecated: Use "load_file_from_id" instead.',
            DeprecationWarning,
            stacklevel=4,
        )
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("file", _args)
        return File(_ctx)

    @typecheck
    def function(self, name: str, return_type: "TypeDef") -> Function:
        """Creates a function.

        Parameters
        ----------
        name:
            Name of the function, in its original format from the
            implementation language.
        return_type:
            Return type of the function.
        """
        _args = [
            Arg("name", name),
            Arg("returnType", return_type),
        ]
        _ctx = self._select("function", _args)
        return Function(_ctx)

    @typecheck
    def generated_code(self, code: Directory) -> GeneratedCode:
        """Create a code generation result, given a directory containing the
        generated code.
        """
        _args = [
            Arg("code", code),
        ]
        _ctx = self._select("generatedCode", _args)
        return GeneratedCode(_ctx)

    @typecheck
    def git(
        self,
        url: str,
        *,
        keep_git_dir: bool | None = False,
        experimental_service_host: "Service | None" = None,
        ssh_known_hosts: str | None = "",
        ssh_auth_socket: "Socket | None" = None,
    ) -> GitRepository:
        """Queries a Git repository.

        Parameters
        ----------
        url:
            URL of the git repository.
            Can be formatted as `https://{host}/{owner}/{repo}`,
            `git@{host}:{owner}/{repo}`.
            Suffix ".git" is optional.
        keep_git_dir:
            Set to true to keep .git directory.
        experimental_service_host:
            A service which must be started before the repo is fetched.
        ssh_known_hosts:
            Set SSH known hosts
        ssh_auth_socket:
            Set SSH auth socket
        """
        _args = [
            Arg("url", url),
            Arg("keepGitDir", keep_git_dir, False),
            Arg("experimentalServiceHost", experimental_service_host, None),
            Arg("sshKnownHosts", ssh_known_hosts, ""),
            Arg("sshAuthSocket", ssh_auth_socket, None),
        ]
        _ctx = self._select("git", _args)
        return GitRepository(_ctx)

    @typecheck
    def host(self) -> Host:
        """Queries the host environment."""
        _args: list[Arg] = []
        _ctx = self._select("host", _args)
        return Host(_ctx)

    @typecheck
    def http(
        self,
        url: str,
        *,
        experimental_service_host: "Service | None" = None,
    ) -> File:
        """Returns a file containing an http remote url content.

        Parameters
        ----------
        url:
            HTTP url to get the content from (e.g., "https://docs.dagger.io").
        experimental_service_host:
            A service which must be started before the URL is fetched.
        """
        _args = [
            Arg("url", url),
            Arg("experimentalServiceHost", experimental_service_host, None),
        ]
        _ctx = self._select("http", _args)
        return File(_ctx)

    @typecheck
    def load_cache_volume_from_id(self, id: CacheVolumeID) -> CacheVolume:
        """Load a CacheVolume from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadCacheVolumeFromID", _args)
        return CacheVolume(_ctx)

    @typecheck
    def load_container_from_id(self, id: ContainerID) -> Container:
        """Load a Container from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadContainerFromID", _args)
        return Container(_ctx)

    @typecheck
    def load_directory_from_id(self, id: DirectoryID) -> Directory:
        """Load a Directory from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadDirectoryFromID", _args)
        return Directory(_ctx)

    @typecheck
    def load_env_variable_from_id(self, id: EnvVariableID) -> EnvVariable:
        """Load a EnvVariable from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEnvVariableFromID", _args)
        return EnvVariable(_ctx)

    @typecheck
    def load_field_type_def_from_id(self, id: FieldTypeDefID) -> FieldTypeDef:
        """Load a FieldTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFieldTypeDefFromID", _args)
        return FieldTypeDef(_ctx)

    @typecheck
    def load_file_from_id(self, id: FileID) -> File:
        """Load a File from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFileFromID", _args)
        return File(_ctx)

    @typecheck
    def load_function_arg_from_id(self, id: FunctionArgID) -> FunctionArg:
        """Load a FunctionArg from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionArgFromID", _args)
        return FunctionArg(_ctx)

    @typecheck
    def load_function_call_arg_value_from_id(
        self, id: FunctionCallArgValueID
    ) -> FunctionCallArgValue:
        """Load a FunctionCallArgValue from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionCallArgValueFromID", _args)
        return FunctionCallArgValue(_ctx)

    @typecheck
    def load_function_call_from_id(self, id: FunctionCallID) -> FunctionCall:
        """Load a FunctionCall from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionCallFromID", _args)
        return FunctionCall(_ctx)

    @typecheck
    def load_function_from_id(self, id: FunctionID) -> Function:
        """Load a Function from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionFromID", _args)
        return Function(_ctx)

    @typecheck
    def load_generated_code_from_id(self, id: GeneratedCodeID) -> GeneratedCode:
        """Load a GeneratedCode from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGeneratedCodeFromID", _args)
        return GeneratedCode(_ctx)

    @typecheck
    def load_git_ref_from_id(self, id: GitRefID) -> GitRef:
        """Load a GitRef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGitRefFromID", _args)
        return GitRef(_ctx)

    @typecheck
    def load_git_repository_from_id(self, id: GitRepositoryID) -> GitRepository:
        """Load a GitRepository from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGitRepositoryFromID", _args)
        return GitRepository(_ctx)

    @typecheck
    def load_host_from_id(self, id: HostID) -> Host:
        """Load a Host from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadHostFromID", _args)
        return Host(_ctx)

    @typecheck
    def load_interface_type_def_from_id(
        self, id: InterfaceTypeDefID
    ) -> InterfaceTypeDef:
        """Load a InterfaceTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadInterfaceTypeDefFromID", _args)
        return InterfaceTypeDef(_ctx)

    @typecheck
    def load_label_from_id(self, id: LabelID) -> Label:
        """Load a Label from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadLabelFromID", _args)
        return Label(_ctx)

    @typecheck
    def load_list_type_def_from_id(self, id: ListTypeDefID) -> ListTypeDef:
        """Load a ListTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadListTypeDefFromID", _args)
        return ListTypeDef(_ctx)

    @typecheck
    def load_module_config_from_id(self, id: ModuleConfigID) -> ModuleConfig:
        """Load a ModuleConfig from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleConfigFromID", _args)
        return ModuleConfig(_ctx)

    @typecheck
    def load_module_from_id(self, id: ModuleID) -> Module:
        """Load a Module from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleFromID", _args)
        return Module(_ctx)

    @typecheck
    def load_object_type_def_from_id(self, id: ObjectTypeDefID) -> ObjectTypeDef:
        """Load a ObjectTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadObjectTypeDefFromID", _args)
        return ObjectTypeDef(_ctx)

    @typecheck
    def load_port_from_id(self, id: PortID) -> Port:
        """Load a Port from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadPortFromID", _args)
        return Port(_ctx)

    @typecheck
    def load_secret_from_id(self, id: SecretID) -> "Secret":
        """Load a Secret from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadSecretFromID", _args)
        return Secret(_ctx)

    @typecheck
    def load_service_from_id(self, id: ServiceID) -> "Service":
        """Load a Service from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadServiceFromID", _args)
        return Service(_ctx)

    @typecheck
    def load_socket_from_id(self, id: SocketID) -> "Socket":
        """Load a Socket from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadSocketFromID", _args)
        return Socket(_ctx)

    @typecheck
    def load_type_def_from_id(self, id: TypeDefID) -> "TypeDef":
        """Load a TypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadTypeDefFromID", _args)
        return TypeDef(_ctx)

    @typecheck
    def module(self) -> Module:
        """Create a new module."""
        _args: list[Arg] = []
        _ctx = self._select("module", _args)
        return Module(_ctx)

    @typecheck
    def module_config(
        self,
        source_directory: Directory,
        *,
        subpath: str | None = "",
    ) -> ModuleConfig:
        """Load the static configuration for a module from the given source
        directory and optional subpath.
        """
        _args = [
            Arg("sourceDirectory", source_directory),
            Arg("subpath", subpath, ""),
        ]
        _ctx = self._select("moduleConfig", _args)
        return ModuleConfig(_ctx)

    @typecheck
    def pipeline(
        self,
        name: str,
        *,
        description: str | None = "",
        labels: Sequence[PipelineLabel] | None = None,
    ) -> "Client":
        """Creates a named sub-pipeline.

        Parameters
        ----------
        name:
            Name of the sub-pipeline.
        description:
            Description of the sub-pipeline.
        labels:
            Labels to apply to the sub-pipeline.
        """
        _args = [
            Arg("name", name),
            Arg("description", description, ""),
            Arg("labels", labels, None),
        ]
        _ctx = self._select("pipeline", _args)
        return Client(_ctx)

    @typecheck
    def secret(self, name: str) -> "Secret":
        """Reference a secret by name."""
        _args = [
            Arg("name", name),
        ]
        _ctx = self._select("secret", _args)
        return Secret(_ctx)

    @typecheck
    def set_secret(self, name: str, plaintext: str) -> "Secret":
        """Sets a secret given a user defined name to its plaintext and returns
        the secret.

        The plaintext value is limited to a size of 128000 bytes.

        Parameters
        ----------
        name:
            The user defined name for this secret
        plaintext:
            The plaintext of the secret
        """
        _args = [
            Arg("name", name),
            Arg("plaintext", plaintext),
        ]
        _ctx = self._select("setSecret", _args)
        return Secret(_ctx)

    @typecheck
    def socket(self, id: SocketID) -> "Socket":
        """Loads a socket by its ID.

        .. deprecated::
            Use :py:meth:`load_socket_from_id` instead.
        """
        warnings.warn(
            'Method "socket" is deprecated: Use "load_socket_from_id" instead.',
            DeprecationWarning,
            stacklevel=4,
        )
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("socket", _args)
        return Socket(_ctx)

    @typecheck
    def type_def(self) -> "TypeDef":
        """Create a new TypeDef."""
        _args: list[Arg] = []
        _ctx = self._select("typeDef", _args)
        return TypeDef(_ctx)

    def with_(self, cb: Callable[["Client"], "Client"]) -> "Client":
        """Call the provided callable with current Client.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


class Secret(Type):
    """A reference to a secret value, which can be handled more safely
    than the value itself."""

    @typecheck
    async def id(self) -> SecretID:
        """A unique identifier for this Secret.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        SecretID
            The `SecretID` scalar type represents an identifier for an object
            of type Secret.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(SecretID)

    @typecheck
    async def plaintext(self) -> str:
        """The value of this secret.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("plaintext", _args)
        return await _ctx.execute(str)


class Service(Type):
    """A content-addressed service providing TCP connectivity."""

    @typecheck
    async def endpoint(
        self,
        *,
        port: int | None = None,
        scheme: str | None = "",
    ) -> str:
        """Retrieves an endpoint that clients can use to reach this container.

        If no port is specified, the first exposed port is used. If none exist
        an error is returned.

        If a scheme is specified, a URL is returned. Otherwise, a host:port
        pair is returned.

        Parameters
        ----------
        port:
            The exposed port number for the endpoint
        scheme:
            Return a URL with the given scheme, eg. http for http://

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args = [
            Arg("port", port, None),
            Arg("scheme", scheme, ""),
        ]
        _ctx = self._select("endpoint", _args)
        return await _ctx.execute(str)

    @typecheck
    async def hostname(self) -> str:
        """Retrieves a hostname which can be used by clients to reach this
        container.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("hostname", _args)
        return await _ctx.execute(str)

    @typecheck
    async def id(self) -> ServiceID:
        """A unique identifier for this Service.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        ServiceID
            The `ServiceID` scalar type represents an identifier for an object
            of type Service.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(ServiceID)

    @typecheck
    async def ports(self) -> list[Port]:
        """Retrieves the list of ports provided by the service."""
        _args: list[Arg] = []
        _ctx = self._select("ports", _args)
        _ctx = Port(_ctx)._select_multiple(
            _description="description",
            _port="port",
            _protocol="protocol",
        )
        return await _ctx.execute(list[Port])

    @typecheck
    async def start(self) -> "Service":
        """Start the service and wait for its health checks to succeed.

        Services bound to a Container do not need to be manually started.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("start", _args)
        _id = await _ctx.execute(ServiceID)
        _ctx = Client.from_context(_ctx)._select("loadServiceFromID", [Arg("id", _id)])
        return Service(_ctx)

    @typecheck
    async def stop(self) -> "Service":
        """Stop the service.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("stop", _args)
        _id = await _ctx.execute(ServiceID)
        _ctx = Client.from_context(_ctx)._select("loadServiceFromID", [Arg("id", _id)])
        return Service(_ctx)


class Socket(Type):
    """A Unix or TCP/IP socket that can be mounted into a container."""

    @typecheck
    async def id(self) -> SocketID:
        """A unique identifier for this Socket.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        SocketID
            The `SocketID` scalar type represents an identifier for an object
            of type Socket.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(SocketID)


class TypeDef(Type):
    """A definition of a parameter or return type in a Module."""

    __slots__ = (
        "_kind",
        "_optional",
    )

    _kind: TypeDefKind | None
    _optional: bool | None

    @typecheck
    def as_interface(self) -> InterfaceTypeDef:
        _args: list[Arg] = []
        _ctx = self._select("asInterface", _args)
        return InterfaceTypeDef(_ctx)

    @typecheck
    def as_list(self) -> ListTypeDef:
        _args: list[Arg] = []
        _ctx = self._select("asList", _args)
        return ListTypeDef(_ctx)

    @typecheck
    def as_object(self) -> ObjectTypeDef:
        _args: list[Arg] = []
        _ctx = self._select("asObject", _args)
        return ObjectTypeDef(_ctx)

    @typecheck
    async def id(self) -> TypeDefID:
        """A unique identifier for this TypeDef.

        Note
        ----
        This is lazily evaluated, no operation is actually run.

        Returns
        -------
        TypeDefID
            The `TypeDefID` scalar type represents an identifier for an object
            of type TypeDef.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("id", _args)
        return await _ctx.execute(TypeDefID)

    @typecheck
    async def kind(self) -> TypeDefKind:
        """Returns
        -------
        TypeDefKind
            Distinguishes the different kinds of TypeDefs.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_kind"):
            return self._kind
        _args: list[Arg] = []
        _ctx = self._select("kind", _args)
        return await _ctx.execute(TypeDefKind)

    @typecheck
    async def optional(self) -> bool:
        """Returns
        -------
        bool
            The `Boolean` scalar type represents `true` or `false`.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        if hasattr(self, "_optional"):
            return self._optional
        _args: list[Arg] = []
        _ctx = self._select("optional", _args)
        return await _ctx.execute(bool)

    @typecheck
    def with_constructor(self, function: Function) -> "TypeDef":
        """Adds a function for constructing a new instance of an Object TypeDef,
        failing if the type is not an object.
        """
        _args = [
            Arg("function", function),
        ]
        _ctx = self._select("withConstructor", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_field(
        self,
        name: str,
        type_def: "TypeDef",
        *,
        description: str | None = "",
    ) -> "TypeDef":
        """Adds a static field for an Object TypeDef, failing if the type is not
        an object.

        Parameters
        ----------
        name:
            The name of the field in the object
        type_def:
            The type of the field
        description:
            A doc string for the field, if any
        """
        _args = [
            Arg("name", name),
            Arg("typeDef", type_def),
            Arg("description", description, ""),
        ]
        _ctx = self._select("withField", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_function(self, function: Function) -> "TypeDef":
        """Adds a function for an Object or Interface TypeDef, failing if the
        type is not one of those kinds.
        """
        _args = [
            Arg("function", function),
        ]
        _ctx = self._select("withFunction", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_interface(
        self,
        name: str,
        *,
        description: str | None = "",
    ) -> "TypeDef":
        """Returns a TypeDef of kind Interface with the provided name."""
        _args = [
            Arg("name", name),
            Arg("description", description, ""),
        ]
        _ctx = self._select("withInterface", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_kind(self, kind: TypeDefKind) -> "TypeDef":
        """Sets the kind of the type."""
        _args = [
            Arg("kind", kind),
        ]
        _ctx = self._select("withKind", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_list_of(self, element_type: "TypeDef") -> "TypeDef":
        """Returns a TypeDef of kind List with the provided type for its
        elements.
        """
        _args = [
            Arg("elementType", element_type),
        ]
        _ctx = self._select("withListOf", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_object(
        self,
        name: str,
        *,
        description: str | None = "",
    ) -> "TypeDef":
        """Returns a TypeDef of kind Object with the provided name.

        Note that an object's fields and functions may be omitted if the
        intent is only to refer to an object. This is how functions are able
        to return their own object, or any other circular reference.
        """
        _args = [
            Arg("name", name),
            Arg("description", description, ""),
        ]
        _ctx = self._select("withObject", _args)
        return TypeDef(_ctx)

    @typecheck
    def with_optional(self, optional: bool) -> "TypeDef":
        """Sets whether this type can be set to null."""
        _args = [
            Arg("optional", optional),
        ]
        _ctx = self._select("withOptional", _args)
        return TypeDef(_ctx)

    def with_(self, cb: Callable[["TypeDef"], "TypeDef"]) -> "TypeDef":
        """Call the provided callable with current TypeDef.

        This is useful for reusability and readability by not breaking the calling chain.
        """
        return cb(self)


dag = Client()
"""The global client instance."""

__all__ = [
    "BuildArg",
    "CacheSharingMode",
    "CacheVolume",
    "CacheVolumeID",
    "Client",
    "Container",
    "ContainerID",
    "Directory",
    "DirectoryID",
    "EnvVariable",
    "EnvVariableID",
    "FieldTypeDef",
    "FieldTypeDefID",
    "File",
    "FileID",
    "Function",
    "FunctionArg",
    "FunctionArgID",
    "FunctionCall",
    "FunctionCallArgValue",
    "FunctionCallArgValueID",
    "FunctionCallID",
    "FunctionID",
    "GeneratedCode",
    "GeneratedCodeID",
    "GitRef",
    "GitRefID",
    "GitRepository",
    "GitRepositoryID",
    "Host",
    "HostID",
    "ImageLayerCompression",
    "ImageMediaTypes",
    "InterfaceTypeDef",
    "InterfaceTypeDefID",
    "JSON",
    "Label",
    "LabelID",
    "ListTypeDef",
    "ListTypeDefID",
    "Module",
    "ModuleConfig",
    "ModuleConfigID",
    "ModuleID",
    "NetworkProtocol",
    "ObjectTypeDef",
    "ObjectTypeDefID",
    "PipelineLabel",
    "Platform",
    "Port",
    "PortForward",
    "PortID",
    "Secret",
    "SecretID",
    "Service",
    "ServiceID",
    "Socket",
    "SocketID",
    "TypeDef",
    "TypeDefID",
    "TypeDefKind",
    "Void",
    "dag",
]
