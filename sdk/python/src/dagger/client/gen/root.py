# Code generated by dagger. DO NOT EDIT.

from dataclasses import dataclass

from dagger.client._core import Arg
from dagger.client._guards import typecheck
from dagger.client.base import Root
from dagger.client.gen.core import (
    JSON,
    BuildArg,
    CacheSharingMode,
    CacheVolume,
    CacheVolumeID,
    Container,
    ContainerID,
    CurrentModule,
    CurrentModuleID,
    Directory,
    DirectoryID,
    Engine,
    EngineCache,
    EngineCacheEntry,
    EngineCacheEntryID,
    EngineCacheEntrySet,
    EngineCacheEntrySetID,
    EngineCacheID,
    EngineID,
    EnumTypeDef,
    EnumTypeDefID,
    EnumValueTypeDef,
    EnumValueTypeDefID,
    EnvVariable,
    EnvVariableID,
    FieldTypeDef,
    FieldTypeDefID,
    File,
    FileID,
    Function,
    FunctionArg,
    FunctionArgID,
    FunctionCall,
    FunctionCallArgValue,
    FunctionCallArgValueID,
    FunctionCallID,
    FunctionID,
    GeneratedCode,
    GeneratedCodeID,
    GitModuleSource,
    GitModuleSourceID,
    GitRef,
    GitRefID,
    GitRepository,
    GitRepositoryID,
    Host,
    HostID,
    ImageLayerCompression,
    ImageMediaTypes,
    InputTypeDef,
    InputTypeDefID,
    InterfaceTypeDef,
    InterfaceTypeDefID,
    Label,
    LabelID,
    ListTypeDef,
    ListTypeDefID,
    LocalModuleSource,
    LocalModuleSourceID,
    Module,
    ModuleDependency,
    ModuleDependencyID,
    ModuleID,
    ModuleSource,
    ModuleSourceID,
    ModuleSourceKind,
    ModuleSourceView,
    ModuleSourceViewID,
    NetworkProtocol,
    ObjectTypeDef,
    ObjectTypeDefID,
    PipelineLabel,
    Platform,
    Port,
    PortForward,
    PortID,
    ReturnType,
    ScalarTypeDef,
    ScalarTypeDefID,
    Secret,
    SecretID,
    Service,
    ServiceID,
    Socket,
    SocketID,
    SourceMap,
    SourceMapID,
    Terminal,
    TerminalID,
    TypeDef,
    TypeDefID,
    TypeDefKind,
    Void,
)


@typecheck
class Client(Root):
    """The root of the DAG."""

    def blob(
        self,
        digest: str,
        size: int,
        media_type: str,
        uncompressed: str,
    ) -> Directory:
        """Retrieves a content-addressed blob.

        Parameters
        ----------
        digest:
            Digest of the blob
        size:
            Size of the blob
        media_type:
            Media type of the blob
        uncompressed:
            Digest of the uncompressed blob
        """
        _args = [
            Arg("digest", digest),
            Arg("size", size),
            Arg("mediaType", media_type),
            Arg("uncompressed", uncompressed),
        ]
        _ctx = self._select("blob", _args)
        return Directory(_ctx)

    def builtin_container(self, digest: str) -> Container:
        """Retrieves a container builtin to the engine.

        Parameters
        ----------
        digest:
            Digest of the image manifest
        """
        _args = [
            Arg("digest", digest),
        ]
        _ctx = self._select("builtinContainer", _args)
        return Container(_ctx)

    def cache_volume(self, key: str) -> CacheVolume:
        """Constructs a cache volume for a given cache key.

        Parameters
        ----------
        key:
            A string identifier to target this cache volume (e.g., "modules-
            cache").
        """
        _args = [
            Arg("key", key),
        ]
        _ctx = self._select("cacheVolume", _args)
        return CacheVolume(_ctx)

    def container(
        self,
        *,
        platform: Platform | None = None,
    ) -> Container:
        """Creates a scratch container.

        Optional platform argument initializes new containers to execute and
        publish as that platform. Platform defaults to that of the builder's
        host.

        Parameters
        ----------
        platform:
            Platform to initialize the container with.
        """
        _args = [
            Arg("platform", platform, None),
        ]
        _ctx = self._select("container", _args)
        return Container(_ctx)

    def current_function_call(self) -> FunctionCall:
        """The FunctionCall context that the SDK caller is currently executing
        in.

        If the caller is not currently executing in a function, this will
        return an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("currentFunctionCall", _args)
        return FunctionCall(_ctx)

    def current_module(self) -> CurrentModule:
        """The module currently being served in the session, if any."""
        _args: list[Arg] = []
        _ctx = self._select("currentModule", _args)
        return CurrentModule(_ctx)

    async def current_type_defs(self) -> list["TypeDef"]:
        """The TypeDef representations of the objects currently being served in
        the session.
        """
        _args: list[Arg] = []
        _ctx = self._select("currentTypeDefs", _args)
        _ctx = TypeDef(_ctx)._select("id", [])

        @dataclass
        class Response:
            id: TypeDefID

        _ids = await _ctx.execute(list[Response])
        return [
            TypeDef(
                Client.from_context(_ctx)._select(
                    "loadTypeDefFromID",
                    [Arg("id", v.id)],
                )
            )
            for v in _ids
        ]

    async def default_platform(self) -> Platform:
        """The default platform of the engine.

        Returns
        -------
        Platform
            The platform config OS and architecture in a Container.  The
            format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7",
            "windows/amd64", "linux/arm64").

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("defaultPlatform", _args)
        return await _ctx.execute(Platform)

    def directory(self) -> Directory:
        """Creates an empty directory."""
        _args: list[Arg] = []
        _ctx = self._select("directory", _args)
        return Directory(_ctx)

    def engine(self) -> Engine:
        """The Dagger engine container configuration and state"""
        _args: list[Arg] = []
        _ctx = self._select("engine", _args)
        return Engine(_ctx)

    def function(self, name: str, return_type: "TypeDef") -> Function:
        """Creates a function.

        Parameters
        ----------
        name:
            Name of the function, in its original format from the
            implementation language.
        return_type:
            Return type of the function.
        """
        _args = [
            Arg("name", name),
            Arg("returnType", return_type),
        ]
        _ctx = self._select("function", _args)
        return Function(_ctx)

    def generated_code(self, code: Directory) -> GeneratedCode:
        """Create a code generation result, given a directory containing the
        generated code.
        """
        _args = [
            Arg("code", code),
        ]
        _ctx = self._select("generatedCode", _args)
        return GeneratedCode(_ctx)

    def git(
        self,
        url: str,
        *,
        keep_git_dir: bool | None = True,
        experimental_service_host: "Service | None" = None,
        ssh_known_hosts: str | None = "",
        ssh_auth_socket: "Socket | None" = None,
    ) -> GitRepository:
        """Queries a Git repository.

        Parameters
        ----------
        url:
            URL of the git repository.
            Can be formatted as `https://{host}/{owner}/{repo}`,
            `git@{host}:{owner}/{repo}`.
            Suffix ".git" is optional.
        keep_git_dir:
            DEPRECATED: Set to true to keep .git directory.
        experimental_service_host:
            A service which must be started before the repo is fetched.
        ssh_known_hosts:
            Set SSH known hosts
        ssh_auth_socket:
            Set SSH auth socket
        """
        _args = [
            Arg("url", url),
            Arg("keepGitDir", keep_git_dir, True),
            Arg("experimentalServiceHost", experimental_service_host, None),
            Arg("sshKnownHosts", ssh_known_hosts, ""),
            Arg("sshAuthSocket", ssh_auth_socket, None),
        ]
        _ctx = self._select("git", _args)
        return GitRepository(_ctx)

    def host(self) -> Host:
        """Queries the host environment."""
        _args: list[Arg] = []
        _ctx = self._select("host", _args)
        return Host(_ctx)

    def http(
        self,
        url: str,
        *,
        experimental_service_host: "Service | None" = None,
    ) -> File:
        """Returns a file containing an http remote url content.

        Parameters
        ----------
        url:
            HTTP url to get the content from (e.g., "https://docs.dagger.io").
        experimental_service_host:
            A service which must be started before the URL is fetched.
        """
        _args = [
            Arg("url", url),
            Arg("experimentalServiceHost", experimental_service_host, None),
        ]
        _ctx = self._select("http", _args)
        return File(_ctx)

    def load_cache_volume_from_id(self, id: CacheVolumeID) -> CacheVolume:
        """Load a CacheVolume from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadCacheVolumeFromID", _args)
        return CacheVolume(_ctx)

    def load_container_from_id(self, id: ContainerID) -> Container:
        """Load a Container from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadContainerFromID", _args)
        return Container(_ctx)

    def load_current_module_from_id(self, id: CurrentModuleID) -> CurrentModule:
        """Load a CurrentModule from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadCurrentModuleFromID", _args)
        return CurrentModule(_ctx)

    def load_directory_from_id(self, id: DirectoryID) -> Directory:
        """Load a Directory from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadDirectoryFromID", _args)
        return Directory(_ctx)

    def load_engine_cache_entry_from_id(
        self, id: EngineCacheEntryID
    ) -> EngineCacheEntry:
        """Load a EngineCacheEntry from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEngineCacheEntryFromID", _args)
        return EngineCacheEntry(_ctx)

    def load_engine_cache_entry_set_from_id(
        self, id: EngineCacheEntrySetID
    ) -> EngineCacheEntrySet:
        """Load a EngineCacheEntrySet from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEngineCacheEntrySetFromID", _args)
        return EngineCacheEntrySet(_ctx)

    def load_engine_cache_from_id(self, id: EngineCacheID) -> EngineCache:
        """Load a EngineCache from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEngineCacheFromID", _args)
        return EngineCache(_ctx)

    def load_engine_from_id(self, id: EngineID) -> Engine:
        """Load a Engine from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEngineFromID", _args)
        return Engine(_ctx)

    def load_enum_type_def_from_id(self, id: EnumTypeDefID) -> EnumTypeDef:
        """Load a EnumTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEnumTypeDefFromID", _args)
        return EnumTypeDef(_ctx)

    def load_enum_value_type_def_from_id(
        self, id: EnumValueTypeDefID
    ) -> EnumValueTypeDef:
        """Load a EnumValueTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEnumValueTypeDefFromID", _args)
        return EnumValueTypeDef(_ctx)

    def load_env_variable_from_id(self, id: EnvVariableID) -> EnvVariable:
        """Load a EnvVariable from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadEnvVariableFromID", _args)
        return EnvVariable(_ctx)

    def load_field_type_def_from_id(self, id: FieldTypeDefID) -> FieldTypeDef:
        """Load a FieldTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFieldTypeDefFromID", _args)
        return FieldTypeDef(_ctx)

    def load_file_from_id(self, id: FileID) -> File:
        """Load a File from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFileFromID", _args)
        return File(_ctx)

    def load_function_arg_from_id(self, id: FunctionArgID) -> FunctionArg:
        """Load a FunctionArg from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionArgFromID", _args)
        return FunctionArg(_ctx)

    def load_function_call_arg_value_from_id(
        self, id: FunctionCallArgValueID
    ) -> FunctionCallArgValue:
        """Load a FunctionCallArgValue from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionCallArgValueFromID", _args)
        return FunctionCallArgValue(_ctx)

    def load_function_call_from_id(self, id: FunctionCallID) -> FunctionCall:
        """Load a FunctionCall from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionCallFromID", _args)
        return FunctionCall(_ctx)

    def load_function_from_id(self, id: FunctionID) -> Function:
        """Load a Function from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadFunctionFromID", _args)
        return Function(_ctx)

    def load_generated_code_from_id(self, id: GeneratedCodeID) -> GeneratedCode:
        """Load a GeneratedCode from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGeneratedCodeFromID", _args)
        return GeneratedCode(_ctx)

    def load_git_module_source_from_id(self, id: GitModuleSourceID) -> GitModuleSource:
        """Load a GitModuleSource from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGitModuleSourceFromID", _args)
        return GitModuleSource(_ctx)

    def load_git_ref_from_id(self, id: GitRefID) -> GitRef:
        """Load a GitRef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGitRefFromID", _args)
        return GitRef(_ctx)

    def load_git_repository_from_id(self, id: GitRepositoryID) -> GitRepository:
        """Load a GitRepository from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadGitRepositoryFromID", _args)
        return GitRepository(_ctx)

    def load_host_from_id(self, id: HostID) -> Host:
        """Load a Host from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadHostFromID", _args)
        return Host(_ctx)

    def load_input_type_def_from_id(self, id: InputTypeDefID) -> InputTypeDef:
        """Load a InputTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadInputTypeDefFromID", _args)
        return InputTypeDef(_ctx)

    def load_interface_type_def_from_id(
        self, id: InterfaceTypeDefID
    ) -> InterfaceTypeDef:
        """Load a InterfaceTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadInterfaceTypeDefFromID", _args)
        return InterfaceTypeDef(_ctx)

    def load_label_from_id(self, id: LabelID) -> Label:
        """Load a Label from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadLabelFromID", _args)
        return Label(_ctx)

    def load_list_type_def_from_id(self, id: ListTypeDefID) -> ListTypeDef:
        """Load a ListTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadListTypeDefFromID", _args)
        return ListTypeDef(_ctx)

    def load_local_module_source_from_id(
        self, id: LocalModuleSourceID
    ) -> LocalModuleSource:
        """Load a LocalModuleSource from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadLocalModuleSourceFromID", _args)
        return LocalModuleSource(_ctx)

    def load_module_dependency_from_id(
        self, id: ModuleDependencyID
    ) -> ModuleDependency:
        """Load a ModuleDependency from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleDependencyFromID", _args)
        return ModuleDependency(_ctx)

    def load_module_from_id(self, id: ModuleID) -> Module:
        """Load a Module from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleFromID", _args)
        return Module(_ctx)

    def load_module_source_from_id(self, id: ModuleSourceID) -> ModuleSource:
        """Load a ModuleSource from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleSourceFromID", _args)
        return ModuleSource(_ctx)

    def load_module_source_view_from_id(
        self, id: ModuleSourceViewID
    ) -> ModuleSourceView:
        """Load a ModuleSourceView from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadModuleSourceViewFromID", _args)
        return ModuleSourceView(_ctx)

    def load_object_type_def_from_id(self, id: ObjectTypeDefID) -> ObjectTypeDef:
        """Load a ObjectTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadObjectTypeDefFromID", _args)
        return ObjectTypeDef(_ctx)

    def load_port_from_id(self, id: PortID) -> Port:
        """Load a Port from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadPortFromID", _args)
        return Port(_ctx)

    def load_scalar_type_def_from_id(self, id: ScalarTypeDefID) -> "ScalarTypeDef":
        """Load a ScalarTypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadScalarTypeDefFromID", _args)
        return ScalarTypeDef(_ctx)

    def load_secret_from_id(self, id: SecretID) -> "Secret":
        """Load a Secret from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadSecretFromID", _args)
        return Secret(_ctx)

    def load_service_from_id(self, id: ServiceID) -> "Service":
        """Load a Service from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadServiceFromID", _args)
        return Service(_ctx)

    def load_socket_from_id(self, id: SocketID) -> "Socket":
        """Load a Socket from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadSocketFromID", _args)
        return Socket(_ctx)

    def load_source_map_from_id(self, id: SourceMapID) -> "SourceMap":
        """Load a SourceMap from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadSourceMapFromID", _args)
        return SourceMap(_ctx)

    def load_terminal_from_id(self, id: TerminalID) -> "Terminal":
        """Load a Terminal from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadTerminalFromID", _args)
        return Terminal(_ctx)

    def load_type_def_from_id(self, id: TypeDefID) -> "TypeDef":
        """Load a TypeDef from its ID."""
        _args = [
            Arg("id", id),
        ]
        _ctx = self._select("loadTypeDefFromID", _args)
        return TypeDef(_ctx)

    def module(self) -> Module:
        """Create a new module."""
        _args: list[Arg] = []
        _ctx = self._select("module", _args)
        return Module(_ctx)

    def module_dependency(
        self,
        source: ModuleSource,
        *,
        name: str | None = "",
    ) -> ModuleDependency:
        """Create a new module dependency configuration from a module source and
        name

        Parameters
        ----------
        source:
            The source of the dependency
        name:
            If set, the name to use for the dependency. Otherwise, once
            installed to a parent module, the name of the dependency module
            will be used by default.
        """
        _args = [
            Arg("source", source),
            Arg("name", name, ""),
        ]
        _ctx = self._select("moduleDependency", _args)
        return ModuleDependency(_ctx)

    def module_source(
        self,
        ref_string: str,
        *,
        ref_pin: str | None = "",
        stable: bool | None = False,
        rel_host_path: str | None = "",
    ) -> ModuleSource:
        """Create a new module source instance from a source ref string.

        Parameters
        ----------
        ref_string:
            The string ref representation of the module source
        ref_pin:
            The pinned version of the module source
        stable:
            If true, enforce that the source is a stable version for source
            kinds that support versioning.
        rel_host_path:
            The relative path to the module root from the host directory
        """
        _args = [
            Arg("refString", ref_string),
            Arg("refPin", ref_pin, ""),
            Arg("stable", stable, False),
            Arg("relHostPath", rel_host_path, ""),
        ]
        _ctx = self._select("moduleSource", _args)
        return ModuleSource(_ctx)

    def secret(
        self,
        name: str,
        *,
        accessor: str | None = None,
    ) -> "Secret":
        """Reference a secret by name."""
        _args = [
            Arg("name", name),
            Arg("accessor", accessor, None),
        ]
        _ctx = self._select("secret", _args)
        return Secret(_ctx)

    def set_secret(self, name: str, plaintext: str) -> "Secret":
        """Sets a secret given a user defined name to its plaintext and returns
        the secret.

        The plaintext value is limited to a size of 128000 bytes.

        Parameters
        ----------
        name:
            The user defined name for this secret
        plaintext:
            The plaintext of the secret
        """
        _args = [
            Arg("name", name),
            Arg("plaintext", plaintext),
        ]
        _ctx = self._select("setSecret", _args)
        return Secret(_ctx)

    def source_map(
        self,
        filename: str,
        line: int,
        column: int,
    ) -> "SourceMap":
        """Creates source map metadata.

        Parameters
        ----------
        filename:
            The filename from the module source.
        line:
            The line number within the filename.
        column:
            The column number within the line.
        """
        _args = [
            Arg("filename", filename),
            Arg("line", line),
            Arg("column", column),
        ]
        _ctx = self._select("sourceMap", _args)
        return SourceMap(_ctx)

    def type_def(self) -> "TypeDef":
        """Create a new TypeDef."""
        _args: list[Arg] = []
        _ctx = self._select("typeDef", _args)
        return TypeDef(_ctx)

    async def version(self) -> str:
        """Get the current Dagger Engine version.

        Returns
        -------
        str
            The `String` scalar type represents textual data, represented as
            UTF-8 character sequences. The String type is most often used by
            GraphQL to represent free-form human-readable text.

        Raises
        ------
        ExecuteTimeoutError
            If the time to execute the query exceeds the configured timeout.
        QueryError
            If the API returns an error.
        """
        _args: list[Arg] = []
        _ctx = self._select("version", _args)
        return await _ctx.execute(str)


dag = Client()
"""The global client instance."""

__all__ = [
    "BuildArg",
    "CacheSharingMode",
    "CacheVolume",
    "CacheVolumeID",
    "Client",
    "Container",
    "ContainerID",
    "CurrentModule",
    "CurrentModuleID",
    "Directory",
    "DirectoryID",
    "Engine",
    "EngineCache",
    "EngineCacheEntry",
    "EngineCacheEntryID",
    "EngineCacheEntrySet",
    "EngineCacheEntrySetID",
    "EngineCacheID",
    "EngineID",
    "EnumTypeDef",
    "EnumTypeDefID",
    "EnumValueTypeDef",
    "EnumValueTypeDefID",
    "EnvVariable",
    "EnvVariableID",
    "FieldTypeDef",
    "FieldTypeDefID",
    "File",
    "FileID",
    "Function",
    "FunctionArg",
    "FunctionArgID",
    "FunctionCall",
    "FunctionCallArgValue",
    "FunctionCallArgValueID",
    "FunctionCallID",
    "FunctionID",
    "GeneratedCode",
    "GeneratedCodeID",
    "GitModuleSource",
    "GitModuleSourceID",
    "GitRef",
    "GitRefID",
    "GitRepository",
    "GitRepositoryID",
    "Host",
    "HostID",
    "ImageLayerCompression",
    "ImageMediaTypes",
    "InputTypeDef",
    "InputTypeDefID",
    "InterfaceTypeDef",
    "InterfaceTypeDefID",
    "JSON",
    "Label",
    "LabelID",
    "ListTypeDef",
    "ListTypeDefID",
    "LocalModuleSource",
    "LocalModuleSourceID",
    "Module",
    "ModuleDependency",
    "ModuleDependencyID",
    "ModuleID",
    "ModuleSource",
    "ModuleSourceID",
    "ModuleSourceKind",
    "ModuleSourceView",
    "ModuleSourceViewID",
    "NetworkProtocol",
    "ObjectTypeDef",
    "ObjectTypeDefID",
    "PipelineLabel",
    "Platform",
    "Port",
    "PortForward",
    "PortID",
    "ReturnType",
    "ScalarTypeDef",
    "ScalarTypeDefID",
    "Secret",
    "SecretID",
    "Service",
    "ServiceID",
    "Socket",
    "SocketID",
    "SourceMap",
    "SourceMapID",
    "Terminal",
    "TerminalID",
    "TypeDef",
    "TypeDefID",
    "TypeDefKind",
    "Void",
    "dag",
]
