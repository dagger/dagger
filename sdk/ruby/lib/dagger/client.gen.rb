# frozen_string_literal: true

# This file was auto-generated by `client-gen`.
# Do not make direct changes to the file.

# typed: strict

require 'sorbet-runtime'

require 'net/http'
require 'base64'
require 'json'

# Dagger module
module Dagger
  extend T::Sig

  # Sharing mode of the cache volume.
  class CacheSharingMode < T::Enum
    enums do
      # Shares the cache volume amongst many build pipelines, but will serialize the writes
      Locked = new

      # Keeps a cache volume for a single build pipeline
      Private = new

      # Shares the cache volume amongst many build pipelines
      Shared = new
    end
  end

  # Compression algorithm to use for image layers.
  class ImageLayerCompression < T::Enum
    enums do
      Estargz = new
      Gzip = new
      Uncompressed = new
      Zstd = new
    end
  end

  # Mediatypes to use in published or exported image metadata.
  class ImageMediaTypes < T::Enum
    enums do
      Dockermediatypes = new
      Ocimediatypes = new
    end
  end

  # The kind of module source.
  class ModuleSourceKind < T::Enum
    enums do
      GitSource = new
      LocalSource = new
    end
  end

  # Transport layer network protocol associated to a port.
  class NetworkProtocol < T::Enum
    enums do
      Tcp = new
      Udp = new
    end
  end

  # Expected return type of an execution
  class ReturnType < T::Enum
    enums do
      # Any execution (exit codes 0-127)
      Any = new

      # A failed execution (exit codes 1-127)
      Failure = new

      # A successful execution (exit code 0)
      Success = new
    end
  end

  # Distinguishes the different kinds of TypeDefs.
  class TypeDefKind < T::Enum
    enums do
      # A boolean value.
      BooleanKind = new

      # A GraphQL enum type and its values
      #
      # Always paired with an EnumTypeDef.
      EnumKind = new

      # A graphql input type, used only when representing the core API via TypeDefs.
      InputKind = new

      # An integer value.
      IntegerKind = new

      # A named type of functions that can be matched+implemented by other objects+interfaces.
      #
      # Always paired with an InterfaceTypeDef.
      InterfaceKind = new

      # A list of values all having the same type.
      #
      # Always paired with a ListTypeDef.
      ListKind = new

      # A named type defined in the GraphQL schema, with fields and functions.
      #
      # Always paired with an ObjectTypeDef.
      ObjectKind = new

      # A scalar value of any basic kind.
      ScalarKind = new

      # A string value.
      StringKind = new

      # A special kind used to signify that no value is returned.
      #
      # This is used for functions that have no return value. The outer TypeDef specifying this Kind is always Optional, as the Void is never actually represented.
      VoidKind = new
    end
  end

  # The `CacheVolumeID` scalar type represents an identifier for an object of type CacheVolume.
  CacheVolumeID = T.type_alias { String }

  # The `ContainerID` scalar type represents an identifier for an object of type Container.
  ContainerID = T.type_alias { String }

  # The `CurrentModuleID` scalar type represents an identifier for an object of type CurrentModule.
  CurrentModuleID = T.type_alias { String }

  # The `DirectoryID` scalar type represents an identifier for an object of type Directory.
  DirectoryID = T.type_alias { String }

  # The `EngineCacheEntryID` scalar type represents an identifier for an object of type EngineCacheEntry.
  EngineCacheEntryID = T.type_alias { String }

  # The `EngineCacheEntrySetID` scalar type represents an identifier for an object of type EngineCacheEntrySet.
  EngineCacheEntrySetID = T.type_alias { String }

  # The `EngineCacheID` scalar type represents an identifier for an object of type EngineCache.
  EngineCacheID = T.type_alias { String }

  # The `EngineID` scalar type represents an identifier for an object of type Engine.
  EngineID = T.type_alias { String }

  # The `EnumTypeDefID` scalar type represents an identifier for an object of type EnumTypeDef.
  EnumTypeDefID = T.type_alias { String }

  # The `EnumValueTypeDefID` scalar type represents an identifier for an object of type EnumValueTypeDef.
  EnumValueTypeDefID = T.type_alias { String }

  # The `EnvVariableID` scalar type represents an identifier for an object of type EnvVariable.
  EnvVariableID = T.type_alias { String }

  # The `ErrorID` scalar type represents an identifier for an object of type Error.
  ErrorID = T.type_alias { String }

  # The `FieldTypeDefID` scalar type represents an identifier for an object of type FieldTypeDef.
  FieldTypeDefID = T.type_alias { String }

  # The `FileID` scalar type represents an identifier for an object of type File.
  FileID = T.type_alias { String }

  # The `FunctionArgID` scalar type represents an identifier for an object of type FunctionArg.
  FunctionArgID = T.type_alias { String }

  # The `FunctionCallArgValueID` scalar type represents an identifier for an object of type FunctionCallArgValue.
  FunctionCallArgValueID = T.type_alias { String }

  # The `FunctionCallID` scalar type represents an identifier for an object of type FunctionCall.
  FunctionCallID = T.type_alias { String }

  # The `FunctionID` scalar type represents an identifier for an object of type Function.
  FunctionID = T.type_alias { String }

  # The `GeneratedCodeID` scalar type represents an identifier for an object of type GeneratedCode.
  GeneratedCodeID = T.type_alias { String }

  # The `GitModuleSourceID` scalar type represents an identifier for an object of type GitModuleSource.
  GitModuleSourceID = T.type_alias { String }

  # The `GitRefID` scalar type represents an identifier for an object of type GitRef.
  GitRefID = T.type_alias { String }

  # The `GitRepositoryID` scalar type represents an identifier for an object of type GitRepository.
  GitRepositoryID = T.type_alias { String }

  # The `HostID` scalar type represents an identifier for an object of type Host.
  HostID = T.type_alias { String }

  # The `InputTypeDefID` scalar type represents an identifier for an object of type InputTypeDef.
  InputTypeDefID = T.type_alias { String }

  # The `InterfaceTypeDefID` scalar type represents an identifier for an object of type InterfaceTypeDef.
  InterfaceTypeDefID = T.type_alias { String }

  # An arbitrary JSON-encoded value.
  JSON = T.type_alias { String }

  # The `LabelID` scalar type represents an identifier for an object of type Label.
  LabelID = T.type_alias { String }

  # The `ListTypeDefID` scalar type represents an identifier for an object of type ListTypeDef.
  ListTypeDefID = T.type_alias { String }

  # The `LocalModuleSourceID` scalar type represents an identifier for an object of type LocalModuleSource.
  LocalModuleSourceID = T.type_alias { String }

  # The `ModuleDependencyID` scalar type represents an identifier for an object of type ModuleDependency.
  ModuleDependencyID = T.type_alias { String }

  # The `ModuleID` scalar type represents an identifier for an object of type Module.
  ModuleID = T.type_alias { String }

  # The `ModuleSourceID` scalar type represents an identifier for an object of type ModuleSource.
  ModuleSourceID = T.type_alias { String }

  # The `ModuleSourceViewID` scalar type represents an identifier for an object of type ModuleSourceView.
  ModuleSourceViewID = T.type_alias { String }

  # The `ObjectTypeDefID` scalar type represents an identifier for an object of type ObjectTypeDef.
  ObjectTypeDefID = T.type_alias { String }

  # The platform config OS and architecture in a Container.
  #
  # The format is [os]/[platform]/[version] (e.g., "darwin/arm64/v7", "windows/amd64", "linux/arm64").
  Platform = T.type_alias { String }

  # The `PortID` scalar type represents an identifier for an object of type Port.
  PortID = T.type_alias { String }

  # The `ScalarTypeDefID` scalar type represents an identifier for an object of type ScalarTypeDef.
  ScalarTypeDefID = T.type_alias { String }

  # The `SecretID` scalar type represents an identifier for an object of type Secret.
  SecretID = T.type_alias { String }

  # The `ServiceID` scalar type represents an identifier for an object of type Service.
  ServiceID = T.type_alias { String }

  # The `SocketID` scalar type represents an identifier for an object of type Socket.
  SocketID = T.type_alias { String }

  # The `SourceMapID` scalar type represents an identifier for an object of type SourceMap.
  SourceMapID = T.type_alias { String }

  # The `TerminalID` scalar type represents an identifier for an object of type Terminal.
  TerminalID = T.type_alias { String }

  # The `TypeDefID` scalar type represents an identifier for an object of type TypeDef.
  TypeDefID = T.type_alias { String }

  # The absence of a value.
  #
  # A Null Void is used as a placeholder for resolvers that do not return anything.
  Void = T.type_alias { String }

  # A directory whose contents persist across runs.
  class CacheVolume < Node; end

  # An OCI-compatible container, also known as a Docker container.
  class Container < Node; end

  # Block to chain methods on Container
  ContainerChain = T.type_alias { T.proc.params(arg0: Container).returns(Container) }

  # Reflective module API provided to functions at runtime.
  class CurrentModule < Node; end

  # A directory.
  class Directory < Node; end

  # Block to chain methods on Directory
  DirectoryChain = T.type_alias { T.proc.params(arg0: Directory).returns(Directory) }

  # The Dagger engine configuration and state
  class Engine < Node; end

  # A cache storage for the Dagger engine
  class EngineCache < Node; end

  # An individual cache entry in a cache entry set
  class EngineCacheEntry < Node; end

  # A set of cache entries returned by a query to a cache
  class EngineCacheEntrySet < Node; end

  # A definition of a custom enum defined in a Module.
  class EnumTypeDef < Node; end

  # A definition of a value in a custom enum defined in a Module.
  class EnumValueTypeDef < Node; end

  # An environment variable name and value.
  class EnvVariable < Node; end

  # Error class
  class Error < Node; end

  # A definition of a field on a custom object defined in a Module.  #  # A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
  class FieldTypeDef < Node; end

  # A file.
  class File < Node; end

  # Block to chain methods on File
  FileChain = T.type_alias { T.proc.params(arg0: File).returns(File) }

  # Function represents a resolver provided by a Module.  #  # A function always evaluates against a parent object and is given a set of named arguments.
  class Function < Node; end

  # Block to chain methods on Function
  FunctionChain = T.type_alias { T.proc.params(arg0: Function).returns(Function) }

  # An argument accepted by a function.  #  # This is a specification for an argument at function definition time, not an argument passed at function call time.
  class FunctionArg < Node; end

  # An active function call.
  class FunctionCall < Node; end

  # A value passed as a named argument to a function call.
  class FunctionCallArgValue < Node; end

  # The result of running an SDK's codegen.
  class GeneratedCode < Node; end

  # Block to chain methods on GeneratedCode
  GeneratedCodeChain = T.type_alias { T.proc.params(arg0: GeneratedCode).returns(GeneratedCode) }

  # Module source originating from a git repo.
  class GitModuleSource < Node; end

  # A git ref (tag, branch, or commit).
  class GitRef < Node; end

  # A git repository.
  class GitRepository < Node; end

  # Block to chain methods on GitRepository
  GitRepositoryChain = T.type_alias { T.proc.params(arg0: GitRepository).returns(GitRepository) }

  # Information about the host environment.
  class Host < Node; end

  # A graphql input type, which is essentially just a group of named args.  # This is currently only used to represent pre-existing usage of graphql input types  # in the core API. It is not used by user modules and shouldn't ever be as user  # module accept input objects via their id rather than graphql input types.
  class InputTypeDef < Node; end

  # A definition of a custom interface defined in a Module.
  class InterfaceTypeDef < Node; end

  # A simple key value object that represents a label.
  class Label < Node; end

  # A definition of a list type in a Module.
  class ListTypeDef < Node; end

  # Module source that that originates from a path locally relative to an arbitrary directory.
  class LocalModuleSource < Node; end

  # A Dagger module.
  class Module_ < Node; end

  # Block to chain methods on Module_
  ModuleChain = T.type_alias { T.proc.params(arg0: Module_).returns(Module_) }

  # The configuration of dependency of a module.
  class ModuleDependency < Node; end

  # The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
  class ModuleSource < Node; end

  # Block to chain methods on ModuleSource
  ModuleSourceChain = T.type_alias { T.proc.params(arg0: ModuleSource).returns(ModuleSource) }

  # A named set of path filters that can be applied to directory arguments provided to functions.
  class ModuleSourceView < Node; end

  # A definition of a custom object defined in a Module.
  class ObjectTypeDef < Node; end

  # A port exposed by a container.
  class Port < Node; end

  # The root of the DAG.
  class Client < Node; end

  # A definition of a custom scalar defined in a Module.
  class ScalarTypeDef < Node; end

  # A reference to a secret value, which can be handled more safely than the value itself.
  class Secret < Node; end

  # A content-addressed service providing TCP connectivity.
  class Service < Node; end

  # Block to chain methods on Service
  ServiceChain = T.type_alias { T.proc.params(arg0: Service).returns(Service) }

  # A Unix or TCP/IP socket that can be mounted into a container.
  class Socket < Node; end

  # Source location information.
  class SourceMap < Node; end

  # An interactive terminal that clients can connect to.
  class Terminal < Node; end

  # A definition of a parameter or return type in a Module.
  class TypeDef < Node; end

  # Block to chain methods on TypeDef
  TypeDefChain = T.type_alias { T.proc.params(arg0: TypeDef).returns(TypeDef) }

  # Optional arguments for as_tarball on Container
  class ContainerAsTarballOpts; end

  # Optional arguments for build on Container
  class ContainerBuildOpts; end

  # Optional arguments for directory on Container
  class ContainerDirectoryOpts; end

  # Optional arguments for export on Container
  class ContainerExportOpts; end

  # Optional arguments for file on Container
  class ContainerFileOpts; end

  # Optional arguments for import on Container
  class ContainerImportOpts; end

  # Optional arguments for publish on Container
  class ContainerPublishOpts; end

  # Optional arguments for terminal on Container
  class ContainerTerminalOpts; end

  # Optional arguments for up on Container
  class ContainerUpOpts; end

  # Optional arguments for with_default_terminal_cmd on Container
  class ContainerWithDefaultTerminalCmdOpts; end

  # Optional arguments for with_directory on Container
  class ContainerWithDirectoryOpts; end

  # Optional arguments for with_entrypoint on Container
  class ContainerWithEntrypointOpts; end

  # Optional arguments for with_env_variable on Container
  class ContainerWithEnvVariableOpts; end

  # Optional arguments for with_exec on Container
  class ContainerWithExecOpts; end

  # Optional arguments for with_exposed_port on Container
  class ContainerWithExposedPortOpts; end

  # Optional arguments for with_file on Container
  class ContainerWithFileOpts; end

  # Optional arguments for with_files on Container
  class ContainerWithFilesOpts; end

  # Optional arguments for with_mounted_cache on Container
  class ContainerWithMountedCacheOpts; end

  # Optional arguments for with_mounted_directory on Container
  class ContainerWithMountedDirectoryOpts; end

  # Optional arguments for with_mounted_file on Container
  class ContainerWithMountedFileOpts; end

  # Optional arguments for with_mounted_secret on Container
  class ContainerWithMountedSecretOpts; end

  # Optional arguments for with_mounted_temp on Container
  class ContainerWithMountedTempOpts; end

  # Optional arguments for with_new_file on Container
  class ContainerWithNewFileOpts; end

  # Optional arguments for with_unix_socket on Container
  class ContainerWithUnixSocketOpts; end

  # Optional arguments for with_workdir on Container
  class ContainerWithWorkdirOpts; end

  # Optional arguments for without_directory on Container
  class ContainerWithoutDirectoryOpts; end

  # Optional arguments for without_entrypoint on Container
  class ContainerWithoutEntrypointOpts; end

  # Optional arguments for without_exposed_port on Container
  class ContainerWithoutExposedPortOpts; end

  # Optional arguments for without_file on Container
  class ContainerWithoutFileOpts; end

  # Optional arguments for without_files on Container
  class ContainerWithoutFilesOpts; end

  # Optional arguments for without_mount on Container
  class ContainerWithoutMountOpts; end

  # Optional arguments for without_unix_socket on Container
  class ContainerWithoutUnixSocketOpts; end

  # Optional arguments for workdir on CurrentModule
  class CurrentModuleWorkdirOpts; end

  # Optional arguments for as_module on Directory
  class DirectoryAsModuleOpts; end

  # Optional arguments for docker_build on Directory
  class DirectoryDockerBuildOpts; end

  # Optional arguments for entries on Directory
  class DirectoryEntriesOpts; end

  # Optional arguments for export on Directory
  class DirectoryExportOpts; end

  # Optional arguments for terminal on Directory
  class DirectoryTerminalOpts; end

  # Optional arguments for with_directory on Directory
  class DirectoryWithDirectoryOpts; end

  # Optional arguments for with_file on Directory
  class DirectoryWithFileOpts; end

  # Optional arguments for with_files on Directory
  class DirectoryWithFilesOpts; end

  # Optional arguments for with_new_directory on Directory
  class DirectoryWithNewDirectoryOpts; end

  # Optional arguments for with_new_file on Directory
  class DirectoryWithNewFileOpts; end

  # Optional arguments for digest on File
  class FileDigestOpts; end

  # Optional arguments for export on File
  class FileExportOpts; end

  # Optional arguments for with_arg on Function
  class FunctionWithArgOpts; end

  # Optional arguments for tree on GitRef
  class GitRefTreeOpts; end

  # Optional arguments for tags on GitRepository
  class GitRepositoryTagsOpts; end

  # Optional arguments for directory on Host
  class HostDirectoryOpts; end

  # Optional arguments for service on Host
  class HostServiceOpts; end

  # Optional arguments for tunnel on Host
  class HostTunnelOpts; end

  # Optional arguments for as_module on ModuleSource
  class ModuleSourceAsModuleOpts; end

  # Optional arguments for resolve_directory_from_caller on ModuleSource
  class ModuleSourceResolveDirectoryFromCallerOpts; end

  # Optional arguments for with_init on ModuleSource
  class ModuleSourceWithInitOpts; end

  # Optional arguments for with_source on Module_
  class ModuleWithSourceOpts; end

  # Optional arguments for container on Client
  class ClientContainerOpts; end

  # Optional arguments for git on Client
  class ClientGitOpts; end

  # Optional arguments for http on Client
  class ClientHttpOpts; end

  # Optional arguments for module_dependency on Client
  class ClientModuleDependencyOpts; end

  # Optional arguments for module_source on Client
  class ClientModuleSourceOpts; end

  # Optional arguments for secret on Client
  class ClientSecretOpts; end

  # Optional arguments for endpoint on Service
  class ServiceEndpointOpts; end

  # Optional arguments for stop on Service
  class ServiceStopOpts; end

  # Optional arguments for up on Service
  class ServiceUpOpts; end

  # Optional arguments for with_enum on TypeDef
  class TypeDefWithEnumOpts; end

  # Optional arguments for with_enum_value on TypeDef
  class TypeDefWithEnumValueOpts; end

  # Optional arguments for with_field on TypeDef
  class TypeDefWithFieldOpts; end

  # Optional arguments for with_interface on TypeDef
  class TypeDefWithInterfaceOpts; end

  # Optional arguments for with_object on TypeDef
  class TypeDefWithObjectOpts; end

  # Optional arguments for with_scalar on TypeDef
  class TypeDefWithScalarOpts; end

  # Input GraphQL type BuildArg
  class BuildArg < T::Struct
    # The build argument name.
    prop :name, String

    # The build argument value.
    prop :value, String
  end

  # A directory whose contents persist across runs.
  class CacheVolume < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end
  end

  # Optional arguments for as_tarball on Container
  class ContainerAsTarballOpts
    extend T::Sig

    # Identifiers for other platform specific containers.
    #
    # Used for multi-platform images.
    sig { returns(T.nilable(T::Array[Container])) }
    attr_accessor :platform_variants

    # Force each layer of the image to use the specified compression algorithm.
    #
    # If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    sig { returns(T.nilable(ImageLayerCompression)) }
    attr_accessor :forced_compression

    # Use the specified media types for the image's layers.
    #
    # Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
    sig { returns(T.nilable(ImageMediaTypes)) }
    attr_accessor :media_types
  end

  # Optional arguments for build on Container
  class ContainerBuildOpts
    extend T::Sig

    # Path to the Dockerfile to use.
    sig { returns(T.nilable(String)) }
    attr_accessor :dockerfile

    # Target build stage to build.
    sig { returns(T.nilable(String)) }
    attr_accessor :target

    # Additional build arguments.
    sig { returns(T.nilable(T::Array[BuildArg])) }
    attr_accessor :build_args

    # Secrets to pass to the build.
    #
    # They will be mounted at /run/secrets/[secret-name] in the build container
    #
    # They can be accessed in the Dockerfile using the "secret" mount type and mount path /run/secrets/[secret-name], e.g. RUN --mount=type=secret,id=my-secret curl [http://example.com?token=$(cat /run/secrets/my-secret)](http://example.com?token=$(cat /run/secrets/my-secret))
    sig { returns(T.nilable(T::Array[Secret])) }
    attr_accessor :secrets
  end

  # Optional arguments for directory on Container
  class ContainerDirectoryOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for export on Container
  class ContainerExportOpts
    extend T::Sig

    # Identifiers for other platform specific containers.
    #
    # Used for multi-platform image.
    sig { returns(T.nilable(T::Array[Container])) }
    attr_accessor :platform_variants

    # Force each layer of the exported image to use the specified compression algorithm.
    #
    # If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    sig { returns(T.nilable(ImageLayerCompression)) }
    attr_accessor :forced_compression

    # Use the specified media types for the exported image's layers.
    #
    # Defaults to OCI, which is largely compatible with most recent container runtimes, but Docker may be needed for older runtimes without OCI support.
    sig { returns(T.nilable(ImageMediaTypes)) }
    attr_accessor :media_types

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for file on Container
  class ContainerFileOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for import on Container
  class ContainerImportOpts
    extend T::Sig

    # Identifies the tag to import from the archive, if the archive bundles multiple tags.
    sig { returns(T.nilable(String)) }
    attr_accessor :tag
  end

  # Optional arguments for publish on Container
  class ContainerPublishOpts
    extend T::Sig

    # Identifiers for other platform specific containers.
    #
    # Used for multi-platform image.
    sig { returns(T.nilable(T::Array[Container])) }
    attr_accessor :platform_variants

    # Force each layer of the published image to use the specified compression algorithm.
    #
    # If this is unset, then if a layer already has a compressed blob in the engine's cache, that will be used (this can result in a mix of compression algorithms for different layers). If this is unset and a layer has no compressed blob in the engine's cache, then it will be compressed using Gzip.
    sig { returns(T.nilable(ImageLayerCompression)) }
    attr_accessor :forced_compression

    # Use the specified media types for the published image's layers.
    #
    # Defaults to OCI, which is largely compatible with most recent registries, but Docker may be needed for older registries without OCI support.
    sig { returns(T.nilable(ImageMediaTypes)) }
    attr_accessor :media_types
  end

  # Optional arguments for terminal on Container
  class ContainerTerminalOpts
    extend T::Sig

    # If set, override the container's default terminal command and invoke these command arguments instead.
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :cmd

    # Provides Dagger access to the executed command.
    #
    # Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :experimental_privileged_nesting

    # Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :insecure_root_capabilities
  end

  # Optional arguments for up on Container
  class ContainerUpOpts
    extend T::Sig

    # List of frontend/backend port mappings to forward.
    #
    # Frontend is the port accepting traffic on the host, backend is the service port.
    sig { returns(T.nilable(T::Array[PortForward])) }
    attr_accessor :ports

    # Bind each tunnel port to a random port on the host.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :random
  end

  # Optional arguments for with_default_terminal_cmd on Container
  class ContainerWithDefaultTerminalCmdOpts
    extend T::Sig

    # Provides Dagger access to the executed command.
    #
    # Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :experimental_privileged_nesting

    # Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :insecure_root_capabilities
  end

  # Optional arguments for with_directory on Container
  class ContainerWithDirectoryOpts
    extend T::Sig

    # Patterns to exclude in the written directory (e.g. ["node_modules/**", ".gitignore", ".git/"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :exclude

    # Patterns to include in the written directory (e.g. ["*.go", "go.mod", "go.sum"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :include

    # A user:group to set for the directory and its contents.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_entrypoint on Container
  class ContainerWithEntrypointOpts
    extend T::Sig

    # Don't remove the default arguments when setting the entrypoint.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :keep_default_args
  end

  # Optional arguments for with_env_variable on Container
  class ContainerWithEnvVariableOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value according to the current environment variables defined in the container (e.g. "/opt/bin:$PATH").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_exec on Container
  class ContainerWithExecOpts
    extend T::Sig

    # If the container has an entrypoint, prepend it to the args.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :use_entrypoint

    # Content to write to the command's standard input before closing (e.g., "Hello world").
    sig { returns(T.nilable(String)) }
    attr_accessor :stdin

    # Redirect the command's standard output to a file in the container (e.g., "/tmp/stdout").
    sig { returns(T.nilable(String)) }
    attr_accessor :redirect_stdout

    # Redirect the command's standard error to a file in the container (e.g., "/tmp/stderr").
    sig { returns(T.nilable(String)) }
    attr_accessor :redirect_stderr

    # Exit codes this command is allowed to exit with without error
    sig { returns(T.nilable(ReturnType)) }
    attr_accessor :expect

    # Provides Dagger access to the executed command.
    #
    # Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :experimental_privileged_nesting

    # Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :insecure_root_capabilities

    # Replace "${VAR}" or "$VAR" in the args according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand

    # If set, skip the automatic init process injected into containers by default.
    #
    # This should only be used if the user requires that their exec process be the pid 1 process in the container. Otherwise it may result in unexpected behavior.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :no_init
  end

  # Optional arguments for with_exposed_port on Container
  class ContainerWithExposedPortOpts
    extend T::Sig

    # Transport layer network protocol
    sig { returns(T.nilable(NetworkProtocol)) }
    attr_accessor :protocol

    # Optional port description
    sig { returns(T.nilable(String)) }
    attr_accessor :description

    # Skip the health check when run as a service.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :experimental_skip_healthcheck
  end

  # Optional arguments for with_file on Container
  class ContainerWithFileOpts
    extend T::Sig

    # Permission given to the copied file (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions

    # A user:group to set for the file.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_files on Container
  class ContainerWithFilesOpts
    extend T::Sig

    # Permission given to the copied files (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions

    # A user:group to set for the files.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_mounted_cache on Container
  class ContainerWithMountedCacheOpts
    extend T::Sig

    # Identifier of the directory to use as the cache volume's root.
    sig { returns(T.nilable(Directory)) }
    attr_accessor :source

    # Sharing mode of the cache volume.
    sig { returns(T.nilable(CacheSharingMode)) }
    attr_accessor :sharing

    # A user:group to set for the mounted cache directory.
    #
    # Note that this changes the ownership of the specified mount along with the initial filesystem provided by source (if any). It does not have any effect if/when the cache has already been created.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_mounted_directory on Container
  class ContainerWithMountedDirectoryOpts
    extend T::Sig

    # A user:group to set for the mounted directory and its contents.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_mounted_file on Container
  class ContainerWithMountedFileOpts
    extend T::Sig

    # A user or user:group to set for the mounted file.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_mounted_secret on Container
  class ContainerWithMountedSecretOpts
    extend T::Sig

    # A user:group to set for the mounted secret.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Permission given to the mounted secret (e.g., 0600).
    #
    # This option requires an owner to be set to be active.
    sig { returns(T.nilable(Integer)) }
    attr_accessor :mode

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_mounted_temp on Container
  class ContainerWithMountedTempOpts
    extend T::Sig

    # Size of the temporary directory in bytes.
    sig { returns(T.nilable(Integer)) }
    attr_accessor :size

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_new_file on Container
  class ContainerWithNewFileOpts
    extend T::Sig

    # Permission given to the written file (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions

    # A user:group to set for the file.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_unix_socket on Container
  class ContainerWithUnixSocketOpts
    extend T::Sig

    # A user:group to set for the mounted socket.
    #
    # The user and group can either be an ID (1000:1000) or a name (foo:bar).
    #
    # If the group is omitted, it defaults to the same as the user.
    sig { returns(T.nilable(String)) }
    attr_accessor :owner

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for with_workdir on Container
  class ContainerWithWorkdirOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for without_directory on Container
  class ContainerWithoutDirectoryOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for without_entrypoint on Container
  class ContainerWithoutEntrypointOpts
    extend T::Sig

    # Don't remove the default arguments when unsetting the entrypoint.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :keep_default_args
  end

  # Optional arguments for without_exposed_port on Container
  class ContainerWithoutExposedPortOpts
    extend T::Sig

    # Port protocol to unexpose
    sig { returns(T.nilable(NetworkProtocol)) }
    attr_accessor :protocol
  end

  # Optional arguments for without_file on Container
  class ContainerWithoutFileOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for without_files on Container
  class ContainerWithoutFilesOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of paths according to the current environment variables defined in the container (e.g. "/$VAR/foo.txt").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for without_mount on Container
  class ContainerWithoutMountOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # Optional arguments for without_unix_socket on Container
  class ContainerWithoutUnixSocketOpts
    extend T::Sig

    # Replace "${VAR}" or "$VAR" in the value of path according to the current environment variables defined in the container (e.g. "/$VAR/foo").
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :expand
  end

  # An OCI-compatible container, also known as a Docker container.
  class Container < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Turn the container into a Service.
    #
    # Be sure to set any exposed ports before this conversion.
    sig { returns(Service) }
    def as_service
      Service.new(self, @client, 'asService')
    end

    # Returns a File representing the container serialized to a tarball.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ContainerAsTarballOpts)).returns(File) }
    def as_tarball(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['platformVariants'] = opts.platform_variants unless opts.platform_variants.nil?
        dag_node_args['forcedCompression'] = opts.forced_compression unless opts.forced_compression.nil?
        dag_node_args['mediaTypes'] = opts.media_types unless opts.media_types.nil?
      end
      File.new(self, @client, 'asTarball', dag_node_args)
    end

    # Initializes this container from a Dockerfile build.
    # @param context - Directory context used by the Dockerfile.
    # @param opts - Optional arguments
    sig { params(context: Directory, opts: T.nilable(ContainerBuildOpts)).returns(Container) }
    def build(context:, opts: nil)
      assert_not_nil(:context, context)
      dag_node_args = {
        'context' => context
      }
      unless opts.nil?
        dag_node_args['dockerfile'] = opts.dockerfile unless opts.dockerfile.nil?
        dag_node_args['target'] = opts.target unless opts.target.nil?
        dag_node_args['buildArgs'] = opts.build_args unless opts.build_args.nil?
        dag_node_args['secrets'] = opts.secrets unless opts.secrets.nil?
      end
      Container.new(self, @client, 'build', dag_node_args)
    end

    # Retrieves default arguments for future commands.
    sig { returns(T::Array[String]) }
    def default_args
      n = Container.new(self, @client, 'defaultArgs')
      @client.invoke(n)
    end

    # Retrieves a directory at the given path.
    #
    # Mounts are included.
    # @param path - The path of the directory to retrieve (e.g., "./src").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerDirectoryOpts)).returns(Directory) }
    def directory(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Directory.new(self, @client, 'directory', dag_node_args)
    end

    # Retrieves entrypoint to be prepended to the arguments of all commands.
    sig { returns(T::Array[String]) }
    def entrypoint
      n = Container.new(self, @client, 'entrypoint')
      @client.invoke(n)
    end

    # Retrieves the value of the specified environment variable.
    # @param name - The name of the environment variable to retrieve (e.g., "PATH").
    sig { params(name: String).returns(String) }
    def env_variable(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      n = Container.new(self, @client, 'envVariable', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves the list of environment variables passed to commands.
    sig { returns(T::Array[EnvVariable]) }
    def env_variables
      n = Container.new(self, @client, 'envVariables')
      @client.invoke(n)
    end

    # The exit code of the last executed command.
    #
    # Returns an error if no command was set.
    sig { returns(Integer) }
    def exit_code
      n = Container.new(self, @client, 'exitCode')
      @client.invoke(n)
    end

    # EXPERIMENTAL API! Subject to change/removal at any time.
    #
    # Configures all available GPUs on the host to be accessible to this container.
    #
    # This currently works for Nvidia devices only.
    sig { returns(Container) }
    def experimental_with_all_gp_us
      Container.new(self, @client, 'experimentalWithAllGPUs')
    end

    # EXPERIMENTAL API! Subject to change/removal at any time.
    #
    # Configures the provided list of devices to be accessible to this container.
    #
    # This currently works for Nvidia devices only.
    # @param devices - List of devices to be accessible to this container.
    sig { params(devices: T::Array[String]).returns(Container) }
    def experimental_with_gpu(devices:)
      assert_not_nil(:devices, devices)
      dag_node_args = {
        'devices' => devices
      }
      Container.new(self, @client, 'experimentalWithGPU', dag_node_args)
    end

    # Writes the container as an OCI tarball to the destination file path on the host.
    #
    # It can also export platform variants.
    # @param path - Host's destination path (e.g., "./tarball").
    #
    # Path can be relative to the engine's workdir or absolute.
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerExportOpts)).returns(String) }
    def export(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['platformVariants'] = opts.platform_variants unless opts.platform_variants.nil?
        dag_node_args['forcedCompression'] = opts.forced_compression unless opts.forced_compression.nil?
        dag_node_args['mediaTypes'] = opts.media_types unless opts.media_types.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      n = Container.new(self, @client, 'export', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves the list of exposed ports.
    #
    # This includes ports already exposed by the image, even if not explicitly added with dagger.
    sig { returns(T::Array[Port]) }
    def exposed_ports
      n = Container.new(self, @client, 'exposedPorts')
      @client.invoke(n)
    end

    # Retrieves a file at the given path.
    #
    # Mounts are included.
    # @param path - The path of the file to retrieve (e.g., "./README.md").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerFileOpts)).returns(File) }
    def file(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      File.new(self, @client, 'file', dag_node_args)
    end

    # Initializes this container from a pulled base image.
    # @param address - Image's address from its registry.
    #
    # Formatted as [host]/[user]/[repo]:[tag] (e.g., "docker.io/dagger/dagger:main").
    sig { params(address: String).returns(Container) }
    def from(address:)
      assert_not_nil(:address, address)
      dag_node_args = {
        'address' => address
      }
      Container.new(self, @client, 'from', dag_node_args)
    end

    # The unique image reference which can only be retrieved immediately after the 'Container.From' call.
    sig { returns(String) }
    def image_ref
      n = Container.new(self, @client, 'imageRef')
      @client.invoke(n)
    end

    # Reads the container from an OCI tarball.
    # @param source - File to read the container from.
    # @param opts - Optional arguments
    sig { params(source: File, opts: T.nilable(ContainerImportOpts)).returns(Container) }
    def import(source:, opts: nil)
      assert_not_nil(:source, source)
      dag_node_args = {
        'source' => source
      }
      unless opts.nil?
        dag_node_args['tag'] = opts.tag unless opts.tag.nil?
      end
      Container.new(self, @client, 'import', dag_node_args)
    end

    # Retrieves the value of the specified label.
    # @param name - The name of the label (e.g., "org.opencontainers.artifact.created").
    sig { params(name: String).returns(String) }
    def label(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      n = Container.new(self, @client, 'label', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves the list of labels passed to container.
    sig { returns(T::Array[Label]) }
    def labels
      n = Container.new(self, @client, 'labels')
      @client.invoke(n)
    end

    # Retrieves the list of paths where a directory is mounted.
    sig { returns(T::Array[String]) }
    def mounts
      n = Container.new(self, @client, 'mounts')
      @client.invoke(n)
    end

    # The platform this container executes and publishes as.
    sig { returns(Platform) }
    def platform
      n = Container.new(self, @client, 'platform')
      @client.invoke(n)
    end

    # Publishes this container as a new image to the specified address.
    #
    # Publish returns a fully qualified ref.
    #
    # It can also publish platform variants.
    # @param address - Registry's address to publish the image to.
    #
    # Formatted as [host]/[user]/[repo]:[tag] (e.g. "docker.io/dagger/dagger:main").
    # @param opts - Optional arguments
    sig { params(address: String, opts: T.nilable(ContainerPublishOpts)).returns(String) }
    def publish(address:, opts: nil)
      assert_not_nil(:address, address)
      dag_node_args = {
        'address' => address
      }
      unless opts.nil?
        dag_node_args['platformVariants'] = opts.platform_variants unless opts.platform_variants.nil?
        dag_node_args['forcedCompression'] = opts.forced_compression unless opts.forced_compression.nil?
        dag_node_args['mediaTypes'] = opts.media_types unless opts.media_types.nil?
      end
      n = Container.new(self, @client, 'publish', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves this container's root filesystem. Mounts are not included.
    sig { returns(Directory) }
    def rootfs
      Directory.new(self, @client, 'rootfs')
    end

    # The error stream of the last executed command.
    #
    # Returns an error if no command was set.
    sig { returns(String) }
    def stderr
      n = Container.new(self, @client, 'stderr')
      @client.invoke(n)
    end

    # The output stream of the last executed command.
    #
    # Returns an error if no command was set.
    sig { returns(String) }
    def stdout
      n = Container.new(self, @client, 'stdout')
      @client.invoke(n)
    end

    # Forces evaluation of the pipeline in the engine.
    #
    # It doesn't run the default command if no exec has been set.
    sig { returns(ContainerID) }
    def sync
      n = Container.new(self, @client, 'sync')
      @client.invoke(n)
    end

    # Opens an interactive terminal for this container using its configured default terminal command if not overridden by args (or sh as a fallback default).
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ContainerTerminalOpts)).returns(Container) }
    def terminal(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['cmd'] = opts.cmd unless opts.cmd.nil?
        dag_node_args['experimentalPrivilegedNesting'] = opts.experimental_privileged_nesting unless opts.experimental_privileged_nesting.nil?
        dag_node_args['insecureRootCapabilities'] = opts.insecure_root_capabilities unless opts.insecure_root_capabilities.nil?
      end
      Container.new(self, @client, 'terminal', dag_node_args)
    end

    # Starts a Service and creates a tunnel that forwards traffic from the caller's network to that service.
    #
    # Be sure to set any exposed ports before calling this api.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ContainerUpOpts)).returns(Void) }
    def up(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['ports'] = opts.ports unless opts.ports.nil?
        dag_node_args['random'] = opts.random unless opts.random.nil?
      end
      n = Container.new(self, @client, 'up', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves the user to be set for all commands.
    sig { returns(String) }
    def user
      n = Container.new(self, @client, 'user')
      @client.invoke(n)
    end

    # Retrieves this container plus the given OCI anotation.
    # @param name - The name of the annotation.
    # @param value - The value of the annotation.
    sig { params(name: String, value: String).returns(Container) }
    def with_annotation(name:, value:)
      assert_not_nil(:name, name)
      assert_not_nil(:value, value)
      dag_node_args = {
        'name' => name,
        'value' => value
      }
      Container.new(self, @client, 'withAnnotation', dag_node_args)
    end

    # Configures default arguments for future commands.
    # @param args - Arguments to prepend to future executions (e.g., ["-v", "--no-cache"]).
    sig { params(args: T::Array[String]).returns(Container) }
    def with_default_args(args:)
      assert_not_nil(:args, args)
      dag_node_args = {
        'args' => args
      }
      Container.new(self, @client, 'withDefaultArgs', dag_node_args)
    end

    # Set the default command to invoke for the container's terminal API.
    # @param args - The args of the command.
    # @param opts - Optional arguments
    sig { params(args: T::Array[String], opts: T.nilable(ContainerWithDefaultTerminalCmdOpts)).returns(Container) }
    def with_default_terminal_cmd(args:, opts: nil)
      assert_not_nil(:args, args)
      dag_node_args = {
        'args' => args
      }
      unless opts.nil?
        dag_node_args['experimentalPrivilegedNesting'] = opts.experimental_privileged_nesting unless opts.experimental_privileged_nesting.nil?
        dag_node_args['insecureRootCapabilities'] = opts.insecure_root_capabilities unless opts.insecure_root_capabilities.nil?
      end
      Container.new(self, @client, 'withDefaultTerminalCmd', dag_node_args)
    end

    # Retrieves this container plus a directory written at the given path.
    # @param path - Location of the written directory (e.g., "/tmp/directory").
    # @param directory - Identifier of the directory to write
    # @param opts - Optional arguments
    sig { params(path: String, directory: Directory, opts: T.nilable(ContainerWithDirectoryOpts)).returns(Container) }
    def with_directory(path:, directory:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:directory, directory)
      dag_node_args = {
        'path' => path,
        'directory' => directory
      }
      unless opts.nil?
        dag_node_args['exclude'] = opts.exclude unless opts.exclude.nil?
        dag_node_args['include'] = opts.include unless opts.include.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withDirectory', dag_node_args)
    end

    # Retrieves this container but with a different command entrypoint.
    # @param args - Entrypoint to use for future executions (e.g., ["go", "run"]).
    # @param opts - Optional arguments
    sig { params(args: T::Array[String], opts: T.nilable(ContainerWithEntrypointOpts)).returns(Container) }
    def with_entrypoint(args:, opts: nil)
      assert_not_nil(:args, args)
      dag_node_args = {
        'args' => args
      }
      unless opts.nil?
        dag_node_args['keepDefaultArgs'] = opts.keep_default_args unless opts.keep_default_args.nil?
      end
      Container.new(self, @client, 'withEntrypoint', dag_node_args)
    end

    # Retrieves this container plus the given environment variable.
    # @param name - The name of the environment variable (e.g., "HOST").
    # @param value - The value of the environment variable. (e.g., "localhost").
    # @param opts - Optional arguments
    sig { params(name: String, value: String, opts: T.nilable(ContainerWithEnvVariableOpts)).returns(Container) }
    def with_env_variable(name:, value:, opts: nil)
      assert_not_nil(:name, name)
      assert_not_nil(:value, value)
      dag_node_args = {
        'name' => name,
        'value' => value
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withEnvVariable', dag_node_args)
    end

    # Retrieves this container after executing the specified command inside it.
    # @param args - Command to run instead of the container's default command (e.g., ["run", "main.go"]).
    #
    # If empty, the container's default command is used.
    # @param opts - Optional arguments
    sig { params(args: T::Array[String], opts: T.nilable(ContainerWithExecOpts)).returns(Container) }
    def with_exec(args:, opts: nil)
      assert_not_nil(:args, args)
      dag_node_args = {
        'args' => args
      }
      unless opts.nil?
        dag_node_args['useEntrypoint'] = opts.use_entrypoint unless opts.use_entrypoint.nil?
        dag_node_args['stdin'] = opts.stdin unless opts.stdin.nil?
        dag_node_args['redirectStdout'] = opts.redirect_stdout unless opts.redirect_stdout.nil?
        dag_node_args['redirectStderr'] = opts.redirect_stderr unless opts.redirect_stderr.nil?
        dag_node_args['expect'] = opts.expect unless opts.expect.nil?
        dag_node_args['experimentalPrivilegedNesting'] = opts.experimental_privileged_nesting unless opts.experimental_privileged_nesting.nil?
        dag_node_args['insecureRootCapabilities'] = opts.insecure_root_capabilities unless opts.insecure_root_capabilities.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
        dag_node_args['noInit'] = opts.no_init unless opts.no_init.nil?
      end
      Container.new(self, @client, 'withExec', dag_node_args)
    end

    # Expose a network port.
    #
    # Exposed ports serve two purposes:
    #
    # - For health checks and introspection, when running services
    #
    # - For setting the EXPOSE OCI field when publishing the container
    # @param port - Port number to expose
    # @param opts - Optional arguments
    sig { params(port: Integer, opts: T.nilable(ContainerWithExposedPortOpts)).returns(Container) }
    def with_exposed_port(port:, opts: nil)
      assert_not_nil(:port, port)
      dag_node_args = {
        'port' => port
      }
      unless opts.nil?
        dag_node_args['protocol'] = opts.protocol unless opts.protocol.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['experimentalSkipHealthcheck'] = opts.experimental_skip_healthcheck unless opts.experimental_skip_healthcheck.nil?
      end
      Container.new(self, @client, 'withExposedPort', dag_node_args)
    end

    # Retrieves this container plus the contents of the given file copied to the given path.
    # @param path - Location of the copied file (e.g., "/tmp/file.txt").
    # @param source - Identifier of the file to copy.
    # @param opts - Optional arguments
    sig { params(path: String, source: File, opts: T.nilable(ContainerWithFileOpts)).returns(Container) }
    def with_file(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withFile', dag_node_args)
    end

    # Retrieves this container plus the contents of the given files copied to the given path.
    # @param path - Location where copied files should be placed (e.g., "/src").
    # @param sources - Identifiers of the files to copy.
    # @param opts - Optional arguments
    sig { params(path: String, sources: T::Array[File], opts: T.nilable(ContainerWithFilesOpts)).returns(Container) }
    def with_files(path:, sources:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:sources, sources)
      dag_node_args = {
        'path' => path,
        'sources' => sources
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withFiles', dag_node_args)
    end

    # Retrieves this container plus the given label.
    # @param name - The name of the label (e.g., "org.opencontainers.artifact.created").
    # @param value - The value of the label (e.g., "2023-01-01T00:00:00Z").
    sig { params(name: String, value: String).returns(Container) }
    def with_label(name:, value:)
      assert_not_nil(:name, name)
      assert_not_nil(:value, value)
      dag_node_args = {
        'name' => name,
        'value' => value
      }
      Container.new(self, @client, 'withLabel', dag_node_args)
    end

    # Retrieves this container plus a cache volume mounted at the given path.
    # @param path - Location of the cache directory (e.g., "/cache/node_modules").
    # @param cache - Identifier of the cache volume to mount.
    # @param opts - Optional arguments
    sig { params(path: String, cache: CacheVolume, opts: T.nilable(ContainerWithMountedCacheOpts)).returns(Container) }
    def with_mounted_cache(path:, cache:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:cache, cache)
      dag_node_args = {
        'path' => path,
        'cache' => cache
      }
      unless opts.nil?
        dag_node_args['source'] = opts.source unless opts.source.nil?
        dag_node_args['sharing'] = opts.sharing unless opts.sharing.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withMountedCache', dag_node_args)
    end

    # Retrieves this container plus a directory mounted at the given path.
    # @param path - Location of the mounted directory (e.g., "/mnt/directory").
    # @param source - Identifier of the mounted directory.
    # @param opts - Optional arguments
    sig { params(path: String, source: Directory, opts: T.nilable(ContainerWithMountedDirectoryOpts)).returns(Container) }
    def with_mounted_directory(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withMountedDirectory', dag_node_args)
    end

    # Retrieves this container plus a file mounted at the given path.
    # @param path - Location of the mounted file (e.g., "/tmp/file.txt").
    # @param source - Identifier of the mounted file.
    # @param opts - Optional arguments
    sig { params(path: String, source: File, opts: T.nilable(ContainerWithMountedFileOpts)).returns(Container) }
    def with_mounted_file(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withMountedFile', dag_node_args)
    end

    # Retrieves this container plus a secret mounted into a file at the given path.
    # @param path - Location of the secret file (e.g., "/tmp/secret.txt").
    # @param source - Identifier of the secret to mount.
    # @param opts - Optional arguments
    sig { params(path: String, source: Secret, opts: T.nilable(ContainerWithMountedSecretOpts)).returns(Container) }
    def with_mounted_secret(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['mode'] = opts.mode unless opts.mode.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withMountedSecret', dag_node_args)
    end

    # Retrieves this container plus a temporary directory mounted at the given path. Any writes will be ephemeral to a single withExec call; they will not be persisted to subsequent withExecs.
    # @param path - Location of the temporary directory (e.g., "/tmp/temp_dir").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithMountedTempOpts)).returns(Container) }
    def with_mounted_temp(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['size'] = opts.size unless opts.size.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withMountedTemp', dag_node_args)
    end

    # Retrieves this container plus a new file written at the given path.
    # @param path - Location of the written file (e.g., "/tmp/file.txt").
    # @param contents - Content of the file to write (e.g., "Hello world!").
    # @param opts - Optional arguments
    sig { params(path: String, contents: String, opts: T.nilable(ContainerWithNewFileOpts)).returns(Container) }
    def with_new_file(path:, contents:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:contents, contents)
      dag_node_args = {
        'path' => path,
        'contents' => contents
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withNewFile', dag_node_args)
    end

    # Retrieves this container with a registry authentication for a given address.
    # @param address - Registry's address to bind the authentication to.
    #
    # Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    # @param username - The username of the registry's account (e.g., "Dagger").
    # @param secret - The API key, password or token to authenticate to this registry.
    sig { params(address: String, username: String, secret: Secret).returns(Container) }
    def with_registry_auth(address:, username:, secret:)
      assert_not_nil(:address, address)
      assert_not_nil(:username, username)
      assert_not_nil(:secret, secret)
      dag_node_args = {
        'address' => address,
        'username' => username,
        'secret' => secret
      }
      Container.new(self, @client, 'withRegistryAuth', dag_node_args)
    end

    # Retrieves the container with the given directory mounted to /.
    # @param directory - Directory to mount.
    sig { params(directory: Directory).returns(Container) }
    def with_rootfs(directory:)
      assert_not_nil(:directory, directory)
      dag_node_args = {
        'directory' => directory
      }
      Container.new(self, @client, 'withRootfs', dag_node_args)
    end

    # Retrieves this container plus an env variable containing the given secret.
    # @param name - The name of the secret variable (e.g., "API_SECRET").
    # @param secret - The identifier of the secret value.
    sig { params(name: String, secret: Secret).returns(Container) }
    def with_secret_variable(name:, secret:)
      assert_not_nil(:name, name)
      assert_not_nil(:secret, secret)
      dag_node_args = {
        'name' => name,
        'secret' => secret
      }
      Container.new(self, @client, 'withSecretVariable', dag_node_args)
    end

    # Establish a runtime dependency on a service.
    #
    # The service will be started automatically when needed and detached when it is no longer needed, executing the default command if none is set.
    #
    # The service will be reachable from the container via the provided hostname alias.
    #
    # The service dependency will also convey to any files or directories produced by the container.
    # @param alias_ - A name that can be used to reach the service from the container
    # @param service - Identifier of the service container
    sig { params(alias_: String, service: Service).returns(Container) }
    def with_service_binding(alias_:, service:)
      assert_not_nil(:alias_, alias_)
      assert_not_nil(:service, service)
      dag_node_args = {
        'alias' => alias_,
        'service' => service
      }
      Container.new(self, @client, 'withServiceBinding', dag_node_args)
    end

    # Retrieves this container plus a socket forwarded to the given Unix socket path.
    # @param path - Location of the forwarded Unix socket (e.g., "/tmp/socket").
    # @param source - Identifier of the socket to forward.
    # @param opts - Optional arguments
    sig { params(path: String, source: Socket, opts: T.nilable(ContainerWithUnixSocketOpts)).returns(Container) }
    def with_unix_socket(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['owner'] = opts.owner unless opts.owner.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withUnixSocket', dag_node_args)
    end

    # Retrieves this container with a different command user.
    # @param name - The user to set (e.g., "root").
    sig { params(name: String).returns(Container) }
    def with_user(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      Container.new(self, @client, 'withUser', dag_node_args)
    end

    # Retrieves this container with a different working directory.
    # @param path - The path to set as the working directory (e.g., "/app").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithWorkdirOpts)).returns(Container) }
    def with_workdir(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withWorkdir', dag_node_args)
    end

    # Retrieves this container minus the given OCI annotation.
    # @param name - The name of the annotation.
    sig { params(name: String).returns(Container) }
    def without_annotation(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      Container.new(self, @client, 'withoutAnnotation', dag_node_args)
    end

    # Retrieves this container with unset default arguments for future commands.
    sig { returns(Container) }
    def without_default_args
      Container.new(self, @client, 'withoutDefaultArgs')
    end

    # Retrieves this container with the directory at the given path removed.
    # @param path - Location of the directory to remove (e.g., ".github/").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithoutDirectoryOpts)).returns(Container) }
    def without_directory(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withoutDirectory', dag_node_args)
    end

    # Retrieves this container with an unset command entrypoint.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ContainerWithoutEntrypointOpts)).returns(Container) }
    def without_entrypoint(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['keepDefaultArgs'] = opts.keep_default_args unless opts.keep_default_args.nil?
      end
      Container.new(self, @client, 'withoutEntrypoint', dag_node_args)
    end

    # Retrieves this container minus the given environment variable.
    # @param name - The name of the environment variable (e.g., "HOST").
    sig { params(name: String).returns(Container) }
    def without_env_variable(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      Container.new(self, @client, 'withoutEnvVariable', dag_node_args)
    end

    # Unexpose a previously exposed port.
    # @param port - Port number to unexpose
    # @param opts - Optional arguments
    sig { params(port: Integer, opts: T.nilable(ContainerWithoutExposedPortOpts)).returns(Container) }
    def without_exposed_port(port:, opts: nil)
      assert_not_nil(:port, port)
      dag_node_args = {
        'port' => port
      }
      unless opts.nil?
        dag_node_args['protocol'] = opts.protocol unless opts.protocol.nil?
      end
      Container.new(self, @client, 'withoutExposedPort', dag_node_args)
    end

    # Retrieves this container with the file at the given path removed.
    # @param path - Location of the file to remove (e.g., "/file.txt").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithoutFileOpts)).returns(Container) }
    def without_file(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withoutFile', dag_node_args)
    end

    # Retrieves this container with the files at the given paths removed.
    # @param paths - Location of the files to remove (e.g., ["/file.txt"]).
    # @param opts - Optional arguments
    sig { params(paths: T::Array[String], opts: T.nilable(ContainerWithoutFilesOpts)).returns(Container) }
    def without_files(paths:, opts: nil)
      assert_not_nil(:paths, paths)
      dag_node_args = {
        'paths' => paths
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withoutFiles', dag_node_args)
    end

    # Retrieves this container minus the given environment label.
    # @param name - The name of the label to remove (e.g., "org.opencontainers.artifact.created").
    sig { params(name: String).returns(Container) }
    def without_label(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      Container.new(self, @client, 'withoutLabel', dag_node_args)
    end

    # Retrieves this container after unmounting everything at the given path.
    # @param path - Location of the cache directory (e.g., "/cache/node_modules").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithoutMountOpts)).returns(Container) }
    def without_mount(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withoutMount', dag_node_args)
    end

    # Retrieves this container without the registry authentication of a given address.
    # @param address - Registry's address to remove the authentication from.
    #
    # Formatted as [host]/[user]/[repo]:[tag] (e.g. docker.io/dagger/dagger:main).
    sig { params(address: String).returns(Container) }
    def without_registry_auth(address:)
      assert_not_nil(:address, address)
      dag_node_args = {
        'address' => address
      }
      Container.new(self, @client, 'withoutRegistryAuth', dag_node_args)
    end

    # Retrieves this container minus the given environment variable containing the secret.
    # @param name - The name of the environment variable (e.g., "HOST").
    sig { params(name: String).returns(Container) }
    def without_secret_variable(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      Container.new(self, @client, 'withoutSecretVariable', dag_node_args)
    end

    # Retrieves this container with a previously added Unix socket removed.
    # @param path - Location of the socket to remove (e.g., "/tmp/socket").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ContainerWithoutUnixSocketOpts)).returns(Container) }
    def without_unix_socket(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['expand'] = opts.expand unless opts.expand.nil?
      end
      Container.new(self, @client, 'withoutUnixSocket', dag_node_args)
    end

    # Retrieves this container with an unset command user.
    #
    # Should default to root.
    sig { returns(Container) }
    def without_user
      Container.new(self, @client, 'withoutUser')
    end

    # Retrieves this container with an unset working directory.
    #
    # Should default to "/".
    sig { returns(Container) }
    def without_workdir
      Container.new(self, @client, 'withoutWorkdir')
    end

    # Retrieves the working directory for all commands.
    sig { returns(String) }
    def workdir
      n = Container.new(self, @client, 'workdir')
      @client.invoke(n)
    end

    sig { params(_blk: ContainerChain).returns(Container) }
    def with(&_blk)
      yield self
    end
  end

  # Optional arguments for workdir on CurrentModule
  class CurrentModuleWorkdirOpts
    extend T::Sig

    # Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :exclude

    # Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :include
  end

  # Reflective module API provided to functions at runtime.
  class CurrentModule < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The name of the module being executed in
    sig { returns(String) }
    def name
      n = CurrentModule.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The directory containing the module's source code loaded into the engine (plus any generated code that may have been created).
    sig { returns(Directory) }
    def source
      Directory.new(self, @client, 'source')
    end

    # Load a directory from the module's scratch working directory, including any changes that may have been made to it during module function execution.
    # @param path - Location of the directory to access (e.g., ".").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(CurrentModuleWorkdirOpts)).returns(Directory) }
    def workdir(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['exclude'] = opts.exclude unless opts.exclude.nil?
        dag_node_args['include'] = opts.include unless opts.include.nil?
      end
      Directory.new(self, @client, 'workdir', dag_node_args)
    end

    # Load a file from the module's scratch working directory, including any changes that may have been made to it during module function execution.Load a file from the module's scratch working directory, including any changes that may have been made to it during module function execution.
    # @param path - Location of the file to retrieve (e.g., "README.md").
    sig { params(path: String).returns(File) }
    def workdir_file(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      File.new(self, @client, 'workdirFile', dag_node_args)
    end
  end

  # Optional arguments for as_module on Directory
  class DirectoryAsModuleOpts
    extend T::Sig

    # An optional subpath of the directory which contains the module's configuration file.
    #
    # This is needed when the module code is in a subdirectory but requires parent directories to be loaded in order to execute. For example, the module source code may need a go.mod, project.toml, package.json, etc. file from a parent directory.
    #
    # If not set, the module source code is loaded from the root of the directory.
    sig { returns(T.nilable(String)) }
    attr_accessor :source_root_path

    # The engine version to upgrade to.
    sig { returns(T.nilable(String)) }
    attr_accessor :engine_version
  end

  # Optional arguments for docker_build on Directory
  class DirectoryDockerBuildOpts
    extend T::Sig

    # The platform to build.
    sig { returns(T.nilable(Platform)) }
    attr_accessor :platform

    # Path to the Dockerfile to use (e.g., "frontend.Dockerfile").
    sig { returns(T.nilable(String)) }
    attr_accessor :dockerfile

    # Target build stage to build.
    sig { returns(T.nilable(String)) }
    attr_accessor :target

    # Build arguments to use in the build.
    sig { returns(T.nilable(T::Array[BuildArg])) }
    attr_accessor :build_args

    # Secrets to pass to the build.
    #
    # They will be mounted at /run/secrets/[secret-name].
    sig { returns(T.nilable(T::Array[Secret])) }
    attr_accessor :secrets
  end

  # Optional arguments for entries on Directory
  class DirectoryEntriesOpts
    extend T::Sig

    # Location of the directory to look at (e.g., "/src").
    sig { returns(T.nilable(String)) }
    attr_accessor :path
  end

  # Optional arguments for export on Directory
  class DirectoryExportOpts
    extend T::Sig

    # If true, then the host directory will be wiped clean before exporting so that it exactly matches the directory being exported; this means it will delete any files on the host that aren't in the exported dir. If false (the default), the contents of the directory will be merged with any existing contents of the host directory, leaving any existing files on the host that aren't in the exported directory alone.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :wipe
  end

  # Optional arguments for terminal on Directory
  class DirectoryTerminalOpts
    extend T::Sig

    # If set, override the container's default terminal command and invoke these command arguments instead.
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :cmd

    # Provides Dagger access to the executed command.
    #
    # Do not use this option unless you trust the command being executed; the command being executed WILL BE GRANTED FULL ACCESS TO YOUR HOST FILESYSTEM.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :experimental_privileged_nesting

    # Execute the command with all root capabilities. This is similar to running a command with "sudo" or executing "docker run" with the "--privileged" flag. Containerization does not provide any security guarantees when using this option. It should only be used when absolutely necessary and only with trusted commands.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :insecure_root_capabilities

    # If set, override the default container used for the terminal.
    sig { returns(T.nilable(Container)) }
    attr_accessor :container
  end

  # Optional arguments for with_directory on Directory
  class DirectoryWithDirectoryOpts
    extend T::Sig

    # Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :exclude

    # Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :include
  end

  # Optional arguments for with_file on Directory
  class DirectoryWithFileOpts
    extend T::Sig

    # Permission given to the copied file (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions
  end

  # Optional arguments for with_files on Directory
  class DirectoryWithFilesOpts
    extend T::Sig

    # Permission given to the copied files (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions
  end

  # Optional arguments for with_new_directory on Directory
  class DirectoryWithNewDirectoryOpts
    extend T::Sig

    # Permission granted to the created directory (e.g., 0777).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions
  end

  # Optional arguments for with_new_file on Directory
  class DirectoryWithNewFileOpts
    extend T::Sig

    # Permission given to the copied file (e.g., 0600).
    sig { returns(T.nilable(Integer)) }
    attr_accessor :permissions
  end

  # A directory.
  class Directory < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Load the directory as a Dagger module
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(DirectoryAsModuleOpts)).returns(Module_) }
    def as_module(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['sourceRootPath'] = opts.source_root_path unless opts.source_root_path.nil?
        dag_node_args['engineVersion'] = opts.engine_version unless opts.engine_version.nil?
      end
      Module_.new(self, @client, 'asModule', dag_node_args)
    end

    # Gets the difference between this directory and an another directory.
    # @param other - Identifier of the directory to compare.
    sig { params(other: Directory).returns(Directory) }
    def diff(other:)
      assert_not_nil(:other, other)
      dag_node_args = {
        'other' => other
      }
      Directory.new(self, @client, 'diff', dag_node_args)
    end

    # Return the directory's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    sig { returns(String) }
    def digest
      n = Directory.new(self, @client, 'digest')
      @client.invoke(n)
    end

    # Retrieves a directory at the given path.
    # @param path - Location of the directory to retrieve (e.g., "/src").
    sig { params(path: String).returns(Directory) }
    def directory(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      Directory.new(self, @client, 'directory', dag_node_args)
    end

    # Builds a new Docker container from this directory.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(DirectoryDockerBuildOpts)).returns(Container) }
    def docker_build(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['platform'] = opts.platform unless opts.platform.nil?
        dag_node_args['dockerfile'] = opts.dockerfile unless opts.dockerfile.nil?
        dag_node_args['target'] = opts.target unless opts.target.nil?
        dag_node_args['buildArgs'] = opts.build_args unless opts.build_args.nil?
        dag_node_args['secrets'] = opts.secrets unless opts.secrets.nil?
      end
      Container.new(self, @client, 'dockerBuild', dag_node_args)
    end

    # Returns a list of files and directories at the given path.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(DirectoryEntriesOpts)).returns(T::Array[String]) }
    def entries(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['path'] = opts.path unless opts.path.nil?
      end
      n = Directory.new(self, @client, 'entries', dag_node_args)
      @client.invoke(n)
    end

    # Writes the contents of the directory to a path on the host.
    # @param path - Location of the copied directory (e.g., "logs/").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(DirectoryExportOpts)).returns(String) }
    def export(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['wipe'] = opts.wipe unless opts.wipe.nil?
      end
      n = Directory.new(self, @client, 'export', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves a file at the given path.
    # @param path - Location of the file to retrieve (e.g., "README.md").
    sig { params(path: String).returns(File) }
    def file(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      File.new(self, @client, 'file', dag_node_args)
    end

    # Returns a list of files and directories that matche the given pattern.
    # @param pattern - Pattern to match (e.g., "*.md").
    sig { params(pattern: String).returns(T::Array[String]) }
    def glob(pattern:)
      assert_not_nil(:pattern, pattern)
      dag_node_args = {
        'pattern' => pattern
      }
      n = Directory.new(self, @client, 'glob', dag_node_args)
      @client.invoke(n)
    end

    # Force evaluation in the engine.
    sig { returns(DirectoryID) }
    def sync
      n = Directory.new(self, @client, 'sync')
      @client.invoke(n)
    end

    # Opens an interactive terminal in new container with this directory mounted inside.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(DirectoryTerminalOpts)).returns(Directory) }
    def terminal(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['cmd'] = opts.cmd unless opts.cmd.nil?
        dag_node_args['experimentalPrivilegedNesting'] = opts.experimental_privileged_nesting unless opts.experimental_privileged_nesting.nil?
        dag_node_args['insecureRootCapabilities'] = opts.insecure_root_capabilities unless opts.insecure_root_capabilities.nil?
        dag_node_args['container'] = opts.container unless opts.container.nil?
      end
      Directory.new(self, @client, 'terminal', dag_node_args)
    end

    # Retrieves this directory plus a directory written at the given path.
    # @param path - Location of the written directory (e.g., "/src/").
    # @param directory - Identifier of the directory to copy.
    # @param opts - Optional arguments
    sig { params(path: String, directory: Directory, opts: T.nilable(DirectoryWithDirectoryOpts)).returns(Directory) }
    def with_directory(path:, directory:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:directory, directory)
      dag_node_args = {
        'path' => path,
        'directory' => directory
      }
      unless opts.nil?
        dag_node_args['exclude'] = opts.exclude unless opts.exclude.nil?
        dag_node_args['include'] = opts.include unless opts.include.nil?
      end
      Directory.new(self, @client, 'withDirectory', dag_node_args)
    end

    # Retrieves this directory plus the contents of the given file copied to the given path.
    # @param path - Location of the copied file (e.g., "/file.txt").
    # @param source - Identifier of the file to copy.
    # @param opts - Optional arguments
    sig { params(path: String, source: File, opts: T.nilable(DirectoryWithFileOpts)).returns(Directory) }
    def with_file(path:, source:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:source, source)
      dag_node_args = {
        'path' => path,
        'source' => source
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
      end
      Directory.new(self, @client, 'withFile', dag_node_args)
    end

    # Retrieves this directory plus the contents of the given files copied to the given path.
    # @param path - Location where copied files should be placed (e.g., "/src").
    # @param sources - Identifiers of the files to copy.
    # @param opts - Optional arguments
    sig { params(path: String, sources: T::Array[File], opts: T.nilable(DirectoryWithFilesOpts)).returns(Directory) }
    def with_files(path:, sources:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:sources, sources)
      dag_node_args = {
        'path' => path,
        'sources' => sources
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
      end
      Directory.new(self, @client, 'withFiles', dag_node_args)
    end

    # Retrieves this directory plus a new directory created at the given path.
    # @param path - Location of the directory created (e.g., "/logs").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(DirectoryWithNewDirectoryOpts)).returns(Directory) }
    def with_new_directory(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
      end
      Directory.new(self, @client, 'withNewDirectory', dag_node_args)
    end

    # Retrieves this directory plus a new file written at the given path.
    # @param path - Location of the written file (e.g., "/file.txt").
    # @param contents - Content of the written file (e.g., "Hello world!").
    # @param opts - Optional arguments
    sig { params(path: String, contents: String, opts: T.nilable(DirectoryWithNewFileOpts)).returns(Directory) }
    def with_new_file(path:, contents:, opts: nil)
      assert_not_nil(:path, path)
      assert_not_nil(:contents, contents)
      dag_node_args = {
        'path' => path,
        'contents' => contents
      }
      unless opts.nil?
        dag_node_args['permissions'] = opts.permissions unless opts.permissions.nil?
      end
      Directory.new(self, @client, 'withNewFile', dag_node_args)
    end

    # Retrieves this directory with all file/dir timestamps set to the given time.
    # @param timestamp - Timestamp to set dir/files in.
    #
    # Formatted in seconds following Unix epoch (e.g., 1672531199).
    sig { params(timestamp: Integer).returns(Directory) }
    def with_timestamps(timestamp:)
      assert_not_nil(:timestamp, timestamp)
      dag_node_args = {
        'timestamp' => timestamp
      }
      Directory.new(self, @client, 'withTimestamps', dag_node_args)
    end

    # Retrieves this directory with the directory at the given path removed.
    # @param path - Location of the directory to remove (e.g., ".github/").
    sig { params(path: String).returns(Directory) }
    def without_directory(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      Directory.new(self, @client, 'withoutDirectory', dag_node_args)
    end

    # Retrieves this directory with the file at the given path removed.
    # @param path - Location of the file to remove (e.g., "/file.txt").
    sig { params(path: String).returns(Directory) }
    def without_file(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      Directory.new(self, @client, 'withoutFile', dag_node_args)
    end

    # Retrieves this directory with the files at the given paths removed.
    # @param paths - Location of the file to remove (e.g., ["/file.txt"]).
    sig { params(paths: T::Array[String]).returns(Directory) }
    def without_files(paths:)
      assert_not_nil(:paths, paths)
      dag_node_args = {
        'paths' => paths
      }
      Directory.new(self, @client, 'withoutFiles', dag_node_args)
    end

    sig { params(_blk: DirectoryChain).returns(Directory) }
    def with(&_blk)
      yield self
    end
  end

  # The Dagger engine configuration and state
  class Engine < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The local (on-disk) cache for the Dagger engine
    sig { returns(EngineCache) }
    def local_cache
      EngineCache.new(self, @client, 'localCache')
    end
  end

  # A cache storage for the Dagger engine
  class EngineCache < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The current set of entries in the cache
    sig { returns(EngineCacheEntrySet) }
    def entry_set
      EngineCacheEntrySet.new(self, @client, 'entrySet')
    end

    # The maximum bytes to keep in the cache without pruning, after which automatic pruning may kick in.
    # @deprecated Use minFreeSpace instead.
    sig { returns(Integer) }
    def keep_bytes
      n = EngineCache.new(self, @client, 'keepBytes')
      @client.invoke(n)
    end

    # The maximum bytes to keep in the cache without pruning.
    sig { returns(Integer) }
    def max_used_space
      n = EngineCache.new(self, @client, 'maxUsedSpace')
      @client.invoke(n)
    end

    # The target amount of free disk space the garbage collector will attempt to leave.
    sig { returns(Integer) }
    def min_free_space
      n = EngineCache.new(self, @client, 'minFreeSpace')
      @client.invoke(n)
    end

    # Prune the cache of releaseable entries
    sig { returns(Void) }
    def prune
      n = EngineCache.new(self, @client, 'prune')
      @client.invoke(n)
    end

    sig { returns(Integer) }
    def reserved_space
      n = EngineCache.new(self, @client, 'reservedSpace')
      @client.invoke(n)
    end
  end

  # An individual cache entry in a cache entry set
  class EngineCacheEntry < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Whether the cache entry is actively being used.
    sig { returns(T::Boolean) }
    def actively_used
      n = EngineCacheEntry.new(self, @client, 'activelyUsed')
      @client.invoke(n)
    end

    # The time the cache entry was created, in Unix nanoseconds.
    sig { returns(Integer) }
    def created_time_unix_nano
      n = EngineCacheEntry.new(self, @client, 'createdTimeUnixNano')
      @client.invoke(n)
    end

    # The description of the cache entry.
    sig { returns(String) }
    def description
      n = EngineCacheEntry.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The disk space used by the cache entry.
    sig { returns(Integer) }
    def disk_space_bytes
      n = EngineCacheEntry.new(self, @client, 'diskSpaceBytes')
      @client.invoke(n)
    end

    # The most recent time the cache entry was used, in Unix nanoseconds.
    sig { returns(Integer) }
    def most_recent_use_time_unix_nano
      n = EngineCacheEntry.new(self, @client, 'mostRecentUseTimeUnixNano')
      @client.invoke(n)
    end
  end

  # A set of cache entries returned by a query to a cache
  class EngineCacheEntrySet < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The total disk space used by the cache entries in this set.
    sig { returns(Integer) }
    def disk_space_bytes
      n = EngineCacheEntrySet.new(self, @client, 'diskSpaceBytes')
      @client.invoke(n)
    end

    # The list of individual cache entries in the set
    sig { returns(T::Array[EngineCacheEntry]) }
    def entries
      n = EngineCacheEntrySet.new(self, @client, 'entries')
      @client.invoke(n)
    end

    # The number of cache entries in this set.
    sig { returns(Integer) }
    def entry_count
      n = EngineCacheEntrySet.new(self, @client, 'entryCount')
      @client.invoke(n)
    end
  end

  # A definition of a custom enum defined in a Module.
  class EnumTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # A doc string for the enum, if any.
    sig { returns(String) }
    def description
      n = EnumTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The name of the enum.
    sig { returns(String) }
    def name
      n = EnumTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this enum declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # If this EnumTypeDef is associated with a Module, the name of the module. Unset otherwise.
    sig { returns(String) }
    def source_module_name
      n = EnumTypeDef.new(self, @client, 'sourceModuleName')
      @client.invoke(n)
    end

    # The values of the enum.
    sig { returns(T::Array[EnumValueTypeDef]) }
    def values
      n = EnumTypeDef.new(self, @client, 'values')
      @client.invoke(n)
    end
  end

  # A definition of a value in a custom enum defined in a Module.
  class EnumValueTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # A doc string for the enum value, if any.
    sig { returns(String) }
    def description
      n = EnumValueTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The name of the enum value.
    sig { returns(String) }
    def name
      n = EnumValueTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this enum value declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end
  end

  # An environment variable name and value.
  class EnvVariable < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The environment variable name.
    sig { returns(String) }
    def name
      n = EnvVariable.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The environment variable value.
    sig { returns(String) }
    def value
      n = EnvVariable.new(self, @client, 'value')
      @client.invoke(n)
    end
  end

  # Error class
  class Error < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # A description of the error.
    sig { returns(String) }
    def message
      n = Error.new(self, @client, 'message')
      @client.invoke(n)
    end
  end

  # A definition of a field on a custom object defined in a Module.
  #
  # A field on an object has a static value, as opposed to a function on an object whose value is computed by invoking code (and can accept arguments).
  class FieldTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # A doc string for the field, if any.
    sig { returns(String) }
    def description
      n = FieldTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The name of the field in lowerCamelCase format.
    sig { returns(String) }
    def name
      n = FieldTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this field declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # The type of the field.
    sig { returns(TypeDef) }
    def type_def
      TypeDef.new(self, @client, 'typeDef')
    end
  end

  # Optional arguments for digest on File
  class FileDigestOpts
    extend T::Sig

    # If true, exclude metadata from the digest.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :exclude_metadata
  end

  # Optional arguments for export on File
  class FileExportOpts
    extend T::Sig

    # If allowParentDirPath is true, the path argument can be a directory path, in which case the file will be created in that directory.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :allow_parent_dir_path
  end

  # A file.
  class File < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Retrieves the contents of the file.
    sig { returns(String) }
    def contents
      n = File.new(self, @client, 'contents')
      @client.invoke(n)
    end

    # Return the file's digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(FileDigestOpts)).returns(String) }
    def digest(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['excludeMetadata'] = opts.exclude_metadata unless opts.exclude_metadata.nil?
      end
      n = File.new(self, @client, 'digest', dag_node_args)
      @client.invoke(n)
    end

    # Writes the file to a file path on the host.
    # @param path - Location of the written directory (e.g., "output.txt").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(FileExportOpts)).returns(String) }
    def export(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['allowParentDirPath'] = opts.allow_parent_dir_path unless opts.allow_parent_dir_path.nil?
      end
      n = File.new(self, @client, 'export', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves the name of the file.
    sig { returns(String) }
    def name
      n = File.new(self, @client, 'name')
      @client.invoke(n)
    end

    # Retrieves the size of the file, in bytes.
    sig { returns(Integer) }
    def size
      n = File.new(self, @client, 'size')
      @client.invoke(n)
    end

    # Force evaluation in the engine.
    sig { returns(FileID) }
    def sync
      n = File.new(self, @client, 'sync')
      @client.invoke(n)
    end

    # Retrieves this file with its name set to the given name.
    # @param name - Name to set file to.
    sig { params(name: String).returns(File) }
    def with_name(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      File.new(self, @client, 'withName', dag_node_args)
    end

    # Retrieves this file with its created/modified timestamps set to the given time.
    # @param timestamp - Timestamp to set dir/files in.
    #
    # Formatted in seconds following Unix epoch (e.g., 1672531199).
    sig { params(timestamp: Integer).returns(File) }
    def with_timestamps(timestamp:)
      assert_not_nil(:timestamp, timestamp)
      dag_node_args = {
        'timestamp' => timestamp
      }
      File.new(self, @client, 'withTimestamps', dag_node_args)
    end

    sig { params(_blk: FileChain).returns(File) }
    def with(&_blk)
      yield self
    end
  end

  # Optional arguments for with_arg on Function
  class FunctionWithArgOpts
    extend T::Sig

    # A doc string for the argument, if any
    sig { returns(T.nilable(String)) }
    attr_accessor :description

    # A default value to use for this argument if not explicitly set by the caller, if any
    sig { returns(T.nilable(JSON)) }
    attr_accessor :default_value

    # If the argument is a Directory or File type, default to load path from context directory, relative to root directory.
    sig { returns(T.nilable(String)) }
    attr_accessor :default_path

    # Patterns to ignore when loading the contextual argument value.
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :ignore

    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Function represents a resolver provided by a Module.
  #
  # A function always evaluates against a parent object and is given a set of named arguments.
  class Function < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Arguments accepted by the function, if any.
    sig { returns(T::Array[FunctionArg]) }
    def args
      n = Function.new(self, @client, 'args')
      @client.invoke(n)
    end

    # A doc string for the function, if any.
    sig { returns(String) }
    def description
      n = Function.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The name of the function.
    sig { returns(String) }
    def name
      n = Function.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The type returned by the function.
    sig { returns(TypeDef) }
    def return_type
      TypeDef.new(self, @client, 'returnType')
    end

    # The location of this function declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # Returns the function with the provided argument
    # @param name - The name of the argument
    # @param type_def - The type of the argument
    # @param opts - Optional arguments
    sig { params(name: String, type_def: TypeDef, opts: T.nilable(FunctionWithArgOpts)).returns(Function) }
    def with_arg(name:, type_def:, opts: nil)
      assert_not_nil(:name, name)
      assert_not_nil(:type_def, type_def)
      dag_node_args = {
        'name' => name,
        'typeDef' => type_def
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['defaultValue'] = opts.default_value unless opts.default_value.nil?
        dag_node_args['defaultPath'] = opts.default_path unless opts.default_path.nil?
        dag_node_args['ignore'] = opts.ignore unless opts.ignore.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      Function.new(self, @client, 'withArg', dag_node_args)
    end

    # Returns the function with the given doc string.
    # @param description - The doc string to set.
    sig { params(description: String).returns(Function) }
    def with_description(description:)
      assert_not_nil(:description, description)
      dag_node_args = {
        'description' => description
      }
      Function.new(self, @client, 'withDescription', dag_node_args)
    end

    # Returns the function with the given source map.
    # @param source_map - The source map for the function definition.
    sig { params(source_map: SourceMap).returns(Function) }
    def with_source_map(source_map:)
      assert_not_nil(:source_map, source_map)
      dag_node_args = {
        'sourceMap' => source_map
      }
      Function.new(self, @client, 'withSourceMap', dag_node_args)
    end

    sig { params(_blk: FunctionChain).returns(Function) }
    def with(&_blk)
      yield self
    end
  end

  # An argument accepted by a function.
  #
  # This is a specification for an argument at function definition time, not an argument passed at function call time.
  class FunctionArg < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Only applies to arguments of type File or Directory. If the argument is not set, load it from the given path in the context directory
    sig { returns(String) }
    def default_path
      n = FunctionArg.new(self, @client, 'defaultPath')
      @client.invoke(n)
    end

    # A default value to use for this argument when not explicitly set by the caller, if any.
    sig { returns(JSON) }
    def default_value
      n = FunctionArg.new(self, @client, 'defaultValue')
      @client.invoke(n)
    end

    # A doc string for the argument, if any.
    sig { returns(String) }
    def description
      n = FunctionArg.new(self, @client, 'description')
      @client.invoke(n)
    end

    # Only applies to arguments of type Directory. The ignore patterns are applied to the input directory, and matching entries are filtered out, in a cache-efficient manner.
    sig { returns(T::Array[String]) }
    def ignore
      n = FunctionArg.new(self, @client, 'ignore')
      @client.invoke(n)
    end

    # The name of the argument in lowerCamelCase format.
    sig { returns(String) }
    def name
      n = FunctionArg.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this arg declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # The type of the argument.
    sig { returns(TypeDef) }
    def type_def
      TypeDef.new(self, @client, 'typeDef')
    end
  end

  # An active function call.
  class FunctionCall < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The argument values the function is being invoked with.
    sig { returns(T::Array[FunctionCallArgValue]) }
    def input_args
      n = FunctionCall.new(self, @client, 'inputArgs')
      @client.invoke(n)
    end

    # The name of the function being called.
    sig { returns(String) }
    def name
      n = FunctionCall.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The value of the parent object of the function being called. If the function is top-level to the module, this is always an empty object.
    sig { returns(JSON) }
    def parent
      n = FunctionCall.new(self, @client, 'parent')
      @client.invoke(n)
    end

    # The name of the parent object of the function being called. If the function is top-level to the module, this is the name of the module.
    sig { returns(String) }
    def parent_name
      n = FunctionCall.new(self, @client, 'parentName')
      @client.invoke(n)
    end

    # Return an error from the function.
    # @param error - The error to return.
    sig { params(error: Error).returns(Void) }
    def return_error(error:)
      assert_not_nil(:error, error)
      dag_node_args = {
        'error' => error
      }
      n = FunctionCall.new(self, @client, 'returnError', dag_node_args)
      @client.invoke(n)
    end

    # Set the return value of the function call to the provided value.
    # @param value - JSON serialization of the return value.
    sig { params(value: JSON).returns(Void) }
    def return_value(value:)
      assert_not_nil(:value, value)
      dag_node_args = {
        'value' => value
      }
      n = FunctionCall.new(self, @client, 'returnValue', dag_node_args)
      @client.invoke(n)
    end
  end

  # A value passed as a named argument to a function call.
  class FunctionCallArgValue < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The name of the argument.
    sig { returns(String) }
    def name
      n = FunctionCallArgValue.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The value of the argument represented as a JSON serialized string.
    sig { returns(JSON) }
    def value
      n = FunctionCallArgValue.new(self, @client, 'value')
      @client.invoke(n)
    end
  end

  # The result of running an SDK's codegen.
  class GeneratedCode < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The directory containing the generated code.
    sig { returns(Directory) }
    def code
      Directory.new(self, @client, 'code')
    end

    # List of paths to mark generated in version control (i.e. .gitattributes).
    sig { returns(T::Array[String]) }
    def vcs_generated_paths
      n = GeneratedCode.new(self, @client, 'vcsGeneratedPaths')
      @client.invoke(n)
    end

    # List of paths to ignore in version control (i.e. .gitignore).
    sig { returns(T::Array[String]) }
    def vcs_ignored_paths
      n = GeneratedCode.new(self, @client, 'vcsIgnoredPaths')
      @client.invoke(n)
    end

    # Set the list of paths to mark generated in version control.
    sig { params(paths: T::Array[String]).returns(GeneratedCode) }
    def with_vcs_generated_paths(paths:)
      assert_not_nil(:paths, paths)
      dag_node_args = {
        'paths' => paths
      }
      GeneratedCode.new(self, @client, 'withVCSGeneratedPaths', dag_node_args)
    end

    # Set the list of paths to ignore in version control.
    sig { params(paths: T::Array[String]).returns(GeneratedCode) }
    def with_vcs_ignored_paths(paths:)
      assert_not_nil(:paths, paths)
      dag_node_args = {
        'paths' => paths
      }
      GeneratedCode.new(self, @client, 'withVCSIgnoredPaths', dag_node_args)
    end

    sig { params(_blk: GeneratedCodeChain).returns(GeneratedCode) }
    def with(&_blk)
      yield self
    end
  end

  # Module source originating from a git repo.
  class GitModuleSource < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The ref to clone the root of the git repo from
    sig { returns(String) }
    def clone_ref
      n = GitModuleSource.new(self, @client, 'cloneRef')
      @client.invoke(n)
    end

    # The resolved commit of the git repo this source points to.
    sig { returns(String) }
    def commit
      n = GitModuleSource.new(self, @client, 'commit')
      @client.invoke(n)
    end

    # The directory containing everything needed to load load and use the module.
    sig { returns(Directory) }
    def context_directory
      Directory.new(self, @client, 'contextDirectory')
    end

    # The URL to access the web view of the repository (e.g., GitHub, GitLab, Bitbucket)
    sig { returns(String) }
    def html_repo_url
      n = GitModuleSource.new(self, @client, 'htmlRepoURL')
      @client.invoke(n)
    end

    # The URL to the source's git repo in a web browser
    sig { returns(String) }
    def html_url
      n = GitModuleSource.new(self, @client, 'htmlURL')
      @client.invoke(n)
    end

    # The clean module name of the root of the module
    sig { returns(String) }
    def root
      n = GitModuleSource.new(self, @client, 'root')
      @client.invoke(n)
    end

    # The path to the root of the module source under the context directory. This directory contains its configuration file. It also contains its source code (possibly as a subdirectory).
    sig { returns(String) }
    def root_subpath
      n = GitModuleSource.new(self, @client, 'rootSubpath')
      @client.invoke(n)
    end

    # The specified version of the git repo this source points to.
    sig { returns(String) }
    def version
      n = GitModuleSource.new(self, @client, 'version')
      @client.invoke(n)
    end
  end

  # Optional arguments for tree on GitRef
  class GitRefTreeOpts
    extend T::Sig

    # Set to true to discard .git directory.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :discard_git_dir
  end

  # A git ref (tag, branch, or commit).
  class GitRef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The resolved commit id at this ref.
    sig { returns(String) }
    def commit
      n = GitRef.new(self, @client, 'commit')
      @client.invoke(n)
    end

    # The filesystem tree at this ref.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(GitRefTreeOpts)).returns(Directory) }
    def tree(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['discardGitDir'] = opts.discard_git_dir unless opts.discard_git_dir.nil?
      end
      Directory.new(self, @client, 'tree', dag_node_args)
    end
  end

  # Optional arguments for tags on GitRepository
  class GitRepositoryTagsOpts
    extend T::Sig

    # Glob patterns (e.g., "refs/tags/v*").
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :patterns
  end

  # A git repository.
  class GitRepository < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Returns details of a branch.
    # @param name - Branch's name (e.g., "main").
    sig { params(name: String).returns(GitRef) }
    def branch(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      GitRef.new(self, @client, 'branch', dag_node_args)
    end

    # Returns details of a commit.
    # @param id - Identifier of the commit (e.g., "b6315d8f2810962c601af73f86831f6866ea798b").
    sig { params(id: String).returns(GitRef) }
    def commit(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      GitRef.new(self, @client, 'commit', dag_node_args)
    end

    # Returns details for HEAD.
    sig { returns(GitRef) }
    def head
      GitRef.new(self, @client, 'head')
    end

    # Returns details of a ref.
    # @param name - Ref's name (can be a commit identifier, a tag name, a branch name, or a fully-qualified ref).
    sig { params(name: String).returns(GitRef) }
    def ref(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      GitRef.new(self, @client, 'ref', dag_node_args)
    end

    # Returns details of a tag.
    # @param name - Tag's name (e.g., "v0.3.9").
    sig { params(name: String).returns(GitRef) }
    def tag(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      GitRef.new(self, @client, 'tag', dag_node_args)
    end

    # tags that match any of the given glob patterns.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(GitRepositoryTagsOpts)).returns(T::Array[String]) }
    def tags(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['patterns'] = opts.patterns unless opts.patterns.nil?
      end
      n = GitRepository.new(self, @client, 'tags', dag_node_args)
      @client.invoke(n)
    end

    # Header to authenticate the remote with.
    # @param header - Secret used to populate the Authorization HTTP header
    sig { params(header: Secret).returns(GitRepository) }
    def with_auth_header(header:)
      assert_not_nil(:header, header)
      dag_node_args = {
        'header' => header
      }
      GitRepository.new(self, @client, 'withAuthHeader', dag_node_args)
    end

    # Token to authenticate the remote with.
    # @param token - Secret used to populate the password during basic HTTP Authorization
    sig { params(token: Secret).returns(GitRepository) }
    def with_auth_token(token:)
      assert_not_nil(:token, token)
      dag_node_args = {
        'token' => token
      }
      GitRepository.new(self, @client, 'withAuthToken', dag_node_args)
    end

    sig { params(_blk: GitRepositoryChain).returns(GitRepository) }
    def with(&_blk)
      yield self
    end
  end

  # Optional arguments for directory on Host
  class HostDirectoryOpts
    extend T::Sig

    # Exclude artifacts that match the given pattern (e.g., ["node_modules/", ".git*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :exclude

    # Include only artifacts that match the given pattern (e.g., ["app/", "package.*"]).
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :include
  end

  # Optional arguments for service on Host
  class HostServiceOpts
    extend T::Sig

    # Upstream host to forward traffic to.
    sig { returns(T.nilable(String)) }
    attr_accessor :host

    # Ports to expose via the service, forwarding through the host network.
    #
    # If a port's frontend is unspecified or 0, it defaults to the same as the backend port.
    #
    # An empty set of ports is not valid; an error will be returned.
    # Warning: type is set as optional to simplify generated code but this field is required!
    sig { returns(T.nilable(T::Array[PortForward])) }
    attr_accessor :ports
  end

  # Optional arguments for tunnel on Host
  class HostTunnelOpts
    extend T::Sig

    # Configure explicit port forwarding rules for the tunnel.
    #
    # If a port's frontend is unspecified or 0, a random port will be chosen by the host.
    #
    # If no ports are given, all of the service's ports are forwarded. If native is true, each port maps to the same port on the host. If native is false, each port maps to a random port chosen by the host.
    #
    # If ports are given and native is true, the ports are additive.
    sig { returns(T.nilable(T::Array[PortForward])) }
    attr_accessor :ports

    # Map each service port to the same port on the host, as if the service were running natively.
    #
    # Note: enabling may result in port conflicts.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :native
  end

  # Information about the host environment.
  class Host < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Accesses a directory on the host.
    # @param path - Location of the directory to access (e.g., ".").
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(HostDirectoryOpts)).returns(Directory) }
    def directory(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['exclude'] = opts.exclude unless opts.exclude.nil?
        dag_node_args['include'] = opts.include unless opts.include.nil?
      end
      Directory.new(self, @client, 'directory', dag_node_args)
    end

    # Accesses a file on the host.
    # @param path - Location of the file to retrieve (e.g., "README.md").
    sig { params(path: String).returns(File) }
    def file(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      File.new(self, @client, 'file', dag_node_args)
    end

    # Creates a service that forwards traffic to a specified address via the host.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(HostServiceOpts)).returns(Service) }
    def service(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['host'] = opts.host unless opts.host.nil?
        dag_node_args['ports'] = opts.ports unless opts.ports.nil?
      end
      Service.new(self, @client, 'service', dag_node_args)
    end

    # Sets a secret given a user-defined name and the file path on the host, and returns the secret.
    #
    # The file is limited to a size of 512000 bytes.
    # @param name - The user defined name for this secret.
    # @param path - Location of the file to set as a secret.
    sig { params(name: String, path: String).returns(Secret) }
    def set_secret_file(name:, path:)
      assert_not_nil(:name, name)
      assert_not_nil(:path, path)
      dag_node_args = {
        'name' => name,
        'path' => path
      }
      Secret.new(self, @client, 'setSecretFile', dag_node_args)
    end

    # Creates a tunnel that forwards traffic from the host to a service.
    # @param service - Service to send traffic from the tunnel.
    # @param opts - Optional arguments
    sig { params(service: Service, opts: T.nilable(HostTunnelOpts)).returns(Service) }
    def tunnel(service:, opts: nil)
      assert_not_nil(:service, service)
      dag_node_args = {
        'service' => service
      }
      unless opts.nil?
        dag_node_args['ports'] = opts.ports unless opts.ports.nil?
        dag_node_args['native'] = opts.native unless opts.native.nil?
      end
      Service.new(self, @client, 'tunnel', dag_node_args)
    end

    # Accesses a Unix socket on the host.
    # @param path - Location of the Unix socket (e.g., "/var/run/docker.sock").
    sig { params(path: String).returns(Socket) }
    def unix_socket(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      Socket.new(self, @client, 'unixSocket', dag_node_args)
    end
  end

  # A graphql input type, which is essentially just a group of named args.
  # This is currently only used to represent pre-existing usage of graphql input types
  # in the core API. It is not used by user modules and shouldn't ever be as user
  # module accept input objects via their id rather than graphql input types.
  class InputTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Static fields defined on this input object, if any.
    sig { returns(T::Array[FieldTypeDef]) }
    def fields
      n = InputTypeDef.new(self, @client, 'fields')
      @client.invoke(n)
    end

    # The name of the input object.
    sig { returns(String) }
    def name
      n = InputTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end
  end

  # A definition of a custom interface defined in a Module.
  class InterfaceTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The doc string for the interface, if any.
    sig { returns(String) }
    def description
      n = InterfaceTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # Functions defined on this interface, if any.
    sig { returns(T::Array[Function]) }
    def functions
      n = InterfaceTypeDef.new(self, @client, 'functions')
      @client.invoke(n)
    end

    # The name of the interface.
    sig { returns(String) }
    def name
      n = InterfaceTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this interface declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # If this InterfaceTypeDef is associated with a Module, the name of the module. Unset otherwise.
    sig { returns(String) }
    def source_module_name
      n = InterfaceTypeDef.new(self, @client, 'sourceModuleName')
      @client.invoke(n)
    end
  end

  # A simple key value object that represents a label.
  class Label < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The label name.
    sig { returns(String) }
    def name
      n = Label.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The label value.
    sig { returns(String) }
    def value
      n = Label.new(self, @client, 'value')
      @client.invoke(n)
    end
  end

  # A definition of a list type in a Module.
  class ListTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The type of the elements in the list.
    sig { returns(TypeDef) }
    def element_type_def
      TypeDef.new(self, @client, 'elementTypeDef')
    end
  end

  # Module source that that originates from a path locally relative to an arbitrary directory.
  class LocalModuleSource < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The directory containing everything needed to load load and use the module.
    sig { returns(Directory) }
    def context_directory
      Directory.new(self, @client, 'contextDirectory')
    end

    # The relative path to the module root from the host directory
    sig { returns(String) }
    def rel_host_path
      n = LocalModuleSource.new(self, @client, 'relHostPath')
      @client.invoke(n)
    end

    # The path to the root of the module source under the context directory. This directory contains its configuration file. It also contains its source code (possibly as a subdirectory).
    sig { returns(String) }
    def root_subpath
      n = LocalModuleSource.new(self, @client, 'rootSubpath')
      @client.invoke(n)
    end
  end

  # Optional arguments for with_source on Module_
  class ModuleWithSourceOpts
    extend T::Sig

    # The engine version to upgrade to.
    sig { returns(T.nilable(String)) }
    attr_accessor :engine_version
  end

  # A Dagger module.
  class Module_ < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Modules used by this module.
    sig { returns(T::Array[Module_]) }
    def dependencies
      n = Module_.new(self, @client, 'dependencies')
      @client.invoke(n)
    end

    # The dependencies as configured by the module.
    sig { returns(T::Array[ModuleDependency]) }
    def dependency_config
      n = Module_.new(self, @client, 'dependencyConfig')
      @client.invoke(n)
    end

    # The doc string of the module, if any
    sig { returns(String) }
    def description
      n = Module_.new(self, @client, 'description')
      @client.invoke(n)
    end

    # Enumerations served by this module.
    sig { returns(T::Array[TypeDef]) }
    def enums
      n = Module_.new(self, @client, 'enums')
      @client.invoke(n)
    end

    # The generated files and directories made on top of the module source's context directory.
    sig { returns(Directory) }
    def generated_context_diff
      Directory.new(self, @client, 'generatedContextDiff')
    end

    # The module source's context plus any configuration and source files created by codegen.
    sig { returns(Directory) }
    def generated_context_directory
      Directory.new(self, @client, 'generatedContextDirectory')
    end

    # Retrieves the module with the objects loaded via its SDK.
    sig { returns(Module_) }
    def initialize_
      Module_.new(self, @client, 'initialize')
    end

    # Interfaces served by this module.
    sig { returns(T::Array[TypeDef]) }
    def interfaces
      n = Module_.new(self, @client, 'interfaces')
      @client.invoke(n)
    end

    # The name of the module
    sig { returns(String) }
    def name
      n = Module_.new(self, @client, 'name')
      @client.invoke(n)
    end

    # Objects served by this module.
    sig { returns(T::Array[TypeDef]) }
    def objects
      n = Module_.new(self, @client, 'objects')
      @client.invoke(n)
    end

    # The container that runs the module's entrypoint. It will fail to execute if the module doesn't compile.
    sig { returns(Container) }
    def runtime
      Container.new(self, @client, 'runtime')
    end

    # The SDK used by this module. Either a name of a builtin SDK or a module source ref string pointing to the SDK's implementation.
    sig { returns(String) }
    def sdk
      n = Module_.new(self, @client, 'sdk')
      @client.invoke(n)
    end

    # Serve a module's API in the current session.
    #
    # Note: this can only be called once per session. In the future, it could return a stream or service to remove the side effect.
    sig { returns(Void) }
    def serve
      n = Module_.new(self, @client, 'serve')
      @client.invoke(n)
    end

    # The source for the module.
    sig { returns(ModuleSource) }
    def source
      ModuleSource.new(self, @client, 'source')
    end

    # Retrieves the module with the given description
    # @param description - The description to set
    sig { params(description: String).returns(Module_) }
    def with_description(description:)
      assert_not_nil(:description, description)
      dag_node_args = {
        'description' => description
      }
      Module_.new(self, @client, 'withDescription', dag_node_args)
    end

    # This module plus the given Enum type and associated values
    sig { params(enum: TypeDef).returns(Module_) }
    def with_enum(enum:)
      assert_not_nil(:enum, enum)
      dag_node_args = {
        'enum' => enum
      }
      Module_.new(self, @client, 'withEnum', dag_node_args)
    end

    # This module plus the given Interface type and associated functions
    sig { params(iface: TypeDef).returns(Module_) }
    def with_interface(iface:)
      assert_not_nil(:iface, iface)
      dag_node_args = {
        'iface' => iface
      }
      Module_.new(self, @client, 'withInterface', dag_node_args)
    end

    # This module plus the given Object type and associated functions.
    sig { params(object: TypeDef).returns(Module_) }
    def with_object(object:)
      assert_not_nil(:object, object)
      dag_node_args = {
        'object' => object
      }
      Module_.new(self, @client, 'withObject', dag_node_args)
    end

    # Retrieves the module with basic configuration loaded if present.
    # @param source - The module source to initialize from.
    # @param opts - Optional arguments
    sig { params(source: ModuleSource, opts: T.nilable(ModuleWithSourceOpts)).returns(Module_) }
    def with_source(source:, opts: nil)
      assert_not_nil(:source, source)
      dag_node_args = {
        'source' => source
      }
      unless opts.nil?
        dag_node_args['engineVersion'] = opts.engine_version unless opts.engine_version.nil?
      end
      Module_.new(self, @client, 'withSource', dag_node_args)
    end

    sig { params(_blk: ModuleChain).returns(Module_) }
    def with(&_blk)
      yield self
    end
  end

  # The configuration of dependency of a module.
  class ModuleDependency < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The name of the dependency module.
    sig { returns(String) }
    def name
      n = ModuleDependency.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The source for the dependency module.
    sig { returns(ModuleSource) }
    def source
      ModuleSource.new(self, @client, 'source')
    end
  end

  # Optional arguments for as_module on ModuleSource
  class ModuleSourceAsModuleOpts
    extend T::Sig

    # The engine version to upgrade to.
    sig { returns(T.nilable(String)) }
    attr_accessor :engine_version
  end

  # Optional arguments for resolve_directory_from_caller on ModuleSource
  class ModuleSourceResolveDirectoryFromCallerOpts
    extend T::Sig

    # If set, the name of the view to apply to the path.
    sig { returns(T.nilable(String)) }
    attr_accessor :view_name

    # Patterns to ignore when loading the directory.
    sig { returns(T.nilable(T::Array[String])) }
    attr_accessor :ignore
  end

  # Optional arguments for with_init on ModuleSource
  class ModuleSourceWithInitOpts
    extend T::Sig

    # Merge module dependencies into the current project's
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :merge
  end

  # The source needed to load and run a module, along with any metadata about the source such as versions/urls/etc.
  class ModuleSource < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # If the source is a of kind git, the git source representation of it.
    sig { returns(GitModuleSource) }
    def as_git_source
      GitModuleSource.new(self, @client, 'asGitSource')
    end

    # If the source is of kind local, the local source representation of it.
    sig { returns(LocalModuleSource) }
    def as_local_source
      LocalModuleSource.new(self, @client, 'asLocalSource')
    end

    # Load the source as a module. If this is a local source, the parent directory must have been provided during module source creation
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ModuleSourceAsModuleOpts)).returns(Module_) }
    def as_module(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['engineVersion'] = opts.engine_version unless opts.engine_version.nil?
      end
      Module_.new(self, @client, 'asModule', dag_node_args)
    end

    # A human readable ref string representation of this module source.
    sig { returns(String) }
    def as_string
      n = ModuleSource.new(self, @client, 'asString')
      @client.invoke(n)
    end

    # Returns whether the module source has a configuration file.
    sig { returns(T::Boolean) }
    def config_exists
      n = ModuleSource.new(self, @client, 'configExists')
      @client.invoke(n)
    end

    # The directory containing everything needed to load load and use the module.
    sig { returns(Directory) }
    def context_directory
      Directory.new(self, @client, 'contextDirectory')
    end

    # The effective module source dependencies from the configuration, and calls to withDependencies and withoutDependencies.
    sig { returns(T::Array[ModuleDependency]) }
    def dependencies
      n = ModuleSource.new(self, @client, 'dependencies')
      @client.invoke(n)
    end

    # Return the module source's content digest. The format of the digest is not guaranteed to be stable between releases of Dagger. It is guaranteed to be stable between invocations of the same Dagger engine.
    sig { returns(String) }
    def digest
      n = ModuleSource.new(self, @client, 'digest')
      @client.invoke(n)
    end

    # The directory containing the module configuration and source code (source code may be in a subdir).
    # @param path - The path from the source directory to select.
    sig { params(path: String).returns(Directory) }
    def directory(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      Directory.new(self, @client, 'directory', dag_node_args)
    end

    # The kind of source (e.g. local, git, etc.)
    sig { returns(ModuleSourceKind) }
    def kind
      n = ModuleSource.new(self, @client, 'kind')
      @client.invoke(n)
    end

    # If set, the name of the module this source references, including any overrides at runtime by callers.
    sig { returns(String) }
    def module_name
      n = ModuleSource.new(self, @client, 'moduleName')
      @client.invoke(n)
    end

    # The original name of the module this source references, as defined in the module configuration.
    sig { returns(String) }
    def module_original_name
      n = ModuleSource.new(self, @client, 'moduleOriginalName')
      @client.invoke(n)
    end

    # The path to the module source's context directory on the caller's filesystem. Only valid for local sources.
    sig { returns(String) }
    def resolve_context_path_from_caller
      n = ModuleSource.new(self, @client, 'resolveContextPathFromCaller')
      @client.invoke(n)
    end

    # Resolve the provided module source arg as a dependency relative to this module source.
    # @param dep - The dependency module source to resolve.
    sig { params(dep: ModuleSource).returns(ModuleSource) }
    def resolve_dependency(dep:)
      assert_not_nil(:dep, dep)
      dag_node_args = {
        'dep' => dep
      }
      ModuleSource.new(self, @client, 'resolveDependency', dag_node_args)
    end

    # Load a directory from the caller optionally with a given view applied.
    # @param path - The path on the caller's filesystem to load.
    # @param opts - Optional arguments
    sig { params(path: String, opts: T.nilable(ModuleSourceResolveDirectoryFromCallerOpts)).returns(Directory) }
    def resolve_directory_from_caller(path:, opts: nil)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      unless opts.nil?
        dag_node_args['viewName'] = opts.view_name unless opts.view_name.nil?
        dag_node_args['ignore'] = opts.ignore unless opts.ignore.nil?
      end
      Directory.new(self, @client, 'resolveDirectoryFromCaller', dag_node_args)
    end

    # Load the source from its path on the caller's filesystem, including only needed+configured files and directories. Only valid for local sources.
    sig { returns(ModuleSource) }
    def resolve_from_caller
      ModuleSource.new(self, @client, 'resolveFromCaller')
    end

    # The path relative to context of the root of the module source, which contains dagger.json. It also contains the module implementation source code, but that may or may not being a subdir of this root.
    sig { returns(String) }
    def source_root_subpath
      n = ModuleSource.new(self, @client, 'sourceRootSubpath')
      @client.invoke(n)
    end

    # The path relative to context of the module implementation source code.
    sig { returns(String) }
    def source_subpath
      n = ModuleSource.new(self, @client, 'sourceSubpath')
      @client.invoke(n)
    end

    # Retrieve a named view defined for this module source.
    # @param name - The name of the view to retrieve.
    sig { params(name: String).returns(ModuleSourceView) }
    def view(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      ModuleSourceView.new(self, @client, 'view', dag_node_args)
    end

    # The named views defined for this module source, which are sets of directory filters that can be applied to directory arguments provided to functions.
    sig { returns(T::Array[ModuleSourceView]) }
    def views
      n = ModuleSource.new(self, @client, 'views')
      @client.invoke(n)
    end

    # Update the module source with a new context directory. Only valid for local sources.
    # @param dir - The directory to set as the context directory.
    sig { params(dir: Directory).returns(ModuleSource) }
    def with_context_directory(dir:)
      assert_not_nil(:dir, dir)
      dag_node_args = {
        'dir' => dir
      }
      ModuleSource.new(self, @client, 'withContextDirectory', dag_node_args)
    end

    # Append the provided dependencies to the module source's dependency list.
    # @param dependencies - The dependencies to append.
    sig { params(dependencies: T::Array[ModuleDependency]).returns(ModuleSource) }
    def with_dependencies(dependencies:)
      assert_not_nil(:dependencies, dependencies)
      dag_node_args = {
        'dependencies' => dependencies
      }
      ModuleSource.new(self, @client, 'withDependencies', dag_node_args)
    end

    # Sets module init arguments
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ModuleSourceWithInitOpts)).returns(ModuleSource) }
    def with_init(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['merge'] = opts.merge unless opts.merge.nil?
      end
      ModuleSource.new(self, @client, 'withInit', dag_node_args)
    end

    # Update the module source with a new name.
    # @param name - The name to set.
    sig { params(name: String).returns(ModuleSource) }
    def with_name(name:)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      ModuleSource.new(self, @client, 'withName', dag_node_args)
    end

    # Update the module source with a new SDK.
    # @param sdk - The SDK to set.
    sig { params(sdk: String).returns(ModuleSource) }
    def with_sdk(sdk:)
      assert_not_nil(:sdk, sdk)
      dag_node_args = {
        'sdk' => sdk
      }
      ModuleSource.new(self, @client, 'withSDK', dag_node_args)
    end

    # Update the module source with a new source subpath.
    # @param path - The path to set as the source subpath.
    sig { params(path: String).returns(ModuleSource) }
    def with_source_subpath(path:)
      assert_not_nil(:path, path)
      dag_node_args = {
        'path' => path
      }
      ModuleSource.new(self, @client, 'withSourceSubpath', dag_node_args)
    end

    # Update the module source with a new named view.
    # @param name - The name of the view to set.
    # @param patterns - The patterns to set as the view filters.
    sig { params(name: String, patterns: T::Array[String]).returns(ModuleSource) }
    def with_view(name:, patterns:)
      assert_not_nil(:name, name)
      assert_not_nil(:patterns, patterns)
      dag_node_args = {
        'name' => name,
        'patterns' => patterns
      }
      ModuleSource.new(self, @client, 'withView', dag_node_args)
    end

    # Remove the provided dependencies from the module source's dependency list.
    # @param dependencies - The dependencies to remove.
    sig { params(dependencies: T::Array[String]).returns(ModuleSource) }
    def without_dependencies(dependencies:)
      assert_not_nil(:dependencies, dependencies)
      dag_node_args = {
        'dependencies' => dependencies
      }
      ModuleSource.new(self, @client, 'withoutDependencies', dag_node_args)
    end

    sig { params(_blk: ModuleSourceChain).returns(ModuleSource) }
    def with(&_blk)
      yield self
    end
  end

  # A named set of path filters that can be applied to directory arguments provided to functions.
  class ModuleSourceView < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The name of the view
    sig { returns(String) }
    def name
      n = ModuleSourceView.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The patterns of the view used to filter paths
    sig { returns(T::Array[String]) }
    def patterns
      n = ModuleSourceView.new(self, @client, 'patterns')
      @client.invoke(n)
    end
  end

  # A definition of a custom object defined in a Module.
  class ObjectTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The function used to construct new instances of this object, if any
    sig { returns(Function) }
    def constructor
      Function.new(self, @client, 'constructor')
    end

    # The doc string for the object, if any.
    sig { returns(String) }
    def description
      n = ObjectTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # Static fields defined on this object, if any.
    sig { returns(T::Array[FieldTypeDef]) }
    def fields
      n = ObjectTypeDef.new(self, @client, 'fields')
      @client.invoke(n)
    end

    # Functions defined on this object, if any.
    sig { returns(T::Array[Function]) }
    def functions
      n = ObjectTypeDef.new(self, @client, 'functions')
      @client.invoke(n)
    end

    # The name of the object.
    sig { returns(String) }
    def name
      n = ObjectTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The location of this object declaration.
    sig { returns(SourceMap) }
    def source_map
      SourceMap.new(self, @client, 'sourceMap')
    end

    # If this ObjectTypeDef is associated with a Module, the name of the module. Unset otherwise.
    sig { returns(String) }
    def source_module_name
      n = ObjectTypeDef.new(self, @client, 'sourceModuleName')
      @client.invoke(n)
    end
  end

  # Input GraphQL type PipelineLabel
  class PipelineLabel < T::Struct
    # Label name.
    prop :name, String

    # Label value.
    prop :value, String
  end

  # A port exposed by a container.
  class Port < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The port description.
    sig { returns(String) }
    def description
      n = Port.new(self, @client, 'description')
      @client.invoke(n)
    end

    # Skip the health check when run as a service.
    sig { returns(T::Boolean) }
    def experimental_skip_healthcheck
      n = Port.new(self, @client, 'experimentalSkipHealthcheck')
      @client.invoke(n)
    end

    # The port number.
    sig { returns(Integer) }
    def port
      n = Port.new(self, @client, 'port')
      @client.invoke(n)
    end

    # The transport layer protocol.
    sig { returns(NetworkProtocol) }
    def protocol
      n = Port.new(self, @client, 'protocol')
      @client.invoke(n)
    end
  end

  # Input GraphQL type PortForward
  class PortForward < T::Struct
    # Destination port for traffic.
    prop :backend, Integer

    # Port to expose to clients. If unspecified, a default will be chosen.
    prop :frontend, T.nilable(Integer)

    # Transport layer protocol to use for traffic.
    prop :protocol, T.nilable(NetworkProtocol)
  end

  # Optional arguments for container on Client
  class ClientContainerOpts
    extend T::Sig

    # Platform to initialize the container with.
    sig { returns(T.nilable(Platform)) }
    attr_accessor :platform
  end

  # Optional arguments for git on Client
  class ClientGitOpts
    extend T::Sig

    # DEPRECATED: Set to true to keep .git directory.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :keep_git_dir

    # A service which must be started before the repo is fetched.
    sig { returns(T.nilable(Service)) }
    attr_accessor :experimental_service_host

    # Set SSH known hosts
    sig { returns(T.nilable(String)) }
    attr_accessor :ssh_known_hosts

    # Set SSH auth socket
    sig { returns(T.nilable(Socket)) }
    attr_accessor :ssh_auth_socket
  end

  # Optional arguments for http on Client
  class ClientHttpOpts
    extend T::Sig

    # A service which must be started before the URL is fetched.
    sig { returns(T.nilable(Service)) }
    attr_accessor :experimental_service_host
  end

  # Optional arguments for module_dependency on Client
  class ClientModuleDependencyOpts
    extend T::Sig

    # If set, the name to use for the dependency. Otherwise, once installed to a parent module, the name of the dependency module will be used by default.
    sig { returns(T.nilable(String)) }
    attr_accessor :name
  end

  # Optional arguments for module_source on Client
  class ClientModuleSourceOpts
    extend T::Sig

    # The pinned version of the module source
    sig { returns(T.nilable(String)) }
    attr_accessor :ref_pin

    # If true, enforce that the source is a stable version for source kinds that support versioning.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :stable

    # The relative path to the module root from the host directory
    sig { returns(T.nilable(String)) }
    attr_accessor :rel_host_path
  end

  # Optional arguments for secret on Client
  class ClientSecretOpts
    extend T::Sig

    sig { returns(T.nilable(String)) }
    attr_accessor :accessor
  end

  # The root of the DAG.
  class Client < Node
    extend T::Sig

    sig { returns(GraphQLClient) }
    attr_reader :client

    # Retrieves a content-addressed blob.
    # @param digest - Digest of the blob
    # @param size - Size of the blob
    # @param media_type - Media type of the blob
    # @param uncompressed - Digest of the uncompressed blob
    sig { params(digest: String, size: Integer, media_type: String, uncompressed: String).returns(Directory) }
    def blob(digest:, size:, media_type:, uncompressed:)
      assert_not_nil(:digest, digest)
      assert_not_nil(:size, size)
      assert_not_nil(:media_type, media_type)
      assert_not_nil(:uncompressed, uncompressed)
      dag_node_args = {
        'digest' => digest,
        'size' => size,
        'mediaType' => media_type,
        'uncompressed' => uncompressed
      }
      Directory.new(self, @client, 'blob', dag_node_args)
    end

    # Retrieves a container builtin to the engine.
    # @param digest - Digest of the image manifest
    sig { params(digest: String).returns(Container) }
    def builtin_container(digest:)
      assert_not_nil(:digest, digest)
      dag_node_args = {
        'digest' => digest
      }
      Container.new(self, @client, 'builtinContainer', dag_node_args)
    end

    # Constructs a cache volume for a given cache key.
    # @param key - A string identifier to target this cache volume (e.g., "modules-cache").
    sig { params(key: String).returns(CacheVolume) }
    def cache_volume(key:)
      assert_not_nil(:key, key)
      dag_node_args = {
        'key' => key
      }
      CacheVolume.new(self, @client, 'cacheVolume', dag_node_args)
    end

    # Creates a scratch container.
    #
    # Optional platform argument initializes new containers to execute and publish as that platform. Platform defaults to that of the builder's host.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ClientContainerOpts)).returns(Container) }
    def container(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['platform'] = opts.platform unless opts.platform.nil?
      end
      Container.new(self, @client, 'container', dag_node_args)
    end

    # The FunctionCall context that the SDK caller is currently executing in.
    #
    # If the caller is not currently executing in a function, this will return an error.
    sig { returns(FunctionCall) }
    def current_function_call
      FunctionCall.new(self, @client, 'currentFunctionCall')
    end

    # The module currently being served in the session, if any.
    sig { returns(CurrentModule) }
    def current_module
      CurrentModule.new(self, @client, 'currentModule')
    end

    # The TypeDef representations of the objects currently being served in the session.
    sig { returns(T::Array[TypeDef]) }
    def current_type_defs
      n = Client.new(self, @client, 'currentTypeDefs')
      @client.invoke(n)
    end

    # The default platform of the engine.
    sig { returns(Platform) }
    def default_platform
      n = Client.new(self, @client, 'defaultPlatform')
      @client.invoke(n)
    end

    # Creates an empty directory.
    sig { returns(Directory) }
    def directory
      Directory.new(self, @client, 'directory')
    end

    # The Dagger engine container configuration and state
    sig { returns(Engine) }
    def engine
      Engine.new(self, @client, 'engine')
    end

    # Create a new error.
    # @param message - A brief description of the error.
    sig { params(message: String).returns(Error) }
    def error(message:)
      assert_not_nil(:message, message)
      dag_node_args = {
        'message' => message
      }
      Error.new(self, @client, 'error', dag_node_args)
    end

    # Creates a function.
    # @param name - Name of the function, in its original format from the implementation language.
    # @param return_type - Return type of the function.
    sig { params(name: String, return_type: TypeDef).returns(Function) }
    def function(name:, return_type:)
      assert_not_nil(:name, name)
      assert_not_nil(:return_type, return_type)
      dag_node_args = {
        'name' => name,
        'returnType' => return_type
      }
      Function.new(self, @client, 'function', dag_node_args)
    end

    # Create a code generation result, given a directory containing the generated code.
    sig { params(code: Directory).returns(GeneratedCode) }
    def generated_code(code:)
      assert_not_nil(:code, code)
      dag_node_args = {
        'code' => code
      }
      GeneratedCode.new(self, @client, 'generatedCode', dag_node_args)
    end

    # Queries a Git repository.
    # @param url - URL of the git repository.
    #
    # Can be formatted as `https://{host}/{owner}/{repo}`, `git@{host}:{owner}/{repo}`.
    #
    # Suffix ".git" is optional.
    # @param opts - Optional arguments
    sig { params(url: String, opts: T.nilable(ClientGitOpts)).returns(GitRepository) }
    def git(url:, opts: nil)
      assert_not_nil(:url, url)
      dag_node_args = {
        'url' => url
      }
      unless opts.nil?
        dag_node_args['keepGitDir'] = opts.keep_git_dir unless opts.keep_git_dir.nil?
        dag_node_args['experimentalServiceHost'] = opts.experimental_service_host unless opts.experimental_service_host.nil?
        dag_node_args['sshKnownHosts'] = opts.ssh_known_hosts unless opts.ssh_known_hosts.nil?
        dag_node_args['sshAuthSocket'] = opts.ssh_auth_socket unless opts.ssh_auth_socket.nil?
      end
      GitRepository.new(self, @client, 'git', dag_node_args)
    end

    # Queries the host environment.
    sig { returns(Host) }
    def host
      Host.new(self, @client, 'host')
    end

    # Returns a file containing an http remote url content.
    # @param url - HTTP url to get the content from (e.g., "https://docs.dagger.io").
    # @param opts - Optional arguments
    sig { params(url: String, opts: T.nilable(ClientHttpOpts)).returns(File) }
    def http(url:, opts: nil)
      assert_not_nil(:url, url)
      dag_node_args = {
        'url' => url
      }
      unless opts.nil?
        dag_node_args['experimentalServiceHost'] = opts.experimental_service_host unless opts.experimental_service_host.nil?
      end
      File.new(self, @client, 'http', dag_node_args)
    end

    # Load a CacheVolume from its ID.
    sig { params(id: CacheVolume).returns(CacheVolume) }
    def load_cache_volume_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      CacheVolume.new(self, @client, 'loadCacheVolumeFromID', dag_node_args)
    end

    # Load a Container from its ID.
    sig { params(id: Container).returns(Container) }
    def load_container_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Container.new(self, @client, 'loadContainerFromID', dag_node_args)
    end

    # Load a CurrentModule from its ID.
    sig { params(id: CurrentModule).returns(CurrentModule) }
    def load_current_module_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      CurrentModule.new(self, @client, 'loadCurrentModuleFromID', dag_node_args)
    end

    # Load a Directory from its ID.
    sig { params(id: Directory).returns(Directory) }
    def load_directory_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Directory.new(self, @client, 'loadDirectoryFromID', dag_node_args)
    end

    # Load a EngineCacheEntry from its ID.
    sig { params(id: EngineCacheEntry).returns(EngineCacheEntry) }
    def load_engine_cache_entry_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EngineCacheEntry.new(self, @client, 'loadEngineCacheEntryFromID', dag_node_args)
    end

    # Load a EngineCacheEntrySet from its ID.
    sig { params(id: EngineCacheEntrySet).returns(EngineCacheEntrySet) }
    def load_engine_cache_entry_set_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EngineCacheEntrySet.new(self, @client, 'loadEngineCacheEntrySetFromID', dag_node_args)
    end

    # Load a EngineCache from its ID.
    sig { params(id: EngineCache).returns(EngineCache) }
    def load_engine_cache_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EngineCache.new(self, @client, 'loadEngineCacheFromID', dag_node_args)
    end

    # Load a Engine from its ID.
    sig { params(id: Engine).returns(Engine) }
    def load_engine_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Engine.new(self, @client, 'loadEngineFromID', dag_node_args)
    end

    # Load a EnumTypeDef from its ID.
    sig { params(id: EnumTypeDef).returns(EnumTypeDef) }
    def load_enum_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EnumTypeDef.new(self, @client, 'loadEnumTypeDefFromID', dag_node_args)
    end

    # Load a EnumValueTypeDef from its ID.
    sig { params(id: EnumValueTypeDef).returns(EnumValueTypeDef) }
    def load_enum_value_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EnumValueTypeDef.new(self, @client, 'loadEnumValueTypeDefFromID', dag_node_args)
    end

    # Load a EnvVariable from its ID.
    sig { params(id: EnvVariable).returns(EnvVariable) }
    def load_env_variable_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      EnvVariable.new(self, @client, 'loadEnvVariableFromID', dag_node_args)
    end

    # Load a Error from its ID.
    sig { params(id: Error).returns(Error) }
    def load_error_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Error.new(self, @client, 'loadErrorFromID', dag_node_args)
    end

    # Load a FieldTypeDef from its ID.
    sig { params(id: FieldTypeDef).returns(FieldTypeDef) }
    def load_field_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      FieldTypeDef.new(self, @client, 'loadFieldTypeDefFromID', dag_node_args)
    end

    # Load a File from its ID.
    sig { params(id: File).returns(File) }
    def load_file_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      File.new(self, @client, 'loadFileFromID', dag_node_args)
    end

    # Load a FunctionArg from its ID.
    sig { params(id: FunctionArg).returns(FunctionArg) }
    def load_function_arg_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      FunctionArg.new(self, @client, 'loadFunctionArgFromID', dag_node_args)
    end

    # Load a FunctionCallArgValue from its ID.
    sig { params(id: FunctionCallArgValue).returns(FunctionCallArgValue) }
    def load_function_call_arg_value_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      FunctionCallArgValue.new(self, @client, 'loadFunctionCallArgValueFromID', dag_node_args)
    end

    # Load a FunctionCall from its ID.
    sig { params(id: FunctionCall).returns(FunctionCall) }
    def load_function_call_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      FunctionCall.new(self, @client, 'loadFunctionCallFromID', dag_node_args)
    end

    # Load a Function from its ID.
    sig { params(id: Function).returns(Function) }
    def load_function_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Function.new(self, @client, 'loadFunctionFromID', dag_node_args)
    end

    # Load a GeneratedCode from its ID.
    sig { params(id: GeneratedCode).returns(GeneratedCode) }
    def load_generated_code_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      GeneratedCode.new(self, @client, 'loadGeneratedCodeFromID', dag_node_args)
    end

    # Load a GitModuleSource from its ID.
    sig { params(id: GitModuleSource).returns(GitModuleSource) }
    def load_git_module_source_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      GitModuleSource.new(self, @client, 'loadGitModuleSourceFromID', dag_node_args)
    end

    # Load a GitRef from its ID.
    sig { params(id: GitRef).returns(GitRef) }
    def load_git_ref_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      GitRef.new(self, @client, 'loadGitRefFromID', dag_node_args)
    end

    # Load a GitRepository from its ID.
    sig { params(id: GitRepository).returns(GitRepository) }
    def load_git_repository_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      GitRepository.new(self, @client, 'loadGitRepositoryFromID', dag_node_args)
    end

    # Load a Host from its ID.
    sig { params(id: Host).returns(Host) }
    def load_host_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Host.new(self, @client, 'loadHostFromID', dag_node_args)
    end

    # Load a InputTypeDef from its ID.
    sig { params(id: InputTypeDef).returns(InputTypeDef) }
    def load_input_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      InputTypeDef.new(self, @client, 'loadInputTypeDefFromID', dag_node_args)
    end

    # Load a InterfaceTypeDef from its ID.
    sig { params(id: InterfaceTypeDef).returns(InterfaceTypeDef) }
    def load_interface_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      InterfaceTypeDef.new(self, @client, 'loadInterfaceTypeDefFromID', dag_node_args)
    end

    # Load a Label from its ID.
    sig { params(id: Label).returns(Label) }
    def load_label_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Label.new(self, @client, 'loadLabelFromID', dag_node_args)
    end

    # Load a ListTypeDef from its ID.
    sig { params(id: ListTypeDef).returns(ListTypeDef) }
    def load_list_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ListTypeDef.new(self, @client, 'loadListTypeDefFromID', dag_node_args)
    end

    # Load a LocalModuleSource from its ID.
    sig { params(id: LocalModuleSource).returns(LocalModuleSource) }
    def load_local_module_source_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      LocalModuleSource.new(self, @client, 'loadLocalModuleSourceFromID', dag_node_args)
    end

    # Load a ModuleDependency from its ID.
    sig { params(id: ModuleDependency).returns(ModuleDependency) }
    def load_module_dependency_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ModuleDependency.new(self, @client, 'loadModuleDependencyFromID', dag_node_args)
    end

    # Load a Module from its ID.
    sig { params(id: Module_).returns(Module_) }
    def load_module_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Module_.new(self, @client, 'loadModuleFromID', dag_node_args)
    end

    # Load a ModuleSource from its ID.
    sig { params(id: ModuleSource).returns(ModuleSource) }
    def load_module_source_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ModuleSource.new(self, @client, 'loadModuleSourceFromID', dag_node_args)
    end

    # Load a ModuleSourceView from its ID.
    sig { params(id: ModuleSourceView).returns(ModuleSourceView) }
    def load_module_source_view_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ModuleSourceView.new(self, @client, 'loadModuleSourceViewFromID', dag_node_args)
    end

    # Load a ObjectTypeDef from its ID.
    sig { params(id: ObjectTypeDef).returns(ObjectTypeDef) }
    def load_object_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ObjectTypeDef.new(self, @client, 'loadObjectTypeDefFromID', dag_node_args)
    end

    # Load a Port from its ID.
    sig { params(id: Port).returns(Port) }
    def load_port_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Port.new(self, @client, 'loadPortFromID', dag_node_args)
    end

    # Load a ScalarTypeDef from its ID.
    sig { params(id: ScalarTypeDef).returns(ScalarTypeDef) }
    def load_scalar_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      ScalarTypeDef.new(self, @client, 'loadScalarTypeDefFromID', dag_node_args)
    end

    # Load a Secret from its ID.
    sig { params(id: Secret).returns(Secret) }
    def load_secret_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Secret.new(self, @client, 'loadSecretFromID', dag_node_args)
    end

    # Load a Service from its ID.
    sig { params(id: Service).returns(Service) }
    def load_service_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Service.new(self, @client, 'loadServiceFromID', dag_node_args)
    end

    # Load a Socket from its ID.
    sig { params(id: Socket).returns(Socket) }
    def load_socket_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Socket.new(self, @client, 'loadSocketFromID', dag_node_args)
    end

    # Load a SourceMap from its ID.
    sig { params(id: SourceMap).returns(SourceMap) }
    def load_source_map_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      SourceMap.new(self, @client, 'loadSourceMapFromID', dag_node_args)
    end

    # Load a Terminal from its ID.
    sig { params(id: Terminal).returns(Terminal) }
    def load_terminal_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      Terminal.new(self, @client, 'loadTerminalFromID', dag_node_args)
    end

    # Load a TypeDef from its ID.
    sig { params(id: TypeDef).returns(TypeDef) }
    def load_type_def_from_id(id:)
      assert_not_nil(:id, id)
      dag_node_args = {
        'id' => id
      }
      TypeDef.new(self, @client, 'loadTypeDefFromID', dag_node_args)
    end

    # Create a new module.
    sig { returns(Module_) }
    def module_
      Module_.new(self, @client, 'module')
    end

    # Create a new module dependency configuration from a module source and name
    # @param source - The source of the dependency
    # @param opts - Optional arguments
    sig { params(source: ModuleSource, opts: T.nilable(ClientModuleDependencyOpts)).returns(ModuleDependency) }
    def module_dependency(source:, opts: nil)
      assert_not_nil(:source, source)
      dag_node_args = {
        'source' => source
      }
      unless opts.nil?
        dag_node_args['name'] = opts.name unless opts.name.nil?
      end
      ModuleDependency.new(self, @client, 'moduleDependency', dag_node_args)
    end

    # Create a new module source instance from a source ref string.
    # @param ref_string - The string ref representation of the module source
    # @param opts - Optional arguments
    sig { params(ref_string: String, opts: T.nilable(ClientModuleSourceOpts)).returns(ModuleSource) }
    def module_source(ref_string:, opts: nil)
      assert_not_nil(:ref_string, ref_string)
      dag_node_args = {
        'refString' => ref_string
      }
      unless opts.nil?
        dag_node_args['refPin'] = opts.ref_pin unless opts.ref_pin.nil?
        dag_node_args['stable'] = opts.stable unless opts.stable.nil?
        dag_node_args['relHostPath'] = opts.rel_host_path unless opts.rel_host_path.nil?
      end
      ModuleSource.new(self, @client, 'moduleSource', dag_node_args)
    end

    # Reference a secret by name.
    # @param opts - Optional arguments
    sig { params(name: String, opts: T.nilable(ClientSecretOpts)).returns(Secret) }
    def secret(name:, opts: nil)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      unless opts.nil?
        dag_node_args['accessor'] = opts.accessor unless opts.accessor.nil?
      end
      Secret.new(self, @client, 'secret', dag_node_args)
    end

    # Sets a secret given a user defined name to its plaintext and returns the secret.
    #
    # The plaintext value is limited to a size of 128000 bytes.
    # @param name - The user defined name for this secret
    # @param plaintext - The plaintext of the secret
    sig { params(name: String, plaintext: String).returns(Secret) }
    def set_secret(name:, plaintext:)
      assert_not_nil(:name, name)
      assert_not_nil(:plaintext, plaintext)
      dag_node_args = {
        'name' => name,
        'plaintext' => plaintext
      }
      Secret.new(self, @client, 'setSecret', dag_node_args)
    end

    # Creates source map metadata.
    # @param filename - The filename from the module source.
    # @param line - The line number within the filename.
    # @param column - The column number within the line.
    sig { params(filename: String, line: Integer, column: Integer).returns(SourceMap) }
    def source_map(filename:, line:, column:)
      assert_not_nil(:filename, filename)
      assert_not_nil(:line, line)
      assert_not_nil(:column, column)
      dag_node_args = {
        'filename' => filename,
        'line' => line,
        'column' => column
      }
      SourceMap.new(self, @client, 'sourceMap', dag_node_args)
    end

    # Create a new TypeDef.
    sig { returns(TypeDef) }
    def type_def
      TypeDef.new(self, @client, 'typeDef')
    end

    # Get the current Dagger Engine version.
    sig { returns(String) }
    def version
      n = Client.new(self, @client, 'version')
      @client.invoke(n)
    end
  end

  # A definition of a custom scalar defined in a Module.
  class ScalarTypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # A doc string for the scalar, if any.
    sig { returns(String) }
    def description
      n = ScalarTypeDef.new(self, @client, 'description')
      @client.invoke(n)
    end

    # The name of the scalar.
    sig { returns(String) }
    def name
      n = ScalarTypeDef.new(self, @client, 'name')
      @client.invoke(n)
    end

    # If this ScalarTypeDef is associated with a Module, the name of the module. Unset otherwise.
    sig { returns(String) }
    def source_module_name
      n = ScalarTypeDef.new(self, @client, 'sourceModuleName')
      @client.invoke(n)
    end
  end

  # A reference to a secret value, which can be handled more safely than the value itself.
  class Secret < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The name of this secret.
    sig { returns(String) }
    def name
      n = Secret.new(self, @client, 'name')
      @client.invoke(n)
    end

    # The value of this secret.
    sig { returns(String) }
    def plaintext
      n = Secret.new(self, @client, 'plaintext')
      @client.invoke(n)
    end
  end

  # Optional arguments for endpoint on Service
  class ServiceEndpointOpts
    extend T::Sig

    # The exposed port number for the endpoint
    sig { returns(T.nilable(Integer)) }
    attr_accessor :port

    # Return a URL with the given scheme, eg. http for http://
    sig { returns(T.nilable(String)) }
    attr_accessor :scheme
  end

  # Optional arguments for stop on Service
  class ServiceStopOpts
    extend T::Sig

    # Immediately kill the service without waiting for a graceful exit
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :kill
  end

  # Optional arguments for up on Service
  class ServiceUpOpts
    extend T::Sig

    # List of frontend/backend port mappings to forward.
    #
    # Frontend is the port accepting traffic on the host, backend is the service port.
    sig { returns(T.nilable(T::Array[PortForward])) }
    attr_accessor :ports

    # Bind each tunnel port to a random port on the host.
    sig { returns(T.nilable(T::Boolean)) }
    attr_accessor :random
  end

  # A content-addressed service providing TCP connectivity.
  class Service < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Retrieves an endpoint that clients can use to reach this container.
    #
    # If no port is specified, the first exposed port is used. If none exist an error is returned.
    #
    # If a scheme is specified, a URL is returned. Otherwise, a host:port pair is returned.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ServiceEndpointOpts)).returns(String) }
    def endpoint(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['port'] = opts.port unless opts.port.nil?
        dag_node_args['scheme'] = opts.scheme unless opts.scheme.nil?
      end
      n = Service.new(self, @client, 'endpoint', dag_node_args)
      @client.invoke(n)
    end

    # Retrieves a hostname which can be used by clients to reach this container.
    sig { returns(String) }
    def hostname
      n = Service.new(self, @client, 'hostname')
      @client.invoke(n)
    end

    # Retrieves the list of ports provided by the service.
    sig { returns(T::Array[Port]) }
    def ports
      n = Service.new(self, @client, 'ports')
      @client.invoke(n)
    end

    # Start the service and wait for its health checks to succeed.
    #
    # Services bound to a Container do not need to be manually started.
    sig { returns(ServiceID) }
    def start
      n = Service.new(self, @client, 'start')
      @client.invoke(n)
    end

    # Stop the service.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ServiceStopOpts)).returns(ServiceID) }
    def stop(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['kill'] = opts.kill unless opts.kill.nil?
      end
      n = Service.new(self, @client, 'stop', dag_node_args)
      @client.invoke(n)
    end

    # Creates a tunnel that forwards traffic from the caller's network to this service.
    # @param opts - Optional arguments
    sig { params(opts: T.nilable(ServiceUpOpts)).returns(Void) }
    def up(opts: nil)
      dag_node_args = {}
      unless opts.nil?
        dag_node_args['ports'] = opts.ports unless opts.ports.nil?
        dag_node_args['random'] = opts.random unless opts.random.nil?
      end
      n = Service.new(self, @client, 'up', dag_node_args)
      @client.invoke(n)
    end

    # Configures a hostname which can be used by clients within the session to reach this container.
    # @param hostname - The hostname to use.
    sig { params(hostname: String).returns(Service) }
    def with_hostname(hostname:)
      assert_not_nil(:hostname, hostname)
      dag_node_args = {
        'hostname' => hostname
      }
      Service.new(self, @client, 'withHostname', dag_node_args)
    end

    sig { params(_blk: ServiceChain).returns(Service) }
    def with(&_blk)
      yield self
    end
  end

  # A Unix or TCP/IP socket that can be mounted into a container.
  class Socket < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end
  end

  # Source location information.
  class SourceMap < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # The column number within the line.
    sig { returns(Integer) }
    def column
      n = SourceMap.new(self, @client, 'column')
      @client.invoke(n)
    end

    # The filename from the module source.
    sig { returns(String) }
    def filename
      n = SourceMap.new(self, @client, 'filename')
      @client.invoke(n)
    end

    # The line number within the filename.
    sig { returns(Integer) }
    def line
      n = SourceMap.new(self, @client, 'line')
      @client.invoke(n)
    end

    # The module dependency this was declared in.
    sig { returns(String) }
    def module_
      n = SourceMap.new(self, @client, 'module')
      @client.invoke(n)
    end
  end

  # An interactive terminal that clients can connect to.
  class Terminal < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # Forces evaluation of the pipeline in the engine.
    #
    # It doesn't run the default command if no exec has been set.
    sig { returns(TerminalID) }
    def sync
      n = Terminal.new(self, @client, 'sync')
      @client.invoke(n)
    end
  end

  # Optional arguments for with_enum on TypeDef
  class TypeDefWithEnumOpts
    extend T::Sig

    # A doc string for the enum, if any
    sig { returns(T.nilable(String)) }
    attr_accessor :description

    # The source map for the enum definition.
    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Optional arguments for with_enum_value on TypeDef
  class TypeDefWithEnumValueOpts
    extend T::Sig

    # A doc string for the value, if any
    sig { returns(T.nilable(String)) }
    attr_accessor :description

    # The source map for the enum value definition.
    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Optional arguments for with_field on TypeDef
  class TypeDefWithFieldOpts
    extend T::Sig

    # A doc string for the field, if any
    sig { returns(T.nilable(String)) }
    attr_accessor :description

    # The source map for the field definition.
    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Optional arguments for with_interface on TypeDef
  class TypeDefWithInterfaceOpts
    extend T::Sig

    sig { returns(T.nilable(String)) }
    attr_accessor :description

    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Optional arguments for with_object on TypeDef
  class TypeDefWithObjectOpts
    extend T::Sig

    sig { returns(T.nilable(String)) }
    attr_accessor :description

    sig { returns(T.nilable(SourceMap)) }
    attr_accessor :source_map
  end

  # Optional arguments for with_scalar on TypeDef
  class TypeDefWithScalarOpts
    extend T::Sig

    sig { returns(T.nilable(String)) }
    attr_accessor :description
  end

  # A definition of a parameter or return type in a Module.
  class TypeDef < Node
    extend T::Sig

    # Return the Node ID for the GraphQL entity
    # @return [String]
    sig { returns(String) }
    def id
      @client.invoke(Node.new(self, @client, 'id'))
    end

    # If kind is ENUM, the enum-specific type definition. If kind is not ENUM, this will be null.
    sig { returns(EnumTypeDef) }
    def as_enum
      EnumTypeDef.new(self, @client, 'asEnum')
    end

    # If kind is INPUT, the input-specific type definition. If kind is not INPUT, this will be null.
    sig { returns(InputTypeDef) }
    def as_input
      InputTypeDef.new(self, @client, 'asInput')
    end

    # If kind is INTERFACE, the interface-specific type definition. If kind is not INTERFACE, this will be null.
    sig { returns(InterfaceTypeDef) }
    def as_interface
      InterfaceTypeDef.new(self, @client, 'asInterface')
    end

    # If kind is LIST, the list-specific type definition. If kind is not LIST, this will be null.
    sig { returns(ListTypeDef) }
    def as_list
      ListTypeDef.new(self, @client, 'asList')
    end

    # If kind is OBJECT, the object-specific type definition. If kind is not OBJECT, this will be null.
    sig { returns(ObjectTypeDef) }
    def as_object
      ObjectTypeDef.new(self, @client, 'asObject')
    end

    # If kind is SCALAR, the scalar-specific type definition. If kind is not SCALAR, this will be null.
    sig { returns(ScalarTypeDef) }
    def as_scalar
      ScalarTypeDef.new(self, @client, 'asScalar')
    end

    # The kind of type this is (e.g. primitive, list, object).
    sig { returns(TypeDefKind) }
    def kind
      n = TypeDef.new(self, @client, 'kind')
      @client.invoke(n)
    end

    # Whether this type can be set to null. Defaults to false.
    sig { returns(T::Boolean) }
    def optional
      n = TypeDef.new(self, @client, 'optional')
      @client.invoke(n)
    end

    # Adds a function for constructing a new instance of an Object TypeDef, failing if the type is not an object.
    sig { params(function: Function).returns(TypeDef) }
    def with_constructor(function:)
      assert_not_nil(:function, function)
      dag_node_args = {
        'function' => function
      }
      TypeDef.new(self, @client, 'withConstructor', dag_node_args)
    end

    # Returns a TypeDef of kind Enum with the provided name.
    #
    # Note that an enum's values may be omitted if the intent is only to refer to an enum. This is how functions are able to return their own, or any other circular reference.
    # @param name - The name of the enum
    # @param opts - Optional arguments
    sig { params(name: String, opts: T.nilable(TypeDefWithEnumOpts)).returns(TypeDef) }
    def with_enum(name:, opts: nil)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      TypeDef.new(self, @client, 'withEnum', dag_node_args)
    end

    # Adds a static value for an Enum TypeDef, failing if the type is not an enum.
    # @param value - The name of the value in the enum
    # @param opts - Optional arguments
    sig { params(value: String, opts: T.nilable(TypeDefWithEnumValueOpts)).returns(TypeDef) }
    def with_enum_value(value:, opts: nil)
      assert_not_nil(:value, value)
      dag_node_args = {
        'value' => value
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      TypeDef.new(self, @client, 'withEnumValue', dag_node_args)
    end

    # Adds a static field for an Object TypeDef, failing if the type is not an object.
    # @param name - The name of the field in the object
    # @param type_def - The type of the field
    # @param opts - Optional arguments
    sig { params(name: String, type_def: TypeDef, opts: T.nilable(TypeDefWithFieldOpts)).returns(TypeDef) }
    def with_field(name:, type_def:, opts: nil)
      assert_not_nil(:name, name)
      assert_not_nil(:type_def, type_def)
      dag_node_args = {
        'name' => name,
        'typeDef' => type_def
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      TypeDef.new(self, @client, 'withField', dag_node_args)
    end

    # Adds a function for an Object or Interface TypeDef, failing if the type is not one of those kinds.
    sig { params(function: Function).returns(TypeDef) }
    def with_function(function:)
      assert_not_nil(:function, function)
      dag_node_args = {
        'function' => function
      }
      TypeDef.new(self, @client, 'withFunction', dag_node_args)
    end

    # Returns a TypeDef of kind Interface with the provided name.
    # @param opts - Optional arguments
    sig { params(name: String, opts: T.nilable(TypeDefWithInterfaceOpts)).returns(TypeDef) }
    def with_interface(name:, opts: nil)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      TypeDef.new(self, @client, 'withInterface', dag_node_args)
    end

    # Sets the kind of the type.
    sig { params(kind: TypeDefKind).returns(TypeDef) }
    def with_kind(kind:)
      assert_not_nil(:kind, kind)
      dag_node_args = {
        'kind' => kind
      }
      TypeDef.new(self, @client, 'withKind', dag_node_args)
    end

    # Returns a TypeDef of kind List with the provided type for its elements.
    sig { params(element_type: TypeDef).returns(TypeDef) }
    def with_list_of(element_type:)
      assert_not_nil(:element_type, element_type)
      dag_node_args = {
        'elementType' => element_type
      }
      TypeDef.new(self, @client, 'withListOf', dag_node_args)
    end

    # Returns a TypeDef of kind Object with the provided name.
    #
    # Note that an object's fields and functions may be omitted if the intent is only to refer to an object. This is how functions are able to return their own object, or any other circular reference.
    # @param opts - Optional arguments
    sig { params(name: String, opts: T.nilable(TypeDefWithObjectOpts)).returns(TypeDef) }
    def with_object(name:, opts: nil)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
        dag_node_args['sourceMap'] = opts.source_map unless opts.source_map.nil?
      end
      TypeDef.new(self, @client, 'withObject', dag_node_args)
    end

    # Sets whether this type can be set to null.
    sig { params(optional: T::Boolean).returns(TypeDef) }
    def with_optional(optional:)
      assert_not_nil(:optional, optional)
      dag_node_args = {
        'optional' => optional
      }
      TypeDef.new(self, @client, 'withOptional', dag_node_args)
    end

    # Returns a TypeDef of kind Scalar with the provided name.
    # @param opts - Optional arguments
    sig { params(name: String, opts: T.nilable(TypeDefWithScalarOpts)).returns(TypeDef) }
    def with_scalar(name:, opts: nil)
      assert_not_nil(:name, name)
      dag_node_args = {
        'name' => name
      }
      unless opts.nil?
        dag_node_args['description'] = opts.description unless opts.description.nil?
      end
      TypeDef.new(self, @client, 'withScalar', dag_node_args)
    end

    sig { params(_blk: TypeDefChain).returns(TypeDef) }
    def with(&_blk)
      yield self
    end
  end
end
