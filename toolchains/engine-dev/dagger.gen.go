// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/engine-dev/internal/dagger"
	"dagger/engine-dev/internal/querybuilder"
	"dagger/engine-dev/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r EngineDev) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Source             *dagger.Directory
		BuildkitConfig     []string
		LogLevel           string
		SubnetNumber       int
		Race               bool
		ClientDockerConfig *dagger.Secret
	}
	concrete.Source = r.Source
	concrete.BuildkitConfig = r.BuildkitConfig
	concrete.LogLevel = r.LogLevel
	concrete.SubnetNumber = r.SubnetNumber
	concrete.Race = r.Race
	concrete.ClientDockerConfig = r.ClientDockerConfig
	return json.Marshal(&concrete)
}

func (r *EngineDev) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Source             *dagger.Directory
		BuildkitConfig     []string
		LogLevel           string
		SubnetNumber       int
		Race               bool
		ClientDockerConfig *dagger.Secret
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Source = concrete.Source
	r.BuildkitConfig = concrete.BuildkitConfig
	r.LogLevel = concrete.LogLevel
	r.SubnetNumber = concrete.SubnetNumber
	r.Race = concrete.Race
	r.ClientDockerConfig = concrete.ClientDockerConfig
	return nil
}

func (r LoadedEngine) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Loader     *dagger.Container
		Image      string
		GPUSupport bool
	}
	concrete.Loader = r.Loader
	concrete.Image = r.Image
	concrete.GPUSupport = r.GPUSupport
	return json.Marshal(&concrete)
}

func (r *LoadedEngine) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Loader     *dagger.Container
		Image      string
		GPUSupport bool
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Loader = concrete.Loader
	r.Image = concrete.Image
	r.GPUSupport = concrete.GPUSupport
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "EngineDev":
		switch fnName {
		case "Benchmark":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var run string
			if inputArgs["run"] != nil {
				err = json.Unmarshal([]byte(inputArgs["run"]), &run)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg run", err))
				}
			}
			var skip string
			if inputArgs["skip"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skip"]), &skip)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skip", err))
				}
			}
			var pkg string
			if inputArgs["pkg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pkg"]), &pkg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pkg", err))
				}
			}
			var failfast bool
			if inputArgs["failfast"] != nil {
				err = json.Unmarshal([]byte(inputArgs["failfast"]), &failfast)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg failfast", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var race bool
			if inputArgs["race"] != nil {
				err = json.Unmarshal([]byte(inputArgs["race"]), &race)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg race", err))
				}
			}
			var count int
			if inputArgs["count"] != nil {
				err = json.Unmarshal([]byte(inputArgs["count"]), &count)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg count", err))
				}
			}
			var testVerbose bool
			if inputArgs["testVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testVerbose"]), &testVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testVerbose", err))
				}
			}
			var prewarm bool
			if inputArgs["prewarm"] != nil {
				err = json.Unmarshal([]byte(inputArgs["prewarm"]), &prewarm)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg prewarm", err))
				}
			}
			var discordWebhook *dagger.Secret
			if inputArgs["discordWebhook"] != nil {
				err = json.Unmarshal([]byte(inputArgs["discordWebhook"]), &discordWebhook)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg discordWebhook", err))
				}
			}
			var repo *dagger.GitRepository
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return nil, (*EngineDev).Benchmark(&parent, ctx, run, skip, pkg, failfast, timeout, race, count, testVerbose, prewarm, discordWebhook, repo)
		case "BenchmarkDump":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var run string
			if inputArgs["run"] != nil {
				err = json.Unmarshal([]byte(inputArgs["run"]), &run)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg run", err))
				}
			}
			var skip string
			if inputArgs["skip"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skip"]), &skip)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skip", err))
				}
			}
			var pkg string
			if inputArgs["pkg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pkg"]), &pkg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pkg", err))
				}
			}
			var failfast bool
			if inputArgs["failfast"] != nil {
				err = json.Unmarshal([]byte(inputArgs["failfast"]), &failfast)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg failfast", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var race bool
			if inputArgs["race"] != nil {
				err = json.Unmarshal([]byte(inputArgs["race"]), &race)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg race", err))
				}
			}
			var count int
			if inputArgs["count"] != nil {
				err = json.Unmarshal([]byte(inputArgs["count"]), &count)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg count", err))
				}
			}
			var testVerbose bool
			if inputArgs["testVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testVerbose"]), &testVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testVerbose", err))
				}
			}
			var route string
			if inputArgs["route"] != nil {
				err = json.Unmarshal([]byte(inputArgs["route"]), &route)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg route", err))
				}
			}
			var noFinal bool
			if inputArgs["noFinal"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noFinal"]), &noFinal)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noFinal", err))
				}
			}
			var delay string
			if inputArgs["delay"] != nil {
				err = json.Unmarshal([]byte(inputArgs["delay"]), &delay)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg delay", err))
				}
			}
			var interval string
			if inputArgs["interval"] != nil {
				err = json.Unmarshal([]byte(inputArgs["interval"]), &interval)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg interval", err))
				}
			}
			return (*EngineDev).BenchmarkDump(&parent, ctx, run, skip, pkg, failfast, timeout, race, count, testVerbose, route, noFinal, delay, interval)
		case "ConfigSchema":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var filename string
			if inputArgs["filename"] != nil {
				err = json.Unmarshal([]byte(inputArgs["filename"]), &filename)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg filename", err))
				}
			}
			return (*EngineDev).ConfigSchema(&parent, filename), nil
		case "Container":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var platform dagger.Platform
			if inputArgs["platform"] != nil {
				err = json.Unmarshal([]byte(inputArgs["platform"]), &platform)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg platform", err))
				}
			}
			var gpuSupport bool
			if inputArgs["gpuSupport"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpuSupport"]), &gpuSupport)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpuSupport", err))
				}
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			return (*EngineDev).Container(&parent, ctx, platform, gpuSupport, version, tag)
		case "Generate":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).Generate(&parent, ctx)
		case "GraphqlSchema":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var version string
			if inputArgs["version"] != nil {
				err = json.Unmarshal([]byte(inputArgs["version"]), &version)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg version", err))
				}
			}
			return (*EngineDev).GraphqlSchema(&parent, ctx, version)
		case "IncrementSubnet":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).IncrementSubnet(&parent), nil
		case "InstallClient":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var client *dagger.Container
			if inputArgs["client"] != nil {
				err = json.Unmarshal([]byte(inputArgs["client"]), &client)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg client", err))
				}
			}
			var service *dagger.Service
			if inputArgs["service"] != nil {
				err = json.Unmarshal([]byte(inputArgs["service"]), &service)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg service", err))
				}
			}
			return (*EngineDev).InstallClient(&parent, ctx, client, service)
		case "IntrospectionJSON":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).IntrospectionJSON(&parent, ctx)
		case "IntrospectionTool":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).IntrospectionTool(&parent), nil
		case "LoadToDocker":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var docker *dagger.Socket
			if inputArgs["docker"] != nil {
				err = json.Unmarshal([]byte(inputArgs["docker"]), &docker)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg docker", err))
				}
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var platform dagger.Platform
			if inputArgs["platform"] != nil {
				err = json.Unmarshal([]byte(inputArgs["platform"]), &platform)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg platform", err))
				}
			}
			var gpuSupport bool
			if inputArgs["gpuSupport"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpuSupport"]), &gpuSupport)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpuSupport", err))
				}
			}
			return (*EngineDev).LoadToDocker(&parent, ctx, docker, name, platform, gpuSupport)
		case "NetworkCidr":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).NetworkCidr(&parent), nil
		case "Playground":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var base *dagger.Container
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			var gpuSupport bool
			if inputArgs["gpuSupport"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpuSupport"]), &gpuSupport)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpuSupport", err))
				}
			}
			var sharedCache bool
			if inputArgs["sharedCache"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sharedCache"]), &sharedCache)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sharedCache", err))
				}
			}
			var metrics bool
			if inputArgs["metrics"] != nil {
				err = json.Unmarshal([]byte(inputArgs["metrics"]), &metrics)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg metrics", err))
				}
			}
			return (*EngineDev).Playground(&parent, ctx, base, gpuSupport, sharedCache, metrics)
		case "Publish":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var image string
			if inputArgs["image"] != nil {
				err = json.Unmarshal([]byte(inputArgs["image"]), &image)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg image", err))
				}
			}
			var tag []string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			var registryUsername *string
			if inputArgs["registryUsername"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryUsername"]), &registryUsername)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryUsername", err))
				}
			}
			var registryPassword *dagger.Secret
			if inputArgs["registryPassword"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryPassword"]), &registryPassword)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryPassword", err))
				}
			}
			return nil, (*EngineDev).Publish(&parent, ctx, image, tag, dryRun, registryUsername, registryPassword)
		case "ReleaseDryRun":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*EngineDev).ReleaseDryRun(&parent, ctx)
		case "Service":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var gpuSupport bool
			if inputArgs["gpuSupport"] != nil {
				err = json.Unmarshal([]byte(inputArgs["gpuSupport"]), &gpuSupport)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg gpuSupport", err))
				}
			}
			var sharedCache bool
			if inputArgs["sharedCache"] != nil {
				err = json.Unmarshal([]byte(inputArgs["sharedCache"]), &sharedCache)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg sharedCache", err))
				}
			}
			var metrics bool
			if inputArgs["metrics"] != nil {
				err = json.Unmarshal([]byte(inputArgs["metrics"]), &metrics)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg metrics", err))
				}
			}
			return (*EngineDev).Service(&parent, ctx, name, gpuSupport, sharedCache, metrics)
		case "Test":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var run string
			if inputArgs["run"] != nil {
				err = json.Unmarshal([]byte(inputArgs["run"]), &run)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg run", err))
				}
			}
			var skip string
			if inputArgs["skip"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skip"]), &skip)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skip", err))
				}
			}
			var pkg string
			if inputArgs["pkg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pkg"]), &pkg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pkg", err))
				}
			}
			var failfast bool
			if inputArgs["failfast"] != nil {
				err = json.Unmarshal([]byte(inputArgs["failfast"]), &failfast)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg failfast", err))
				}
			}
			var parallel int
			if inputArgs["parallel"] != nil {
				err = json.Unmarshal([]byte(inputArgs["parallel"]), &parallel)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg parallel", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var race bool
			if inputArgs["race"] != nil {
				err = json.Unmarshal([]byte(inputArgs["race"]), &race)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg race", err))
				}
			}
			var count int
			if inputArgs["count"] != nil {
				err = json.Unmarshal([]byte(inputArgs["count"]), &count)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg count", err))
				}
			}
			var envFile *dagger.Secret
			if inputArgs["envFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envFile"]), &envFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envFile", err))
				}
			}
			var testVerbose bool
			if inputArgs["testVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testVerbose"]), &testVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testVerbose", err))
				}
			}
			var update bool
			if inputArgs["update"] != nil {
				err = json.Unmarshal([]byte(inputArgs["update"]), &update)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg update", err))
				}
			}
			return nil, (*EngineDev).Test(&parent, ctx, run, skip, pkg, failfast, parallel, timeout, race, count, envFile, testVerbose, update)
		case "TestDump":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var run string
			if inputArgs["run"] != nil {
				err = json.Unmarshal([]byte(inputArgs["run"]), &run)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg run", err))
				}
			}
			var skip string
			if inputArgs["skip"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skip"]), &skip)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skip", err))
				}
			}
			var pkg string
			if inputArgs["pkg"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pkg"]), &pkg)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pkg", err))
				}
			}
			var failfast bool
			if inputArgs["failfast"] != nil {
				err = json.Unmarshal([]byte(inputArgs["failfast"]), &failfast)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg failfast", err))
				}
			}
			var parallel int
			if inputArgs["parallel"] != nil {
				err = json.Unmarshal([]byte(inputArgs["parallel"]), &parallel)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg parallel", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var race bool
			if inputArgs["race"] != nil {
				err = json.Unmarshal([]byte(inputArgs["race"]), &race)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg race", err))
				}
			}
			var count int
			if inputArgs["count"] != nil {
				err = json.Unmarshal([]byte(inputArgs["count"]), &count)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg count", err))
				}
			}
			var testVerbose bool
			if inputArgs["testVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testVerbose"]), &testVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testVerbose", err))
				}
			}
			var route string
			if inputArgs["route"] != nil {
				err = json.Unmarshal([]byte(inputArgs["route"]), &route)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg route", err))
				}
			}
			var noFinal bool
			if inputArgs["noFinal"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noFinal"]), &noFinal)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noFinal", err))
				}
			}
			var delay string
			if inputArgs["delay"] != nil {
				err = json.Unmarshal([]byte(inputArgs["delay"]), &delay)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg delay", err))
				}
			}
			var interval string
			if inputArgs["interval"] != nil {
				err = json.Unmarshal([]byte(inputArgs["interval"]), &interval)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg interval", err))
				}
			}
			return (*EngineDev).TestDump(&parent, ctx, run, skip, pkg, failfast, parallel, timeout, race, count, testVerbose, route, noFinal, delay, interval)
		case "TestTelemetry":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var run string
			if inputArgs["run"] != nil {
				err = json.Unmarshal([]byte(inputArgs["run"]), &run)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg run", err))
				}
			}
			var skip string
			if inputArgs["skip"] != nil {
				err = json.Unmarshal([]byte(inputArgs["skip"]), &skip)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg skip", err))
				}
			}
			var update bool
			if inputArgs["update"] != nil {
				err = json.Unmarshal([]byte(inputArgs["update"]), &update)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg update", err))
				}
			}
			var failfast bool
			if inputArgs["failfast"] != nil {
				err = json.Unmarshal([]byte(inputArgs["failfast"]), &failfast)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg failfast", err))
				}
			}
			var parallel int
			if inputArgs["parallel"] != nil {
				err = json.Unmarshal([]byte(inputArgs["parallel"]), &parallel)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg parallel", err))
				}
			}
			var timeout string
			if inputArgs["timeout"] != nil {
				err = json.Unmarshal([]byte(inputArgs["timeout"]), &timeout)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg timeout", err))
				}
			}
			var race bool
			if inputArgs["race"] != nil {
				err = json.Unmarshal([]byte(inputArgs["race"]), &race)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg race", err))
				}
			}
			var count int
			if inputArgs["count"] != nil {
				err = json.Unmarshal([]byte(inputArgs["count"]), &count)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg count", err))
				}
			}
			var envFile *dagger.Secret
			if inputArgs["envFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["envFile"]), &envFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg envFile", err))
				}
			}
			var testVerbose bool
			if inputArgs["testVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["testVerbose"]), &testVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg testVerbose", err))
				}
			}
			return (*EngineDev).TestTelemetry(&parent, ctx, run, skip, update, failfast, parallel, timeout, race, count, envFile, testVerbose)
		case "Tests":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).Tests(&parent, ctx)
		case "WithBuildkitConfig":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var key string
			if inputArgs["key"] != nil {
				err = json.Unmarshal([]byte(inputArgs["key"]), &key)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg key", err))
				}
			}
			var value string
			if inputArgs["value"] != nil {
				err = json.Unmarshal([]byte(inputArgs["value"]), &value)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg value", err))
				}
			}
			return (*EngineDev).WithBuildkitConfig(&parent, key, value), nil
		case "WithLogLevel":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var level string
			if inputArgs["level"] != nil {
				err = json.Unmarshal([]byte(inputArgs["level"]), &level)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg level", err))
				}
			}
			return (*EngineDev).WithLogLevel(&parent, level), nil
		case "WithRace":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*EngineDev).WithRace(&parent), nil
		case "":
			var parent EngineDev
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			var subnetNumber int
			if inputArgs["subnetNumber"] != nil {
				err = json.Unmarshal([]byte(inputArgs["subnetNumber"]), &subnetNumber)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg subnetNumber", err))
				}
			}
			var clientDockerConfig *dagger.Secret
			if inputArgs["clientDockerConfig"] != nil {
				err = json.Unmarshal([]byte(inputArgs["clientDockerConfig"]), &clientDockerConfig)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg clientDockerConfig", err))
				}
			}
			return New(source, subnetNumber, clientDockerConfig), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "LoadedEngine":
		switch fnName {
		case "Start":
			var parent LoadedEngine
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var cloudToken *dagger.Secret
			if inputArgs["cloudToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cloudToken"]), &cloudToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cloudToken", err))
				}
			}
			var cloudUrl string
			if inputArgs["cloudURL"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cloudURL"]), &cloudUrl)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cloudURL", err))
				}
			}
			var debug bool
			if inputArgs["debug"] != nil {
				err = json.Unmarshal([]byte(inputArgs["debug"]), &debug)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg debug", err))
				}
			}
			var extraHosts []string
			if inputArgs["extraHosts"] != nil {
				err = json.Unmarshal([]byte(inputArgs["extraHosts"]), &extraHosts)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg extraHosts", err))
				}
			}
			return nil, (*LoadedEngine).Start(&parent, ctx, name, cloudToken, cloudUrl, debug, extraHosts)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
