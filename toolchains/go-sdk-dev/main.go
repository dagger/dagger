package main

import (
	"context"
	"dagger/go-sdk-dev/internal/dagger"
	"fmt"
	"strings"
)

//type GoSdkDev struct{}

type GoSdkDev struct {
	Workspace  *dagger.Directory //+private
	SourcePath string            // +private
}

// Develop the Dagger Go SDK
func New(
	// Workspace to develop the Go SDK
	// +defaultPath="/"
	// +ignore=[
	//  "*",
	//  "!sdk/go",
	//  "!**/go.mod",
	//  "!**/go.sum",
	//  "!cmd/codegen",
	//  "!engine/slog"
	// ]
	workspace *dagger.Directory,
	// Path of the Go SDK source within the workspace
	// +default="sdk/go"
	sourcePath string,
) *GoSdkDev {
	return &GoSdkDev{
		Workspace:  workspace,
		SourcePath: sourcePath,
	}
}

// Build a container to run the go toolchain
func (t GoSdkDev) DevContainer() *dagger.Container {
	ctr := dag.Go(dagger.GoOpts{Source: t.Source()}).
		Env().
		WithWorkdir(t.SourcePath)
	// "sdk" is an arbitrary name for state persistence
	devEngine := dag.DaggerEngine().Service("sdk")
	return dag.DaggerEngine().InstallClient(ctr, devEngine)
}

func (t GoSdkDev) Source() *dagger.Directory {
	return t.Workspace.Directory(t.SourcePath)
}

// Test the Go SDK
func (t GoSdkDev) Test(ctx context.Context) (MyCheckStatus, error) {
	// FIXME: merge into common go toolchain
	_, err := t.DevContainer().
		WithExec([]string{"go", "test", "-v", "-skip=TestProvision", "./..."}).
		Sync(ctx)
	return CheckCompleted, err
}

// Regenerate the Go SDK API
func (t GoSdkDev) Generate(ctx context.Context) (*dagger.Changeset, error) {
	return t.DevContainer().
		WithExec([]string{"go", "generate", "-v", "./..."}).
		WithExec([]string{"go", "mod", "tidy"}).
		Directory("../.."). // pop back to repo root
		Changes(t.Source()).
		Sync(ctx)
}

// Test the release
// +check
func (t GoSdkDev) ReleaseDryRun(
	ctx context.Context,
	// Git repository to fake-release
	// +defaultPath="/"
	sourceRepo *dagger.GitRepository,
	// Git tag to fake-release
	// +default="HEAD"
	sourceTag string,
	// Git remote to fake-release to
	// +default="https://github.com/dagger/dagger-go-sdk.git"
	dest string,
	// +defaultPath="./git-filter-callback.py"
	callback *dagger.File,
) (MyCheckStatus, error) {
	version := strings.TrimPrefix(sourceTag, t.SourcePath)
	return CheckCompleted, dag.GitReleaser().DryRun(
		ctx,
		sourceRepo,
		dagger.GitReleaserDryRunOpts{
			SourceTag: sourceTag,
			Dest:      dest,
			DestTag:   version,
			Callback:  callback,
		})
}

// Publish the Go SDK
func (t GoSdkDev) Release(
	ctx context.Context,
	// Git repository to publish from
	// +defaultPath="/"
	sourceRepo *dagger.GitRepository,
	// The git tag to release from
	sourceTag string,
	// The git remote to publish to
	// +default="https://github.com/dagger/dagger-go-sdk.git"
	dest string,
	// +optional
	githubToken *dagger.Secret,
	// +defaultPath="./go-git-filter-callback.py"
	callback *dagger.File,
) error {
	version := strings.TrimPrefix(sourceTag, t.SourcePath)
	return dag.GitReleaser().Release(ctx,
		sourceRepo,
		dest,
		sourceTag,
		dagger.GitReleaserReleaseOpts{
			SourcePath:  t.SourcePath,
			Callback:    callback,
			DestTag:     version,
			GithubToken: githubToken,
		})
}

// Bump the Go SDK's Engine dependency
func (t GoSdkDev) Bump(_ context.Context, version string) (*dagger.Changeset, error) {
	// trim leading v from version
	version = strings.TrimPrefix(version, "v")

	versionFile := fmt.Sprintf(`// Code generated by dagger. DO NOT EDIT.

package engineconn

const CLIVersion = %q
`, version)

	layer := t.Workspace.WithNewFile("sdk/go/engineconn/version.gen.go", versionFile)
	return layer.Changes(t.Workspace), nil
}
