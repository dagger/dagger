// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"toolchains/release/internal/dagger"
	"toolchains/release/internal/querybuilder"
	"toolchains/release/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Release) MarshalJSON() ([]byte, error) {
	var concrete struct{}
	return json.Marshal(&concrete)
}

func (r *Release) UnmarshalJSON(bs []byte) error {
	var concrete struct{}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	return nil
}

func (r ReleaseReport) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Ref       string
		Commit    string
		Version   string
		Date      string
		Artifacts []*ReleaseReportArtifact
		FollowUps []*ReleaseReportFollowUp
		Errors    []*dagger.Error
	}
	concrete.Ref = r.Ref
	concrete.Commit = r.Commit
	concrete.Version = r.Version
	concrete.Date = r.Date
	concrete.Artifacts = r.Artifacts
	concrete.FollowUps = r.FollowUps
	concrete.Errors = r.Errors
	return json.Marshal(&concrete)
}

func (r *ReleaseReport) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Ref       string
		Commit    string
		Version   string
		Date      string
		Artifacts []*ReleaseReportArtifact
		FollowUps []*ReleaseReportFollowUp
		Errors    []*dagger.Error
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Ref = concrete.Ref
	r.Commit = concrete.Commit
	r.Version = concrete.Version
	r.Date = concrete.Date
	r.Artifacts = concrete.Artifacts
	r.FollowUps = concrete.FollowUps
	r.Errors = concrete.Errors
	return nil
}

func (r ReleaseReportArtifact) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name   string
		Tag    string
		Link   string
		Errors []*dagger.Error
		Notify bool
	}
	concrete.Name = r.Name
	concrete.Tag = r.Tag
	concrete.Link = r.Link
	concrete.Errors = r.Errors
	concrete.Notify = r.Notify
	return json.Marshal(&concrete)
}

func (r *ReleaseReportArtifact) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name   string
		Tag    string
		Link   string
		Errors []*dagger.Error
		Notify bool
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Tag = concrete.Tag
	r.Link = concrete.Link
	r.Errors = concrete.Errors
	r.Notify = concrete.Notify
	return nil
}

func (r ReleaseReportFollowUp) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Name string
		Link string
	}
	concrete.Name = r.Name
	concrete.Link = r.Link
	return json.Marshal(&concrete)
}

func (r *ReleaseReportFollowUp) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Name string
		Link string
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Name = concrete.Name
	r.Link = concrete.Link
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Release":
		switch fnName {
		case "GetMaintainers":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var githubOrgName string
			if inputArgs["githubOrgName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["githubOrgName"]), &githubOrgName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg githubOrgName", err))
				}
			}
			var githubToken *dagger.Secret
			if inputArgs["githubToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["githubToken"]), &githubToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg githubToken", err))
				}
			}
			return (*Release).GetMaintainers(&parent, ctx, githubOrgName, githubToken)
		case "Publish":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var commit string
			if inputArgs["commit"] != nil {
				err = json.Unmarshal([]byte(inputArgs["commit"]), &commit)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg commit", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			var registryImage string
			if inputArgs["registryImage"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryImage"]), &registryImage)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryImage", err))
				}
			}
			var registryUsername string
			if inputArgs["registryUsername"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryUsername"]), &registryUsername)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryUsername", err))
				}
			}
			var registryPassword *dagger.Secret
			if inputArgs["registryPassword"] != nil {
				err = json.Unmarshal([]byte(inputArgs["registryPassword"]), &registryPassword)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg registryPassword", err))
				}
			}
			var goreleaserKey *dagger.Secret
			if inputArgs["goreleaserKey"] != nil {
				err = json.Unmarshal([]byte(inputArgs["goreleaserKey"]), &goreleaserKey)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg goreleaserKey", err))
				}
			}
			var githubToken *dagger.Secret
			if inputArgs["githubToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["githubToken"]), &githubToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg githubToken", err))
				}
			}
			var githubOrgName string
			if inputArgs["githubOrgName"] != nil {
				err = json.Unmarshal([]byte(inputArgs["githubOrgName"]), &githubOrgName)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg githubOrgName", err))
				}
			}
			var netlifyToken *dagger.Secret
			if inputArgs["netlifyToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["netlifyToken"]), &netlifyToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg netlifyToken", err))
				}
			}
			var pypiToken *dagger.Secret
			if inputArgs["pypiToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pypiToken"]), &pypiToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pypiToken", err))
				}
			}
			var pypiRepo string
			if inputArgs["pypiRepo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pypiRepo"]), &pypiRepo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pypiRepo", err))
				}
			}
			var npmToken *dagger.Secret
			if inputArgs["npmToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["npmToken"]), &npmToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg npmToken", err))
				}
			}
			var hexApikey *dagger.Secret
			if inputArgs["hexAPIKey"] != nil {
				err = json.Unmarshal([]byte(inputArgs["hexAPIKey"]), &hexApikey)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg hexAPIKey", err))
				}
			}
			var cargoRegistryToken *dagger.Secret
			if inputArgs["cargoRegistryToken"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cargoRegistryToken"]), &cargoRegistryToken)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cargoRegistryToken", err))
				}
			}
			var awsAccessKeyId *dagger.Secret
			if inputArgs["awsAccessKeyID"] != nil {
				err = json.Unmarshal([]byte(inputArgs["awsAccessKeyID"]), &awsAccessKeyId)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg awsAccessKeyID", err))
				}
			}
			var awsSecretAccessKey *dagger.Secret
			if inputArgs["awsSecretAccessKey"] != nil {
				err = json.Unmarshal([]byte(inputArgs["awsSecretAccessKey"]), &awsSecretAccessKey)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg awsSecretAccessKey", err))
				}
			}
			var awsRegion string
			if inputArgs["awsRegion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["awsRegion"]), &awsRegion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg awsRegion", err))
				}
			}
			var awsBucket string
			if inputArgs["awsBucket"] != nil {
				err = json.Unmarshal([]byte(inputArgs["awsBucket"]), &awsBucket)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg awsBucket", err))
				}
			}
			var awsCloudfrontDistribution string
			if inputArgs["awsCloudfrontDistribution"] != nil {
				err = json.Unmarshal([]byte(inputArgs["awsCloudfrontDistribution"]), &awsCloudfrontDistribution)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg awsCloudfrontDistribution", err))
				}
			}
			var artefactsFqdn string
			if inputArgs["artefactsFQDN"] != nil {
				err = json.Unmarshal([]byte(inputArgs["artefactsFQDN"]), &artefactsFqdn)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg artefactsFQDN", err))
				}
			}
			var discordWebhook *dagger.Secret
			if inputArgs["discordWebhook"] != nil {
				err = json.Unmarshal([]byte(inputArgs["discordWebhook"]), &discordWebhook)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg discordWebhook", err))
				}
			}
			return (*Release).Publish(&parent, ctx, tag, commit, dryRun, registryImage, registryUsername, registryPassword, goreleaserKey, githubToken, githubOrgName, netlifyToken, pypiToken, pypiRepo, npmToken, hexApikey, cargoRegistryToken, awsAccessKeyId, awsSecretAccessKey, awsRegion, awsBucket, awsCloudfrontDistribution, artefactsFqdn, discordWebhook)
		case "Notify":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var repository string
			if inputArgs["repository"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repository"]), &repository)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repository", err))
				}
			}
			var target string
			if inputArgs["target"] != nil {
				err = json.Unmarshal([]byte(inputArgs["target"]), &target)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg target", err))
				}
			}
			var name string
			if inputArgs["name"] != nil {
				err = json.Unmarshal([]byte(inputArgs["name"]), &name)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg name", err))
				}
			}
			var discordWebhook *dagger.Secret
			if inputArgs["discordWebhook"] != nil {
				err = json.Unmarshal([]byte(inputArgs["discordWebhook"]), &discordWebhook)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg discordWebhook", err))
				}
			}
			var dryRun bool
			if inputArgs["dryRun"] != nil {
				err = json.Unmarshal([]byte(inputArgs["dryRun"]), &dryRun)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg dryRun", err))
				}
			}
			return nil, (*Release).Notify(&parent, ctx, repository, target, name, discordWebhook, dryRun)
		case "Bump":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var engineVersion string
			if inputArgs["engineVersion"] != nil {
				err = json.Unmarshal([]byte(inputArgs["engineVersion"]), &engineVersion)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg engineVersion", err))
				}
			}
			return (*Release).Bump(&parent, ctx, engineVersion)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "ReleaseReport":
		switch fnName {
		case "Markdown":
			var parent ReleaseReport
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*ReleaseReport).Markdown(&parent, ctx)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
