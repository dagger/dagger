// Code generated by dagger. DO NOT EDIT.

package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sort"

	"github.com/vektah/gqlparser/v2/gqlerror"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"

	"dagger/gh/internal/dagger"
	"dagger/gh/internal/querybuilder"
	"dagger/gh/internal/telemetry"
)

var dag = dagger.Connect()

func Tracer() trace.Tracer {
	return otel.Tracer("dagger.io/sdk.go")
}

// used for local MarshalJSON implementations
var marshalCtx = context.Background()

// called by main()
func setMarshalContext(ctx context.Context) {
	marshalCtx = ctx
	dagger.SetMarshalContext(ctx)
}

type DaggerObject = querybuilder.GraphQLMarshaller

type ExecError = dagger.ExecError

// ptr returns a pointer to the given value.
func ptr[T any](v T) *T {
	return &v
}

// convertSlice converts a slice of one type to a slice of another type using a
// converter function
func convertSlice[I any, O any](in []I, f func(I) O) []O {
	out := make([]O, len(in))
	for i, v := range in {
		out[i] = f(v)
	}
	return out
}

func (r Gh) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Token      *dagger.Secret
		Repository string
		Source     *dagger.Directory
	}
	concrete.Token = r.Token
	concrete.Repository = r.Repository
	concrete.Source = r.Source
	return json.Marshal(&concrete)
}

func (r *Gh) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Token      *dagger.Secret
		Repository string
		Source     *dagger.Directory
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Token = concrete.Token
	r.Repository = concrete.Repository
	r.Source = concrete.Source
	return nil
}

func (r Repo) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Gh *Gh
	}
	concrete.Gh = r.Gh
	return json.Marshal(&concrete)
}

func (r *Repo) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Gh *Gh
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Gh = concrete.Gh
	return nil
}

func (r PullRequest) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Gh *Gh
	}
	concrete.Gh = r.Gh
	return json.Marshal(&concrete)
}

func (r *PullRequest) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Gh *Gh
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Gh = concrete.Gh
	return nil
}

func (r Release) MarshalJSON() ([]byte, error) {
	var concrete struct {
		Gh *Gh
	}
	concrete.Gh = r.Gh
	return json.Marshal(&concrete)
}

func (r *Release) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		Gh *Gh
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.Gh = concrete.Gh
	return nil
}

func (r PullRequestReview) MarshalJSON() ([]byte, error) {
	var concrete struct {
		PullRequest string
		Body        string
		BodyFile    *dagger.File
		Gh          *Gh
	}
	concrete.PullRequest = r.PullRequest
	concrete.Body = r.Body
	concrete.BodyFile = r.BodyFile
	concrete.Gh = r.Gh
	return json.Marshal(&concrete)
}

func (r *PullRequestReview) UnmarshalJSON(bs []byte) error {
	var concrete struct {
		PullRequest string
		Body        string
		BodyFile    *dagger.File
		Gh          *Gh
	}
	err := json.Unmarshal(bs, &concrete)
	if err != nil {
		return err
	}
	r.PullRequest = concrete.PullRequest
	r.Body = concrete.Body
	r.BodyFile = concrete.BodyFile
	r.Gh = concrete.Gh
	return nil
}

func (r Latest) IsEnum() {}

func (r Latest) Name() string {
	switch r {
	case LatestAuto:
		return "Auto"
	case LatestFalse:
		return "False"
	case LatestTrue:
		return "True"
	}
	return ""
}

func (r Latest) Value() string {
	return string(r)
}

func (r Latest) MarshalJSON() ([]byte, error) {
	if r == "" {
		return []byte("\"\""), nil
	}
	name := r.Name()
	if name == "" {
		return nil, fmt.Errorf("invalid enum value %q", r)
	}
	return json.Marshal(name)
}

func (r *Latest) UnmarshalJSON(bs []byte) error {
	var s string
	err := json.Unmarshal(bs, &s)
	if err != nil {
		return err
	}
	switch s {
	case "":
		*r = ""
	case "True":
		*r = LatestTrue
	case "False":
		*r = LatestFalse
	case "Auto":
		*r = LatestAuto
	default:
		return fmt.Errorf("invalid enum value %q", s)
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Direct slog to the new stderr. This is only for dev time debugging, and
	// runtime errors/warnings.
	slog.SetDefault(slog.New(slog.NewTextHandler(os.Stderr, &slog.HandlerOptions{
		Level: slog.LevelWarn,
	})))

	if err := dispatch(ctx); err != nil {
		os.Exit(2)
	}
}

func convertError(rerr error) *dagger.Error {
	if gqlErr := findSingleGQLError(rerr); gqlErr != nil {
		dagErr := dag.Error(gqlErr.Message)
		if gqlErr.Extensions != nil {
			keys := make([]string, 0, len(gqlErr.Extensions))
			for k := range gqlErr.Extensions {
				keys = append(keys, k)
			}
			sort.Strings(keys)
			for _, k := range keys {
				val, err := json.Marshal(gqlErr.Extensions[k])
				if err != nil {
					fmt.Println("failed to marshal error value:", err)
				}
				dagErr = dagErr.WithValue(k, dagger.JSON(val))
			}
		}
		return dagErr
	}
	return dag.Error(rerr.Error())
}

func findSingleGQLError(rerr error) *gqlerror.Error {
	switch x := rerr.(type) {
	case *gqlerror.Error:
		return x
	case interface{ Unwrap() []error }:
		return nil
	case interface{ Unwrap() error }:
		return findSingleGQLError(x.Unwrap())
	default:
		return nil
	}
}
func dispatch(ctx context.Context) (rerr error) {
	ctx = telemetry.InitEmbedded(ctx, resource.NewWithAttributes(
		semconv.SchemaURL,
		semconv.ServiceNameKey.String("dagger-go-sdk"),
		// TODO version?
	))
	defer telemetry.Close()

	// A lot of the "work" actually happens when we're marshalling the return
	// value, which entails getting object IDs, which happens in MarshalJSON,
	// which has no ctx argument, so we use this lovely global variable.
	setMarshalContext(ctx)

	fnCall := dag.CurrentFunctionCall()
	defer func() {
		if rerr != nil {
			if err := fnCall.ReturnError(ctx, convertError(rerr)); err != nil {
				fmt.Println("failed to return error:", err, "\noriginal error:", rerr)
			}
		}
	}()

	parentName, err := fnCall.ParentName(ctx)
	if err != nil {
		return fmt.Errorf("get parent name: %w", err)
	}
	fnName, err := fnCall.Name(ctx)
	if err != nil {
		return fmt.Errorf("get fn name: %w", err)
	}
	parentJson, err := fnCall.Parent(ctx)
	if err != nil {
		return fmt.Errorf("get fn parent: %w", err)
	}
	fnArgs, err := fnCall.InputArgs(ctx)
	if err != nil {
		return fmt.Errorf("get fn args: %w", err)
	}

	inputArgs := map[string][]byte{}
	for _, fnArg := range fnArgs {
		argName, err := fnArg.Name(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg name: %w", err)
		}
		argValue, err := fnArg.Value(ctx)
		if err != nil {
			return fmt.Errorf("get fn arg value: %w", err)
		}
		inputArgs[argName] = []byte(argValue)
	}

	result, err := invoke(ctx, []byte(parentJson), parentName, fnName, inputArgs)
	if err != nil {
		return err
	}
	resultBytes, err := json.Marshal(result)
	if err != nil {
		return fmt.Errorf("marshal: %w", err)
	}

	if err := fnCall.ReturnValue(ctx, dagger.JSON(resultBytes)); err != nil {
		return fmt.Errorf("store return value: %w", err)
	}
	return nil
}
func invoke(ctx context.Context, parentJSON []byte, parentName string, fnName string, inputArgs map[string][]byte) (_ any, err error) {
	_ = inputArgs
	switch parentName {
	case "Gh":
		switch fnName {
		case "Repo":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Gh).Repo(&parent), nil
		case "WithToken":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			return (*Gh).WithToken(&parent, token), nil
		case "WithRepo":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*Gh).WithRepo(&parent, repo)
		case "WithSource":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			return (*Gh).WithSource(&parent, source), nil
		case "Clone":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*Gh).Clone(&parent, repo)
		case "Run":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var cmd string
			if inputArgs["cmd"] != nil {
				err = json.Unmarshal([]byte(inputArgs["cmd"]), &cmd)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg cmd", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*Gh).Run(&parent, cmd, token, repo), nil
		case "Exec":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var args []string
			if inputArgs["args"] != nil {
				err = json.Unmarshal([]byte(inputArgs["args"]), &args)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg args", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*Gh).Exec(&parent, args, token, repo), nil
		case "WithGitExec":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var args []string
			if inputArgs["args"] != nil {
				err = json.Unmarshal([]byte(inputArgs["args"]), &args)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg args", err))
				}
			}
			return (*Gh).WithGitExec(&parent, args)
		case "Terminal":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*Gh).Terminal(&parent, token, repo), nil
		case "PullRequest":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Gh).PullRequest(&parent), nil
		case "Release":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return (*Gh).Release(&parent), nil
		case "":
			var parent Gh
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			var source *dagger.Directory
			if inputArgs["source"] != nil {
				err = json.Unmarshal([]byte(inputArgs["source"]), &source)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg source", err))
				}
			}
			return New(token, repo, source), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "PullRequest":
		switch fnName {
		case "Create":
			var parent PullRequest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var assignees []string
			if inputArgs["assignees"] != nil {
				err = json.Unmarshal([]byte(inputArgs["assignees"]), &assignees)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg assignees", err))
				}
			}
			var base string
			if inputArgs["base"] != nil {
				err = json.Unmarshal([]byte(inputArgs["base"]), &base)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg base", err))
				}
			}
			var body string
			if inputArgs["body"] != nil {
				err = json.Unmarshal([]byte(inputArgs["body"]), &body)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg body", err))
				}
			}
			var bodyFile *dagger.File
			if inputArgs["bodyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["bodyFile"]), &bodyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg bodyFile", err))
				}
			}
			var draft bool
			if inputArgs["draft"] != nil {
				err = json.Unmarshal([]byte(inputArgs["draft"]), &draft)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg draft", err))
				}
			}
			var fill bool
			if inputArgs["fill"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fill"]), &fill)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fill", err))
				}
			}
			var fillFirst bool
			if inputArgs["fillFirst"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fillFirst"]), &fillFirst)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fillFirst", err))
				}
			}
			var fillVerbose bool
			if inputArgs["fillVerbose"] != nil {
				err = json.Unmarshal([]byte(inputArgs["fillVerbose"]), &fillVerbose)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg fillVerbose", err))
				}
			}
			var head string
			if inputArgs["head"] != nil {
				err = json.Unmarshal([]byte(inputArgs["head"]), &head)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg head", err))
				}
			}
			var labels []string
			if inputArgs["labels"] != nil {
				err = json.Unmarshal([]byte(inputArgs["labels"]), &labels)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg labels", err))
				}
			}
			var milestone string
			if inputArgs["milestone"] != nil {
				err = json.Unmarshal([]byte(inputArgs["milestone"]), &milestone)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg milestone", err))
				}
			}
			var noMaintainerEdit bool
			if inputArgs["noMaintainerEdit"] != nil {
				err = json.Unmarshal([]byte(inputArgs["noMaintainerEdit"]), &noMaintainerEdit)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg noMaintainerEdit", err))
				}
			}
			var projects []string
			if inputArgs["projects"] != nil {
				err = json.Unmarshal([]byte(inputArgs["projects"]), &projects)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg projects", err))
				}
			}
			var reviewers []string
			if inputArgs["reviewers"] != nil {
				err = json.Unmarshal([]byte(inputArgs["reviewers"]), &reviewers)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg reviewers", err))
				}
			}
			var template *dagger.File
			if inputArgs["template"] != nil {
				err = json.Unmarshal([]byte(inputArgs["template"]), &template)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg template", err))
				}
			}
			var title string
			if inputArgs["title"] != nil {
				err = json.Unmarshal([]byte(inputArgs["title"]), &title)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg title", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return nil, (*PullRequest).Create(&parent, ctx, assignees, base, body, bodyFile, draft, fill, fillFirst, fillVerbose, head, labels, milestone, noMaintainerEdit, projects, reviewers, template, title, token, repo)
		case "Exists":
			var parent PullRequest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var pullRequest string
			if inputArgs["pullRequest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pullRequest"]), &pullRequest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pullRequest", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return (*PullRequest).Exists(&parent, ctx, pullRequest, token, repo)
		case "Review":
			var parent PullRequest
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var pullRequest string
			if inputArgs["pullRequest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["pullRequest"]), &pullRequest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg pullRequest", err))
				}
			}
			var body string
			if inputArgs["body"] != nil {
				err = json.Unmarshal([]byte(inputArgs["body"]), &body)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg body", err))
				}
			}
			var bodyFile *dagger.File
			if inputArgs["bodyFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["bodyFile"]), &bodyFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg bodyFile", err))
				}
			}
			return (*PullRequest).Review(&parent, pullRequest, body, bodyFile), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "PullRequestReview":
		switch fnName {
		case "Approve":
			var parent PullRequestReview
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*PullRequestReview).Approve(&parent, ctx)
		case "Comment":
			var parent PullRequestReview
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*PullRequestReview).Comment(&parent, ctx)
		case "RequestChanges":
			var parent PullRequestReview
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			return nil, (*PullRequestReview).RequestChanges(&parent, ctx)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Release":
		switch fnName {
		case "Create":
			var parent Release
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var tag string
			if inputArgs["tag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["tag"]), &tag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg tag", err))
				}
			}
			var title string
			if inputArgs["title"] != nil {
				err = json.Unmarshal([]byte(inputArgs["title"]), &title)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg title", err))
				}
			}
			var files []*dagger.File
			if inputArgs["files"] != nil {
				err = json.Unmarshal([]byte(inputArgs["files"]), &files)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg files", err))
				}
			}
			var draft bool
			if inputArgs["draft"] != nil {
				err = json.Unmarshal([]byte(inputArgs["draft"]), &draft)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg draft", err))
				}
			}
			var preRelease bool
			if inputArgs["preRelease"] != nil {
				err = json.Unmarshal([]byte(inputArgs["preRelease"]), &preRelease)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg preRelease", err))
				}
			}
			var target string
			if inputArgs["target"] != nil {
				err = json.Unmarshal([]byte(inputArgs["target"]), &target)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg target", err))
				}
			}
			var notes string
			if inputArgs["notes"] != nil {
				err = json.Unmarshal([]byte(inputArgs["notes"]), &notes)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg notes", err))
				}
			}
			var notesFile *dagger.File
			if inputArgs["notesFile"] != nil {
				err = json.Unmarshal([]byte(inputArgs["notesFile"]), &notesFile)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg notesFile", err))
				}
			}
			var discussionCategory string
			if inputArgs["discussionCategory"] != nil {
				err = json.Unmarshal([]byte(inputArgs["discussionCategory"]), &discussionCategory)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg discussionCategory", err))
				}
			}
			var generateNotes bool
			if inputArgs["generateNotes"] != nil {
				err = json.Unmarshal([]byte(inputArgs["generateNotes"]), &generateNotes)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg generateNotes", err))
				}
			}
			var notesStartTag string
			if inputArgs["notesStartTag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["notesStartTag"]), &notesStartTag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg notesStartTag", err))
				}
			}
			var latest Latest
			if inputArgs["latest"] != nil {
				err = json.Unmarshal([]byte(inputArgs["latest"]), &latest)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg latest", err))
				}
			}
			var verifyTag bool
			if inputArgs["verifyTag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["verifyTag"]), &verifyTag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg verifyTag", err))
				}
			}
			var notesFromTag bool
			if inputArgs["notesFromTag"] != nil {
				err = json.Unmarshal([]byte(inputArgs["notesFromTag"]), &notesFromTag)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg notesFromTag", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			var repo string
			if inputArgs["repo"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repo"]), &repo)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repo", err))
				}
			}
			return nil, (*Release).Create(&parent, ctx, tag, title, files, draft, preRelease, target, notes, notesFile, discussionCategory, generateNotes, notesStartTag, latest, verifyTag, notesFromTag, token, repo)
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	case "Repo":
		switch fnName {
		case "Clone":
			var parent Repo
			err = json.Unmarshal(parentJSON, &parent)
			if err != nil {
				panic(fmt.Errorf("%s: %w", "failed to unmarshal parent object", err))
			}
			var repository string
			if inputArgs["repository"] != nil {
				err = json.Unmarshal([]byte(inputArgs["repository"]), &repository)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg repository", err))
				}
			}
			var args []string
			if inputArgs["args"] != nil {
				err = json.Unmarshal([]byte(inputArgs["args"]), &args)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg args", err))
				}
			}
			var token *dagger.Secret
			if inputArgs["token"] != nil {
				err = json.Unmarshal([]byte(inputArgs["token"]), &token)
				if err != nil {
					panic(fmt.Errorf("%s: %w", "failed to unmarshal input arg token", err))
				}
			}
			return (*Repo).Clone(&parent, repository, args, token), nil
		default:
			return nil, fmt.Errorf("unknown function %s", fnName)
		}
	default:
		return nil, fmt.Errorf("unknown object %s", parentName)
	}
}
