[{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/110632-embed-directories.md","frontMatter":{"slug":"/110632/embed-directories","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Guillaume de Rouville"],"date":"2022-11-04"},"content":"# Copy Embedded Directories into a Container\n\nDagger does not expose the option to copy entire directories as a single step (yet), whether it is between containers or from an embedded directory to a container. It is, however, doable by traversing the directory tree.\n\nAssume that you have a Dagger CI tool containing the following code structure, which contains an example directory:\n\n```shell\ntree\n.\n├── go.mod\n├── go.sum\n├── main.go\n└── example\n    └── foo.go\n```\n\nThe following example demonstrates how to copy an embedded directory:\n\n```go file=./snippets/embed-directories/main.go\n```\n\nAttempt to run the code and print the content of the `/embed` directory:\n\n```shell\n➜  go run .\n/embed/:\ntotal 4\ndrwxr-xr-x    1 root     root          4096 Oct 31 16:49 example\n\n/embed/example:\ntotal 4\n-rw-r--r--    1 root     root            50 Oct 31 16:49 foo.go\n```\n\nIn this case, the function succeeds in copying the embedded `example` directory.\n\n:::warning\nYou may encounter errors if your directory contains +1000 files, due to the concatenation of the queries.\n:::","contentTitle":"Copy Embedded Directories into a Container","excerpt":"Dagger does not expose the option to copy entire directories as a single step (yet), whether it is between containers or from an embedded directory to a container. It is, however, doable by traversing the directory tree.","timestamp":1667520000000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/114934-nodejs-ci.md","frontMatter":{"slug":"/114934/nodejs-ci","displayed_sidebar":"current","category":"guides","tags":["nodejs","gitlab-ci","github-actions","circle-ci","jenkins"],"authors":["Jeremy Adams"],"date":"2022-12-13"},"content":"# Dagger Node.js SDK in CI\n\nimport Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';\n\n<Tabs defaultValue=\"github-actions\"\ngroupId=\"ci-environment\"\nvalues={[\n{label: 'GitHub Actions', value: 'github-actions'},\n{label: 'CircleCI', value: 'circleci'},\n{label: 'GitLab', value: 'gitlab'},\n{label: 'Jenkins', value: 'jenkins'},\n]}>\n\n<TabItem value=\"github-actions\">\n\n```yaml title=\".github/workflows/dagger.yaml\" file=./snippets/nodejs-ci/actions.yml\n```\n\nEnsure that your `package.json` contains `@dagger.io/dagger` which can be installed using the [documentation](../sdk/nodejs/835948/install).\n\n</TabItem>\n\n<TabItem value=\"circleci\">\n\n```yaml title=\".circleci/config.yml\" file=./snippets/nodejs-ci/circle.yml\n```\n\nEnsure that your `package.json` contains `@dagger.io/dagger` which can be installed using the [documentation](../sdk/nodejs/835948/install).\n\n</TabItem>\n\n<TabItem value=\"gitlab\">\n\n```yaml title=\".gitlab-ci.yml\" file=./snippets/nodejs-ci/gitlab.yml\n```\n\nEnsure that your `package.json` contains `@dagger.io/dagger` which can be installed using the [documentation](../sdk/nodejs/835948/install).\n\n</TabItem>\n\n<TabItem value=\"jenkins\">\n\n```groovy title=\"Jenkinsfile\" file=./snippets/nodejs-ci/Jenkinsfile\n```\n\nRequires `docker` client and Node.js installed on your Jenkins agent, a Docker host available (can be `docker:dind`), and agents labeled in Jenkins with `dagger`. Ensure that your `package.json` contains `@dagger.io/dagger` which can be installed using the [documentation](../sdk/nodejs/835948/install).\n\n</TabItem>\n\n</Tabs>","contentTitle":"Dagger Node.js SDK in CI","excerpt":"<Tabs defaultValue=\"github-actions\"","timestamp":1670889600000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/205271-replace-dockerfile.md","frontMatter":{"slug":"/205271/replace-dockerfile","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Kyle Penfound","Vikram Vaswani"],"date":"2023-01-07"},"content":"# Replace a Dockerfile with Go\n\n## Introduction\n\nThis guide explains how to use the Dagger Go SDK to perform all the same operations that you would typically perform with a Dockerfile, except using Go. You will learn how to:\n\n- Create a Dagger client in Go\n- Write a Dagger pipeline in Go to:\n  - Configure a container with all required dependencies and environment variables\n  - Download and build the application source code in the container\n  - Set the container entrypoint\n  - Publish the built container image to Docker Hub\n- Test the Dagger pipeline locally\n\n## Requirements\n\nThis guide assumes that:\n\n- You have a Go development environment with Go 1.15 or later. If not, [download and install Go](https://go.dev/doc/install).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have a Go module with the Dagger Go SDK installed. If not, [install the Dagger Go SDK](../sdk/go/371491-install.md).\n- You have a Docker Hub account. If not, [register for a Docker Hub account](https://hub.docker.com/signup).\n\n## Step 1: Understand the source Dockerfile\n\nTo illustrate the process, this guide replicates the build process for the popular open source [Memcached caching system](https://www.memcached.org/) using Dagger. It uses the Dockerfile and entrypoint script for the [official Docker Hub Memcached image](https://github.com/docker-library/memcached).\n\nBegin by reviewing the [source Dockerfile](https://github.com/docker-library/memcached/blob/1e3f84629bb2ab9975235401c716c1e00563fa82/alpine/Dockerfile) and corresponding [entrypoint script](https://github.com/docker-library/memcached/blob/1e3f84629bb2ab9975235401c716c1e00563fa82/alpine/docker-entrypoint.sh) to understand how it works. This Dockerfile is current at the time of writing and is available under the BSD 3-Clause License.\n\nBroadly, this Dockerfile performs the following steps:\n\n- It starts from a base `alpine` container image.\n- It adds a `memcache` user and group with defined IDs.\n- It sets environment variables for the Memcached version (`MEMCACHED_VERSION`) and commit hash (`MEMCACHED_SHA1`).\n- It installs dependencies in the container.\n- It downloads the source code archive for the specified version of Memcached, checks the commit hash and extracts the source code into a directory.\n- It configures, builds, tests and installs Memcached from source using `make`.\n- It copies and sets the container entrypoint script.\n- It configures the image to run as the `memcache` user.\n\n## Step 2: Replicate the Dockerfile using a Dagger pipeline\n\nThe Dagger Go SDK enables you to develop a CI/CD pipeline in Go to achieve the same result as using a Dockerfile.\n\nTo see how this works, add the following code to your Go module as `main.go`. Replace the DOCKER-HUB-USERNAME placeholder with your Docker Hub username.\n\n```go file=./snippets/replace-dockerfile/main.go\n```\n\n:::warning\nLike the source Dockerfile, this pipeline assumes that the entrypoint script exists in the current  working directory on the host as `docker-entrypoint.sh`. You can either create a custom entrypoint script, or use the [entrypoint script from the Docker Hub Memcached image repository](https://github.com/docker-library/memcached/blob/1e3f84629bb2ab9975235401c716c1e00563fa82/alpine/docker-entrypoint.sh).\n:::\n\nThere's a lot going on here, so let's step through it in detail:\n\n- The Go CI pipeline imports the Dagger SDK and defines a `main()` function. The `main()` function creates a Dagger client with `dagger.Connect()`. This client provides an interface for executing commands against the Dagger engine.\n- It initializes a new container from a base image with the client's `Container().From()` method and returns a new `Container` struct. In this case, the base image is the `alpine:3.17` image.\n- It calls the `withExec()` method to define the `adduser`, `addgroup` and `apk add` commands for execution, and the `WithEnvVariable()` method to set the `MEMCACHED_VERSION` and `MEMCACHED_SHA1` container environment variables.\n- It calls a custom `setDependencies()` function, which internally uses `withExec()` to define the `apk add` command that installs all the required dependencies to build and test Memcached in the container.\n- It calls a custom `downloadMemcached()` function, which internally uses `withExec()` to define the `wget`, `tar` and related commands required to download, verify and extract the Memcached source code archive in the container at the `/usr/src/memcached` container path.\n- It calls a custom `buildMemcached()` function, which internally uses `withExec()` to define the `configure` and `make` commands required to build, test and install Memcached in the container. The `buildMemcached()` function also takes care of deleting the source code directory at `/usr/src/memcached` in the container and executing `memcached -V` to output the version string to the console.\n- It updates the container filesystem to include the entrypoint script from the host using `withFile()` and specifies it as the command to be executed when the container runs using `WithEntrypoint()`.\n- Finally, it calls the `Container.publish()` method, which executes the entire pipeline descried above and publishes the resulting container image to Docker Hub.\n\n## Step 3: Test the Dagger pipeline\n\nTest the Dagger pipeline as follows:\n\n1. Log in to Docker on the host:\n\n  ```shell\n  docker login\n  ```\n\n  :::info\n  This step is necessary because Dagger relies on the host's Docker credentials and authorizations when publishing to remote registries.\n  :::\n\n1. Run the pipeline:\n\n  ```shell\n  go run main.go\n  ```\n\n  :::warning\n  Verify that you have an entrypoint script on the host at `./docker-entrypoint.sh` before running the Dagger pipeline.\n  :::\n\nDagger performs the operations defined in the pipeline script, logging each operation to the console. This process will take some time. At the end of the process, the built container image is published on Docker Hub and a message similar to the one below appears in the console output:\n\n```shell\nPublished to docker.io/.../my-memcached@sha256:692....\n```\n\nBrowse to your Docker Hub registry to see the published Memcached container image.\n\n## Conclusion\n\nThis tutorial introduced you to the Dagger Go SDK. By replacing a Dockerfile with native Go code, it demonstrated how the SDK contains everything you need to develop CI/CD pipelines in Go and run them on any OCI-compatible container runtime.\n\nThe advantage of this approach is that it allows you to use all the poweful native language features of Go, such as static typing, concurrency, programming structures such as loops and conditionals, and built-in testing, to create powerful CI/CD tooling for your project or organization.\n\nUse the [SDK Reference](https://pkg.go.dev/dagger.io/dagger) to learn more about the Dagger Go SDK.","contentTitle":"Replace a Dockerfile with Go","excerpt":"Introduction","timestamp":1673049600000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/406009-multiplatform-support.md","frontMatter":{"slug":"/406009/multiplatform-support","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Erik Sipsma"],"date":"2022-11-20"},"content":"# Understand Multi-Platform Support\n\n## Introduction\n\nDagger supports pulling container images and executing commands on platforms that differ from the underlying host.\n\nFor example, you can use Dagger to compile binaries that target different CPU architectures, test those binaries and push them to a registry bundled as a multi-platform container image, _all on a single host_.\n\nThis document explores these features through the lens of the Go SDK.\n\n## Requirements\n\nThis guide assumes that:\n\n- You have a Go development environment with Go 1.15 or later. If not, [download and install Go](https://go.dev/doc/install).\n- You are familiar with the basics of the Go SDK and have it installed. If not, read the [Go SDK guide](../sdk/go/959738-get-started.md) and the [Go SDK installation instructions](../sdk/go/371491-install.md).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have `binfmt_misc` configured on the host kernel (that is, on the machine where Dagger will run containers). This is necessary to execute binaries in containers that use a different architecture than that of the host.\n\n  If the host is running Docker, this one-liner will setup everything (only needed once per boot cycle):\n\n  ```sh\n  docker run --privileged --rm tonistiigi/binfmt --install all\n  ```\n\n  Learn more in the [`binfmt` documentation](https://github.com/tonistiigi/binfmt/).\n\n  :::note\n  Dagger users running on MacOS can ignore these instructions. By default on MacOS, Dagger will run inside a Linux VM that should already be configured with `binfmt_misc`.\n  :::\n\n## Terminology\n\n### Platform\n\n- A combination of OS and CPU architecture that executable code may target.\n- Registries compatible with the OCI Image Spec support pulling and pushing images with layers for different platforms all bundled together ([see the spec here](https://github.com/opencontainers/image-spec/blob/main/image-index.md#image-index-property-descriptions))\n\n### Emulation\n\n- A technique by which a binary built to target one CPU architecture can be executed on a different CPU architecture via automatic conversion of machine code.\n- Typically quite slow relative to executing on a native CPU.\n- For builds, cross-compilation will generally be much faster when it's an option.\n\n### Cross-compilation\n\n- A technique by which you can build a binary that targets Platform A on a machine of Platform B. I.e. cross-compilation enables you to build a Windows x86_64 binary from a Linux aarch64 host.\n\n## Examples\n\n### Pull images and execute commands for multiple architectures\n\nThis example demonstrates how to pull images for multiple different architectures and execute commands on each of them.\n\n```go file=./snippets/multiplatform-support/pull-images/main.go\n\n```\n\nAs illustrated above, you can optionally initialize a `Container` with a specific platform. That platform will be used to pull images and execute any commands.\n\nIf the platform of the `Container` does not match that of the host, then emulation will be used for any commands specified in `WithExec`.\n\nIf you don't specify a platform, the `Container` will be initialized with a platform matching that of the host.\n\n### Create new multi-platform images\n\nThe next step builds on the previous example by:\n\n1. Building binaries for each of the platforms. We'll use Go binaries for this example.\n1. Combining those binaries into a multi-platform image that we push to a registry.\n\nStart by running builds using emulation. The next example will show the changes needed to instead perform cross-compilation while still building a multi-platform image.\n\n:::note\nThis example will fail to push the final image unless you change the registry to one that you control and have write permissions for.\n:::\n\n```go file=./snippets/multiplatform-support/build-images-emulation/main.go\n\n```\n\n### Use cross-compilation\n\nThe previous example results in emulation being used to build the binary for different architectures.\n\nEmulation is great to have because it requires no customization of build options; the exact same build can be run for different platforms.\n\nHowever, emulation has the downside of being quite slow relative to executing native CPU instructions.\n\nWhile cross-compilation is sometimes much easier said than done, it's a great option for speeding up multi-platform builds when feasible.\n\nFortunately, Go has great built-in support for cross-compilation, so modifying the previous example to use this feature instead is straightforward (changes are highlighted):\n\n```go file=./snippets/multiplatform-support/build-images-cross-compilation/main.go\n\n```\n\nThe only changes we made to enable faster cross-compilation are:\n\n1. Pulling the base `golang` image for the host platform\n1. Configuring the Go compiler to target the specific platform\n\nThe final image is still multi-platform because each `Container` set as a `PlatformVariant` was initialized with a specific platform (after the cross-compilation has occurred, at the bottom of the `for` loop in the code above).\n\n## Support for non-Linux platforms\n\nThe previous examples work with different architectures but the OS of the platform is always `linux`.\n\nAs explored in our [Get Started tutorial](../sdk/go/959738-get-started.md), Dagger can run cross-compilation builds that create binaries targeting other OSes such as Darwin (MacOS) and Windows.\n\nAdditionally, Dagger has _limited_ support for some operations involving non-Linux container images. Specifically, it is often possible to pull these images and perform basic file operations, but attempting to execute commands will result in an error:\n\n```go file=./snippets/multiplatform-support/non-linux-support/main.go\n\n```\n\n:::note\nLearn more about [support for executing commands on non-Linux OSes in this tracking issue](https://github.com/dagger/dagger/issues/3158).\n:::\n\n## FAQ\n\n### What is the default value of platform if I don't specify it?\n\nThe platform will default to that of the machine running your containers.\n\nIf you are running Dagger from MacOS, by default your containers will run in a Linux virtual machine, so your platform will default to either `linux/amd64` (on Intel Macs) or `linux/arm64` (on ARM Macs).\n\n### How do I know the valid values of platform?\n\nThe names of OSes and CPU architectures that we support are inherited from the [OCI image spec](https://github.com/opencontainers/image-spec/blob/main/image-index.md#image-index-property-descriptions), which in turn inherits names used by Go.\n\nYou can see the full list of valid platform strings by running the command `go tool dist list`. Some examples include:\n\n- `linux/386`\n- `linux/amd64`\n- `linux/arm`\n- `linux/arm64`\n- `linux/mips`\n- `linux/mips64`\n- `linux/mips64le`\n- `linux/mipsle`\n- `linux/ppc64`\n- `linux/ppc64le`\n- `linux/riscv64`\n- `linux/s390x`\n- `windows/386`\n- `windows/amd64`\n- `windows/arm`\n- `windows/arm64`\n\nWhether a particular platform can be used successfully with Dagger depends on several factors:\n\n- Whether an image you are pulling has a published version for that platform\n- Whether QEMU emulation is supported for the architecture and has been configured (as described in Requirements above)\n- Whether the OS is Linux (command execution only works on Linux for now)","contentTitle":"Understand Multi-Platform Support","excerpt":"Introduction","timestamp":1668902400000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/421437-work-with-host-filesystem.md","frontMatter":{"slug":"/421437/work-with-host-filesystem","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Alex Suraci","Vikram Vaswani"],"date":"2022-11-01"},"content":"# Work with the Host Filesystem\n\n## Introduction\n\nThis guide explains how to work with the host filesystem using the Dagger Go SDK. You will learn how to:\n\n- Set the working directory on the host\n- List host directory entries with include/exclude filters\n- Mount a host directory in a container\n- Export a directory from a container to the host\n\n## Requirements\n\nThis guide assumes that:\n\n- You have a Go development environment with Go 1.15 or later. If not, [download and install Go](https://go.dev/doc/install).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have a Go module with the Dagger Go SDK installed. If not, [install the Dagger Go SDK](../sdk/go/371491-install.md).\n\n## Set the host working directory\n\nThe easiest way to set the working directory on the host for your Go CI pipeline is at the time of client instantiation, with the client's `WithWorkdir()` option.\n\nThe following example shows how to set the host working directory:\n\n```go file=./snippets/work-with-host-filesystem/set-workdir/main.go\n```\n\n## List directory contents\n\nThe `Host` type provides information about the host's execution environment. Its `Directory()` method accepts a path and returns a reference to the corresponding host directory as a `Directory` struct. There's also a shortcut `Workdir()` method, which returns a reference to the current working directory on the host. Entries in the directory can be obtained via the `Directory.Entries()` function.\n\nThe following example shows how to list the contents of the host working directory:\n\n```go file=./snippets/work-with-host-filesystem/list-dir/main.go\n```\n\n## List directory contents with filters\n\nIt's possible to restrict a `Directory` to a subset of directory entries, by specifying a list of filename patterns to include or exclude.\n\nThe following example shows how to obtain a reference to the host working directory containing only `*.rar` files:\n\n```go file=./snippets/work-with-host-filesystem/list-dir-include/main.go\n```\n\nThe following example shows how to obtain a reference to the host working directory containing all files except `*.txt` files:\n\n```go file=./snippets/work-with-host-filesystem/list-dir-exclude/main.go\n```\n\nThe `Exclude` pattern overrides the `Include` pattern, but not vice-versa. The following example demonstrates by obtaining a reference to the host working directory containing all files except `*.rar` files:\n\n```go file=./snippets/work-with-host-filesystem/list-dir-exclude-include/main.go\n```\n\n## Mount a host directory in a container\n\nA common operation when working with containers is to mount a host directory to a path in the container and then perform operations on it. This can be done using the `Container.WithMountedDirectory()` method, which accepts the mount point in the container and the `Directory` to be mounted as arguments.\n\nThe following example shows how to mount a host directory in a container at the `/host` container path and then execute a command in the container referencing the mounted directory:\n\n```go file=./snippets/work-with-host-filesystem/mount-dir/main.go\n```\n\n## Export a directory from a container to the host\n\nA directory can be exported to a different path using the `Directory.Export()` method. The destination path is supplied to the method as an argument.\n\nThe following example creates a file in a container's `/tmp` directory and then exports the contents of that directory to the host's temporary directory:\n\n```go file=./snippets/work-with-host-filesystem/export-dir/main.go\n```\n\n## Conclusion\n\nThis guide introduced you to the functions available in the Dagger Go SDK to work with the host filesystem. It provided explanations and code samples demonstrating how to set the host working directory, read directory contents (with and without pathname filters), mount a host directory in a container and export a directory from a container to the host.\n\nUse the [SDK Reference](https://pkg.go.dev/dagger.io/dagger) to learn more about the Dagger Go SDK.","contentTitle":"Work with the Host Filesystem","excerpt":"Introduction","timestamp":1667260800000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/454108-python-ci.md","frontMatter":{"slug":"/454108/python-ci","displayed_sidebar":"current","category":"guides","tags":["python","gitlab-ci","github-actions","circle-ci","jenkins"],"authors":["Jeremy Adams"],"date":"2022-12-13"},"content":"# Dagger Python SDK in CI\n\nimport Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';\n\n<Tabs defaultValue=\"github-actions\"\ngroupId=\"ci-environment\"\nvalues={[\n{label: 'GitHub Actions', value: 'github-actions'},\n{label: 'CircleCI', value: 'circleci'},\n{label: 'GitLab', value: 'gitlab'},\n{label: 'Jenkins', value: 'jenkins'},\n]}>\n\n<TabItem value=\"github-actions\">\n\n```yaml title=\".github/workflows/dagger.yaml\" file=./snippets/python-ci/actions.yml\n```\n\n</TabItem>\n\n<TabItem value=\"circleci\">\n\n```yaml title=\".circleci/config.yml\" file=./snippets/python-ci/circle.yml\n```\n\n</TabItem>\n\n<TabItem value=\"gitlab\">\n\n```yaml title=\".gitlab-ci.yml\" file=./snippets/python-ci/gitlab.yml\n```\n\n</TabItem>\n\n<TabItem value=\"jenkins\">\n\n```groovy title=\"Jenkinsfile\" file=./snippets/python-ci/Jenkinsfile\n```\n\nRequires `docker` client and `python` installed on your Jenkins agent, a Docker host available (can be `docker:dind`), and agents labeled in Jenkins with `dagger`.\n\n</TabItem>\n\n</Tabs>","contentTitle":"Dagger Python SDK in CI","excerpt":"<Tabs defaultValue=\"github-actions\"","timestamp":1670889600000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/544174-multistage-build.md","frontMatter":{"slug":"/544174/multistage-build","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Kyle Penfound"],"date":"2022-11-09"},"content":"# Use Dagger with Multi-stage Container Builds\n\nMulti-stage builds are a common practice when building containers with Docker.\n\n- First, your application is compiled in a context which has tools that are required for building the application, but not necessarily required for running it.\n- Next, to reduce the number of dependencies and hence the size of the image, the compiled application is copied to a different base image which only has the required components to run the application.\n\n[Learn more about multi-stage builds in the Docker documentation](https://docs.docker.com/build/building/multi-stage/).\n\nThis guide explains how to perform multi-stage builds with the Go SDK.\n\n## Requirements\n\nThis guide assumes that:\n\n- You have a Go development environment with Go 1.15 or later. If not, [download and install Go](https://go.dev/doc/install).\n- You are familiar with the basics of the Go SDK and have it installed. If not, read the [Go SDK guide](../sdk/go/959738-get-started.md) and the [Go SDK installation instructions](../sdk/go/371491-install.md).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n\n## Example\n\nThe following code snippet demonstrates a multi-stage build with the Go SDK.\n\n```go file=./snippets/multistage-build/main.go\n\n```\n\nThis code listing starts by creating a Dagger client and loading the project to be built. It obtains a reference to the project and then builds the application by using the `golang:latest` image to mount the source directory, sets `CGO_ENABLED=` since the binary will be published on `alpine`, and executes `go build`.\n\nNext, in the highlighted section, the multi-stage build is achieved by transferring the build artifact from the builder image to a runtime image based on `alpine`. The steps are:\n\n- Create a new container image which will be used as the runtime image, using `From(\"alpine\")`.\n- Transfer the build artifact from the builder image to the new container image using `WithFile`.\n- Set the container entrypoint to the application so that it is executed by default when the container runs.\n\nThe final optimized image can now be pushed to a registry and deployed!","contentTitle":"Use Dagger with Multi-stage Container Builds","excerpt":"Multi-stage builds are a common practice when building containers with Docker.","timestamp":1667952000000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/620941-github-google-cloud.md","frontMatter":{"slug":"/620941/github-google-cloud","displayed_sidebar":"current","category":"guides","tags":["nodejs","gitlab-ci","google-cloud"],"authors":["Vikram Vaswani"],"date":"2022-12-12"},"content":"# Use Dagger with GitHub Actions and Google Cloud\n\n:::note\n[Watch a live demo](https://youtu.be/-pKmv0VDJBg) of this tutorial in the Dagger Community Call (12 Jan 2023). For more demos, [join the next Dagger Community Call](https://dagger.io/events).\n:::\n\n## Introduction\n\nThis tutorial teaches you how to use a Dagger pipeline to continuously build and deploy a Node.js application with GitHub Actions on Google Cloud Run. You will learn how to:\n\n- Configure a Google Cloud service account and assign it the correct roles\n- Create a Google Cloud Run service accessible at a public URL\n- Create a Dagger pipeline using the Node.js SDK\n- Run the Dagger pipeline on your local host to manually build and deploy the application on Google Cloud Run\n- Use the same Dagger pipeline with GitHub Actions to automatically build and deploy the application on Google Cloud Run on every repository commit\n\n## Requirements\n\nThis tutorial assumes that:\n\n- You have a basic understanding of the JavaScript programming language.\n- You have a basic understanding of GitHub Actions. If not, [learn about GitHub Actions](https://docs.github.com/en/actions).\n- You have a Node.js development environment with Node.js 16.x or later. If not, install [NodeJS](https://nodejs.org/en/download/).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have the Google Cloud CLI installed. If not, [install the Google Cloud CLI](https://cloud.google.com/sdk/docs/install).\n- You have a Google Cloud account and a Google Cloud project with billing enabled. If not, [register for a Google Cloud account](https://cloud.google.com/), [create a Google Cloud project](https://console.cloud.google.com/project) and [enable billing](https://support.google.com/cloud/answer/6293499#enable-billing).\n- You have a GitHub account and a GitHub repository containing a Node.js Web application. This repository should also be cloned locally in your development environment. If not, [register for a GitHub account](https://github.com/signup), [install the GitHub CLI](https://github.com/cli/cli#installation) and follow the steps in Appendix A to [create and populate a local and GitHub repository with an example Express application](#appendix-a-create-a-github-repository-with-an-example-express-application).\n\n## Step 1: Create a Google Cloud service account\n\n{@include: ../partials/_google-cloud-service-account-key-setup.md}\n\n## Step 2: Configure Google Cloud APIs and a Google Cloud Run service\n\n{@include: ../partials/_google-cloud-api-run-setup.md}\n\n## Step 3: Create the Dagger pipeline\n\nThe next step is to create a Dagger pipeline to do the heavy lifting: build a container image of the application, release it to Google Container Registry and deploy it on Google Cloud Run.\n\n1. In the application directory, install the Dagger SDK and the Google Cloud Run client library as development dependencies:\n\n  ```shell\n  npm install @dagger.io/dagger@latest @google-cloud/run --save-dev\n  ```\n\n1. Create a new sub-directory named `ci`. Within the `ci` directory, create a file named `main.mjs` and add the following code to it. Replace the PROJECT placeholder with your Google Cloud project identifier and adjust the region (`us-central1`) and service name (`myapp`) if you specified different values when creating the Google Cloud Run service in Step 2.\n\n  ```javascript file=./snippets/github-google-cloud/main.mjs\n  ```\n\n  This file performs the following operations:\n    - It imports the Dagger and Google Cloud Run client libraries.\n    - It creates a Dagger client with `connect()`. This client provides an interface for executing commands against the Dagger engine.\n    - It uses the client's `host().workdir()` method to obtain a reference to the current directory on the host, excluding the `node_modules` and `ci` directories. This reference is stored in the `source` variable.\n    - It uses the client's `container().from()` method to initialize a new container from a base image. The additional `platform` argument to the `container()` method instructs Dagger to build for a specific architecture. In this example, the base image is the `node:16` image and the archiecture is `linux/amd64`, which is one of the architectures supported by Google Cloud. This method returns a `Container` representing an OCI-compatible container image.\n    - It uses the previous `Container` object's `withMountedDirectory()` method to mount the host directory into the container at the `/src` mount point, and the `withWorkdir()` method to set the working directory in the container.\n    - It chains the `withExec()` method to copy the contents of the working directory to the `/home/node` directory in the container and then uses the `withWorkdir()` method to change the working directory in the container to `/home/node`.\n    - It chains the `withExec()` method again to install dependencies with `npm install` and sets the container entrypoint using the `withEntrypoint()` method.\n    - It uses the container object's `publish()` method to publish the container to Google Container Registry, and prints the SHA identifier of the published image.\n    - It creates a Google Cloud Run client, updates the Google Cloud Run service defined in Step 2 to use the published container image, and requests a service update.\n\n:::tip\nMost `Container` object methods return a revised `Container` object representing the new state of the container. This makes it easy to chain methods together. Dagger evaluates pipelines \"lazily\", so the chained operations are only executed when required - in this case, when the `publish()` method is called.\n:::\n\n## Step 4: Test the Dagger pipeline on the local host\n\nConfigure credentials for the Google Cloud SDK on the local host, as follows:\n\n{@include: ../partials/_google-cloud-sdk-credentials-setup.md}\n\nOnce credentials are configured, test the Dagger pipeline by running the command below:\n\n```shell\nnode ci/main.mjs\n```\n\nDagger performs the operations defined in the pipeline script, logging each operation to the console. At the end of the process, the built container is deployed to Google Cloud Run and a message similar to the one below appears in the console output:\n\n  ```shell\n  Deployment for image gcr.io/PROJECT/myapp@sha256:b1cf... now available at https://...run.app\n  ```\n\nBrowse to the URL shown in the deployment message to see the running application.\n\nIf you deployed the example application from [Appendix A](#appendix-a-create-a-github-repository-with-an-example-express-application), you should see a page similar to that shown below:\n\n![Result of running pipeline from local host](/img/current/guides/github-google-cloud/local-deployment.png)\n\n## Step 5: Create a GitHub Actions workflow\n\nDagger executes your pipelines entirely as standard OCI containers. This means that the same pipeline will run the same, whether on on your local machine or a remote server.\n\nThis also means that it's very easy to move your Dagger pipeline from your local host to GitHub Actions - all that's needed is to commit and push the pipeline script from your local clone to your GitHub repository, and then define a GitHub Actions workflow to run it on every commit.\n\n1. Commit and push the pipeline script and related changes to the application's GitHub repository:\n\n  ```shell\n  git add .\n  git commit -a -m \"Added pipeline\"\n  git push\n  ```\n\n1. In the GitHub repository, create a new workflow file at `.github/workflows/main.yml` with the following content:\n\n  ```yaml file=./snippets/github-google-cloud/main.yml\n  ```\n\n  This workflow runs on every commit to the repository `master` branch. It consists of a single job with six steps, as below:\n    - The first step uses the [Checkout action](https://github.com/marketplace/actions/checkout) to check out the latest source code from the `main` branch to the GitHub runner.\n    - The second step uses the [Authenticate to Google Cloud action](https://github.com/marketplace/actions/authenticate-to-google-cloud) to authenticate to Google Cloud. It requires a service account key in JSON format, which it expects to find in the `GOOGLE_CREDENTIALS` GitHub secret. This step sets various environment variables (including the GOOGLE_APPLICATION_CREDENTIALS variable required by the Google Cloud Run SDK) and returns an access token as output, which is used to authenticate the next step.\n    - The third step uses the [Docker Login action](https://github.com/marketplace/actions/docker-login) and the access token from the previous step to authenticate to Google Container Registry from the GitHub runner. This is necessary because Dagger relies on the host's Docker credentials and authorizations when publishing to remote registries.\n    - The fourth step uses the [Setup Node.js environment action](https://github.com/marketplace/actions/setup-node-js-environment) to download and install Node.js 16.x on the GitHub runner.\n    - The fifth step downloads and installs the application's dependencies on the GitHub runner with `npm install`.\n    - The sixth and final step executes the Dagger pipeline.\n\nThe [Authenticate to Google Cloud action](https://github.com/marketplace/actions/authenticate-to-google-cloud) looks for a JSON service account key in the `GOOGLE_CREDENTIALS` GitHub secret. Create this secret as follows:\n\n1. Navigate to the `Settings` -> `Secrets` -> `Actions` page in the GitHub Web interface.\n1. Click `New repository secret` to create a new secret.\n1. Configure the secret with the following inputs:\n    - Name: `GOOGLE_CREDENTIALS`\n    - Secret: The contents of the service account JSON key file downloaded in Step 1.\n1. Click `Add secret` to save the secret.\n\n![Create GitHub secret](/img/current/guides/github-google-cloud/create-github-secret.png)\n\n## Step 6: Test the Dagger pipeline on GitHub\n\nTest the Dagger pipeline by committing a change to the GitHub repository.\n\nIf you are using the example application described in [Appendix A](#appendix-a-create-a-github-repository-with-an-example-express-application), the following commands modify and commit a simple change to the application's index page:\n\n```shell\ngit pull\nsed -i 's/Dagger/Dagger on GitHub/g' routes/index.js\ngit add routes/index.js\ngit commit -a -m \"Update welcome message\"\ngit push\n```\n\nThe commit triggers the GitHub Actions workflow defined in Step 6. The workflow runs the various steps of the `dagger` job, including the pipeline script.\n\nAt the end of the process, a new version of the built container image is released to Google Container Registry and deployed on Google Cloud Run. A message similar to the one below appears in the GitHub Actions log:\n\n```shell\nDeployment for image gcr.io/PROJECT/myapp@sha256:h4si... now available at https://...run.app\n```\n\nBrowse to the URL shown in the deployment message to see the running application. If you deployed the example application with the additional modification above, you see a page similar to that shown below:\n\n![Result of running pipeline from GitHub](/img/current/guides/github-google-cloud/github-actions-deployment.png)\n\n## Conclusion\n\nThis tutorial walked you through the process of creating a Dagger pipeline to continuously build and deploy a Node.js application on Google Cloud Run. It used the Dagger Node.js SDK and explained key concepts, objects and methods available in the SDK to construct a Dagger pipeline.\n\nDagger executes your pipelines entirely as standard OCI containers. This means that pipelines can be tested and debugged locally, and that the same pipeline will run consistently on your local machine, a CI runner, a dedicated server, or any container hosting service. This portability is one of Dagger's key advantages, and this tutorial demonstrated it in action by using the same pipeline on the local host and on GitHub.\n\nUse the [API Key Concepts](../api/975146-concepts.md) page and the [Node.js SDK Reference](../sdk/nodejs/reference/modules.md) to learn more about Dagger.\n\n## Appendix A: Create a GitHub repository with an example Express application\n\nThis tutorial assumes that you have a GitHub repository with a Node.js Web application. If not, follow the steps below to create a GitHub repository and commit an example Express application to it.\n\n1. Log in to GitHub using the GitHub CLI:\n\n  ```shell\n  gh auth login\n  ```\n\n1. Create a directory for the Express application:\n\n  ```shell\n  mkdir myapp\n  cd myapp\n  ```\n\n1. Create a skeleton Express application:\n\n  ```shell\n  npx express-generator\n  ```\n\n1. Make a minor modification to the application's index page:\n\n  ```shell\n  sed -i -e 's/Express/Dagger/g' routes/index.js\n  ```\n\n1. Initialize a local Git repository for the application:\n\n  ```shell\n  git init\n  ```\n\n1. Add a `.gitignore` file and commit the application code:\n\n  ```shell\n  echo node_modules >> .gitignore\n  git add .\n  git commit -a -m \"Initial commit\"\n  ```\n\n1. Create a private repository in your GitHub account and push the changes to it:\n\n  ```shell\n  gh repo create myapp --push --source . --private\n  ```","contentTitle":"Use Dagger with GitHub Actions and Google Cloud","excerpt":"Watch a live demo of this tutorial in the Dagger Community Call (12 Jan 2023). For more demos, join the next Dagger Community Call.","timestamp":1670803200000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/648384-multi-builds.md","frontMatter":{"slug":"/648384/multi-builds","displayed_sidebar":"current","category":"guides","tags":["python"],"authors":["Helder Correia"],"date":"2022-11-22"},"content":"# Create a Multi-Build CI Pipeline\n\n## Introduction\n\nThe Dagger Python SDK makes it easy to build an application for multiple OS and architecture combinations. This guide provides a working example of a Python CI tool that performs this task.\n\n## Requirements\n\nThis guide assumes that:\n\n- You have a Python development environment with Python 3.10 or later. If not, install [Python](https://www.python.org/downloads/).\n- You are familiar with the basics of the Python SDK and have it installed. If not, read the [Python SDK guide](../sdk/python/628797-get-started.md) and the [Python SDK installation instructions](../sdk/python/866944-install.md).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have an application that you wish to build. This guide assumes a Go application, but you can use an application of your choice.\n\n:::tip\nDagger pipelines are executed as standard OCI containers. This portability enables you to do very powerful things. For example, if you're a Python developer, you can use the Python SDK to create a pipeline (written in Python) that builds an application written in a different language (Go) without needing to learn that language.\n:::\n\n## Example\n\nAssume that the Go application to be built is stored in the current directory on the host. The following code listing demonstrates how to build this Go application for multiple OS and architecture combinations using the Python SDK.\n\n```python file=./snippets/multi-builds/build.py\n```\n\nThe `build()` function does the following:\n\n- It defines the build matrix, consisting of two OSs (`darwin` and `linux`) and two architectures (`amd64` and `arm64`).\n- It creates a Dagger client with `dagger.Connection()`.\n- It uses the client's `host().directory(\".\")` method to obtain a reference to the current directory on the host. This reference is stored in the `src` variable.\n- It uses the client's `container().from_()` method to initialize a new container from a base image. This base image contains all the tooling needed to build the application - in this case, the `golang:latest` image. This `from_()` method returns a new `Container` class with the results.\n- It uses the `Container.with_mounted_directory()` method to mount the host directory into the container at the `/src` mount point.\n- It uses the `Container.with_workdir()` method to set the working directory in the container.\n- It iterates over the build matrix, creating a directory in the container for each OS/architecture combination and building the Go application for each such combination. The Go build process is instructed via the `GOOS` and `GOARCH` build variables, which are reset for each case via the `Container.with_env_variable()` method.\n- It obtains a reference to the build output directory in the container with the `with_directory()` method, and then uses the `Directory.export()` method to write the build directory from the container to the host.","contentTitle":"Create a Multi-Build CI Pipeline","excerpt":"Introduction","timestamp":1669075200000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/710884-private-repositories.md","frontMatter":{"slug":"/710884/private-repositories","displayed_sidebar":"current","category":"guides","tags":["go"],"authors":["Guillaume de Rouville"],"date":"2022-10-31"},"content":"import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n# Use Dagger with Private Git Repositories\n\nDagger recommends you to rely on your host's SSH authentication agent to securely authenticate against private remote Git repositories.\n\nTo clone private repositories, the only requirements are to run `ssh-add` on the Dagger host (to add your SSH key to the authentication agent), and mount its socket using the `SSHAuthSocket` parameter of the `(Dagger.GitRef).Tree` API.\n\nAssume that you have a Dagger CI tool containing the following code, which references a private repository:\n\n<Tabs groupId=\"language\">\n<TabItem value=\"Go\">\n\n```go file=./snippets/private-repositories/main.go\n```\n\n</TabItem>\n<TabItem value=\"Node.js (TypeScript)\">\n\n```typescript file=./snippets/private-repositories/clone.ts\n```\n\n</TabItem>\n<TabItem value=\"Python\">\n\n```python file=./snippets/private-repositories/clone.py\n```\n\n</TabItem>\n</Tabs>\n\nNow, first remove all the SSH keys from the authentication agent on the Dagger host:\n\n```shell\n➜  ssh-add -D\nAll identities removed.\n```\n\nAttempt to run the CI tool:\n\n<Tabs groupId=\"language\">\n<TabItem value=\"Go\">\n\n```shell\n➜  go run .\npanic: input:1: git.branch.tree.file.contents failed to load cache key: failed to fetch remote\nexit status 128\n```\n\n</TabItem>\n<TabItem value=\"Node.js (TypeScript)\">\n\n```shell\n➜  node --loader ts-node/esm clone.ts\n{'message': 'failed to load cache key: failed to fetch remote https://xxxxx@private-repository.git: exit status 128', 'locations': [{'line': 6, 'column': 11}], 'path': ['git', 'branch', 'tree', 'file', 'contents']}\n```\n\n</TabItem>\n<TabItem value=\"Python\">\n\n```shell\n➜  python clone.py\n{'message': 'failed to load cache key: failed to fetch remote https://xxxxx@private-repository.git: exit status 128', 'locations': [{'line': 6, 'column': 11}], 'path': ['git', 'branch', 'tree', 'file', 'contents']}\n```\n\n</TabItem>\n</Tabs>\n\nThe CI tool fails, as it is unable to find the necessary authentication credentials to read the private repository in the SSH authentication agent.\n\nNow, add the SSH key to the authentication agent on the host and try again:\n\n<Tabs groupId=\"language\">\n<TabItem value=\"Go\">\n\n```shell\n➜ ssh-add\nIdentity added: xxxxx\ngo run .\nreadme #\n```\n\n</TabItem>\n<TabItem value=\"Node.js (TypeScript)\">\n\n```shell\n➜ ssh-add\nIdentity added: xxxxx\n➜ node --loader ts-node/esm clone.ts\nreadme #\n```\n\n</TabItem>\n<TabItem value=\"Python\">\n\n```shell\n➜ ssh-add\nIdentity added: xxxxx\n➜ python clone.py\nreadme #\n```\n\n</TabItem>\n</Tabs>\n\nFinally, the CI tool succeeds in reading the private Git repository.","contentTitle":"Use Dagger with Private Git Repositories","excerpt":"Dagger recommends you to rely on your host's SSH authentication agent to securely authenticate against private remote Git repositories.","timestamp":1667174400000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/759201-gitlab-google-cloud.md","frontMatter":{"slug":"/759201/gitlab-google-cloud","displayed_sidebar":"current","category":"guides","tags":["go","python","nodejs","gitlab-ci","google-cloud"],"authors":["Vikram Vaswani"],"date":"2023-02-11"},"content":"import Tabs from \"@theme/Tabs\";\nimport TabItem from \"@theme/TabItem\";\n\n# Use Dagger with GitLab CI/CD and Google Cloud\n\n## Introduction\n\nThis tutorial teaches you how to use a Dagger pipeline to continuously build and deploy a Go application with GitLab on Google Cloud Run. You will learn how to:\n\n- Configure a Google Cloud service account and assign it the correct roles\n- Create a Google Cloud Run service accessible at a public URL\n- Create a Dagger pipeline using the Dagger SDKs\n- Run the Dagger pipeline on your local host to manually build and deploy the application on Google Cloud Run\n- Use the same Dagger pipeline with GitLab CI/CD to automatically build and deploy the application on Google Cloud Run on every repository commit\n\n## Requirements\n\nThis tutorial assumes that:\n\n- You have a basic understanding of the Go programming language.\n- You have a basic understanding of GitLab and GitLab CI/CD. If not, [learn about GitLab CI/CD](https://docs.gitlab.com/ee/ci/).\n- You have a Go, Python or Node.js development environment. If not, install [Go](https://go.dev/doc/install), [Python](https://www.python.org/downloads/) or [Node.js](https://nodejs.org/en/download/).\n- You have Docker installed and running on the host system. If not, [install Docker](https://docs.docker.com/engine/install/).\n- You have the Google Cloud CLI installed. If not, [install the Google Cloud CLI](https://cloud.google.com/sdk/docs/install).\n- You have a Google Cloud account and a Google Cloud project with billing enabled. If not, [register for a Google Cloud account](https://cloud.google.com/), [create a Google Cloud project](https://console.cloud.google.com/project) and [enable billing](https://support.google.com/cloud/answer/6293499#enable-billing).\n- You have a GitLab account and a GitLab repository containing a Go web application. This repository should also be cloned locally in your development environment. If not, [register for a GitLab account](https://gitlab.com/), [install the GitLab CLI](https://gitlab.com/gitlab-org/cli#installation) and follow the steps in Appendix A to [create and populate a local and GitLab repository with an example Go application](#appendix-a-create-a-gitlab-repository-with-an-example-go-application).\n- You have a GitLab Runner application available to run your GitLab CI/CD pipeline. This could be either a self-hosted runner or a GitLab-managed runner. [Learn about GitLab Runner](https://docs.gitlab.com/runner/) and follow the steps in Appendix B to [configure a self-hosted runner](#appendix-b-configure-a-self-hosted-gitlab-runner-for-use-with-dagger).\n\n## Step 1: Create a Google Cloud service account\n\n{@include: ../partials/_google-cloud-service-account-key-setup.md}\n\n## Step 2: Configure Google Cloud APIs and a Google Cloud Run service\n\n{@include: ../partials/_google-cloud-api-run-setup.md}\n\n## Step 3: Create the Dagger pipeline\n\nThe next step is to create a Dagger pipeline to do the heavy lifting: build a container image of the application, release it to Google Container Registry and deploy it on Google Cloud Run.\n\n<Tabs groupId=\"language\">\n<TabItem value=\"Go\">\n\n1. In the application directory, install the Dagger SDK and the Google Cloud Run client library:\n\n  ```shell\n  go get dagger.io/dagger@latest\n  go get cloud.google.com/go/run/apiv2\n  ```\n\n1. Create a new sub-directory named `ci`. Within the `ci` directory, create a file named `main.go` and add the following code to it. Replace the PROJECT placeholder with your Google Cloud project identifier and adjust the region (`us-central1`) and service name (`myapp`) if you specified different values when creating the Google Cloud Run service in Step 2.\n\n  ```go file=./snippets/gitlab-google-cloud/main.go\n  ```\n\n  This code listing performs the following operations:\n    - It imports the Dagger and Google Cloud Run client libraries.\n    - It creates a Dagger client with `Connect()`. This client provides an interface for executing commands against the Dagger engine.\n    - It uses the client's `Host().Directory()` method to obtain a reference to the current directory on the host, excluding the `ci` directory. This reference is stored in the `source` variable.\n    - In the first stage of the build, it uses the client's `Container().From()` method to initialize a new container from a base image. The additional `Platform` argument to the `Container()` method instructs Dagger to build for a specific architecture. In this example, the base image is the `golang:1.19` image and the architecture is `linux/amd64`, which is one of the architectures supported by Google Cloud. This method returns a `Container` representing an OCI-compatible container image.\n    - It uses the previous `Container` object's `WithMountedDirectory()` method to mount the host directory into the container at the `/src` mount point, and the `WithWorkdir()` method to set the working directory in the container.\n    - It chains the `WithEnvVariable()` method to set the `CGO_ENABLED` variable in the container environment and the `WithExec()` method to compile the Go application with `go build`.\n    - Once the application is built, it moves to the second stage of the build. It again uses the client's `Container().From()` method to initialize a new container from an `alpine` base image.\n    - It uses the previous `Container` object's `WithFile()` method to transfer the compiled binary file from the first stage to the new container filesystem.\n    - It sets the container entrypoint to the binary file using the `WithEntrypoint()` method.\n    - It uses the container object's `Publish()` method to publish the container to Google Container Registry, and prints the SHA identifier of the published image.\n    - It creates a Google Cloud Run client, creates a service request instructing the Google Cloud Run service to use the newly-published container image, and sends the requests to the Google Cloud Run API.\n\n1. Run the following command to update `go.sum`:\n\n  ```shell\n  go mod tidy\n  ```\n\n</TabItem>\n<TabItem value=\"Node.js\">\n\n1. In the application directory, install the Dagger SDK and the Google Cloud Run client library:\n\n  ```shell\n  npm install @dagger.io/dagger@latest @google-cloud/run --save-dev\n  ```\n\n1. Create a new sub-directory named `ci`. Within the `ci` directory, create a file named `index.mjs` and add the following code to it. Replace the PROJECT placeholder with your Google Cloud project identifier and adjust the region (`us-central1`) and service name (`myapp`) if you specified different values when creating the Google Cloud Run service in Step 2.\n\n  ```javascript file=./snippets/gitlab-google-cloud/index.mjs\n  ```\n\n  This code listing performs the following operations:\n    - It imports the Dagger and Google Cloud Run client libraries.\n    - It creates a Dagger client with `connect()`. This client provides an interface for executing commands against the Dagger engine.\n    - It uses the client's `host().directory()` method to obtain a reference to the current directory on the host, excluding the `ci` directory. This reference is stored in the `source` variable.\n    - In the first stage of the build, it uses the client's `container().from()` method to initialize a new container from a base image. The additional `platform` argument to the `container()` method instructs Dagger to build for a specific architecture. In this example, the base image is the `golang:1.19` image and the architecture is `linux/amd64`, which is one of the architectures supported by Google Cloud. This method returns a `Container` representing an OCI-compatible container image.\n    - It uses the previous `Container` object's `withMountedDirectory()` method to mount the host directory into the container at the `/src` mount point, and the `withWorkdir()` method to set the working directory in the container.\n    - It chains the `withEnvVariable()` method to set the `CGO_ENABLED` variable in the container environment and the `withExec()` method to compile the Go application with `go build`.\n    - Once the application is built, it moves to the second stage of the build. It again uses the client's `container().from()` method to initialize a new container from an `alpine` base image.\n    - It uses the previous `Container` object's `withFile()` method to transfer the compiled binary file from the first stage to the new container filesystem.\n    - It sets the container entrypoint to the binary file using the `withEntrypoint()` method.\n    - It uses the container object's `publish()` method to publish the container to Google Container Registry, and prints the SHA identifier of the published image.\n    - It creates a Google Cloud Run client, creates a service request instructing the Google Cloud Run service to use the newly-published container image, and sends the requests to the Google Cloud Run API.\n\n</TabItem>\n<TabItem value=\"Python\">\n\n1. In the application directory, create a virtual environment and install the Dagger SDK and the Google Cloud Run client library:\n\n  ```shell\n  pip install dagger-io google-cloud-run\n  ```\n\n1. Create a new sub-directory named `ci`. Within the `ci` directory, create a file named `main.py` and add the following code to it. Replace the PROJECT placeholder with your Google Cloud project identifier and adjust the region (`us-central1`) and service name (`myapp`) if you specified different values when creating the Google Cloud Run service in Step 2.\n\n  ```python file=./snippets/gitlab-google-cloud/main.py\n  ```\n\n  This code listing performs the following operations:\n    - It imports the Dagger and Google Cloud Run client libraries.\n    - It creates a Dagger client with `dagger.Connection()`. This client provides an interface for executing commands against the Dagger engine.\n    - It uses the client's `host().directory()` method to obtain a reference to the current directory on the host, excluding the `ci` directory. This reference is stored in the `source` variable.\n    - In the first stage of the build, it uses the client's `container().from_()` method to initialize a new container from a base image. The additional `platform` argument to the `container()` method instructs Dagger to build for a specific architecture. In this example, the base image is the `golang:1.19` image and the architecture is `linux/amd64`, which is one of the architectures supported by Google Cloud. This method returns a `Container` representing an OCI-compatible container image.\n    - It uses the previous `Container` object's `with_mounted_directory()` method to mount the host directory into the container at the `/src` mount point, and the `with_workdir()` method to set the working directory in the container.\n    - It chains the `with_env_variable()` method to set the `CGO_ENABLED` variable in the container environment and the `with_exec()` method to compile the Go application with `go build`.\n    - Once the application is built, it moves to the second stage of the build. It again uses the client's `container().from_()` method to initialize a new container from an `alpine` base image.\n    - It uses the previous `Container` object's `with_file()` method to transfer the compiled binary file from the first stage to the new container filesystem.\n    - It sets the container entrypoint to the binary file using the `with_entrypoint()` method.\n    - It uses the container object's `publish()` method to publish the container to Google Container Registry, and prints the SHA identifier of the published image.\n    - It creates a Google Cloud Run client, creates a service request instructing the Google Cloud Run service to use the newly-published container image, and sends the requests to the Google Cloud Run API.\n\n</TabItem>\n</Tabs>\n\n:::tip\nMost `Container` object methods return a revised `Container` object representing the new state of the container. This makes it easy to chain methods together. Dagger evaluates pipelines \"lazily\", so the chained operations are only executed when required - in this case, when the container is published. Learn more about [lazy evaluation in Dagger](../api/975146-concepts.md#lazy-evaluation).\n:::\n\n## Step 4: Test the Dagger pipeline on the local host\n\nConfigure credentials for the Google Cloud SDK on the local host, as follows:\n\n{@include: ../partials/_google-cloud-sdk-credentials-setup.md}\n\nOnce credentials are configured, test the Dagger pipeline by running the command below:\n\n<Tabs groupId=\"language\">\n<TabItem value=\"Go\">\n\n```shell\ngo run ci/main.go\n```\n\n</TabItem>\n<TabItem value=\"Node.js\">\n\n```shell\nnode ci/index.mjs\n```\n\n</TabItem>\n<TabItem value=\"Python\">\n\n```shell\npython ci/main.py\n```\n\n</TabItem>\n</Tabs>\n\nDagger performs the operations defined in the pipeline script, logging each operation to the console. At the end of the process, the built container is deployed to Google Cloud Run and a message similar to the one below appears in the console output:\n\n  ```shell\n  Deployment for image gcr.io/PROJECT/myapp@sha256:b1cf... now available at https://...run.app\n  ```\n\nBrowse to the URL shown in the deployment message to see the running application.\n\nIf you deployed the example application from [Appendix A](#appendix-a-create-a-gitlab-repository-with-an-example-go-application), you see the output below:\n\n```shell\nHello, Dagger!\n```\n\n## Step 5: Create a GitLab CI/CD pipeline\n\nDagger executes your pipelines entirely as standard OCI containers. This means that the same pipeline will run the same, whether on on your local machine or a remote server.\n\nThis also means that it's very easy to move your Dagger pipeline from your local host to GitLab - all that's needed is to transfer the pipeline script from your local clone to your GitLab repository, and then define a GitLab CI/CD pipeline to run it on every commit.\n\n1. Create a new GitLab CI/CD pipeline configuration file in your application directory at `.gitlab-ci.yml` with the following content:\n\n  <Tabs groupId=\"language\">\n  <TabItem value=\"Go\">\n\n  ```yaml file=./snippets/gitlab-google-cloud/gitlab-ci-go.yml\n  ```\n\n  </TabItem>\n  <TabItem value=\"Node.js\">\n\n  ```yaml file=./snippets/gitlab-google-cloud/gitlab-ci-nodejs.yml\n  ```\n\n  </TabItem>\n  <TabItem value=\"Python\">\n\n  ```yaml file=./snippets/gitlab-google-cloud/gitlab-ci-python.yml\n  ```\n\n  </TabItem>\n  </Tabs>\n\n  This GitLab CI/CD pipeline runs on every commit to the repository `master` branch. It consists of three jobs, as below:\n    - The first job tells the GitLab runner to use the Docker executor with a Docker-in-Docker (`dind`) service. It also configures TLS and sets the location for Docker to generate its TLS certificates.\n    - The second job adds the Docker CLI and authenticates to Google Container Registry from the GitLab runner. This is necessary because Dagger relies on the host's Docker credentials and authorizations when publishing to remote registries. For authentication, the job relies on the Google Cloud service account credentials, which are stored in the `GOOGLE_APPLICATION_CREDENTIALS` variable (more on this later).\n    - The third and final job executes the Dagger pipeline code.\n\n1. This GitLab CI/CD pipeline looks for a Google Cloud service account key in the `GOOGLE_APPLICATION_CREDENTIALS` GitLab variable. Create this variable as follows:\n\n    1. Navigate to the `Settings` -> `CI/CD` -> `Variables` page in the GitLab Web interface.\n    1. Click `Add variable` to create a new variable.\n    1. Configure the variable with the following inputs:\n        - Name: `GOOGLE_APPLICATION_CREDENTIALS`\n        - Value: The contents of the service account JSON key file downloaded in Step 1\n        - Type: `File`\n        - Flags: `Protect variable`\n    1. Click `Add variable` to save the variable.\n\n    ![Create GitLab variable](/img/current/guides/gitlab-google-cloud/create-gitlab-variable.png)\n\n1. Commit and push the changes to the GitLab repository:\n\n  ```shell\n  git add .\n  git commit -a -m \"Added pipeline and CI code\"\n  git push\n  ```\n\n## Step 6: Test the Dagger pipeline on GitLab\n\n:::info\nThis step requires a properly-configured GitLab Runner. Refer to Appendix B for instructions on how to [configure a self-hosted GitLab Runner for use with Dagger](#appendix-b-configure-a-self-hosted-gitlab-runner-for-use-with-dagger).\n:::\n\nTest the Dagger pipeline by committing a change to the GitLab repository.\n\nIf you are using the example application described in [Appendix A](#appendix-a-create-a-gitlab-repository-with-an-example-go-application), the following commands modify and commit a simple change to the application's index page:\n\n```shell\ngit pull\nsed -i -e 's/Dagger/Dagger on GitLab/g' server.go\ngit commit -a -m \"Update welcome message\"\ngit push\n```\n\nThe commit triggers the GitLab CI/CD pipeline defined in Step 6. The pipeline runs the various jobs, including the Dagger pipeline.\n\nAt the end of the process, a new version of the built container image is released to Google Container Registry and deployed on Google Cloud Run. A message similar to the one below appears in the GitHub Actions log:\n\n```shell\nDeployment for image gcr.io/PROJECT/myapp@sha256:h4si... now available at https://...run.app\n```\n\nBrowse to the URL shown in the deployment message to see the running application. If you deployed the example application with the additional modification above, you see the following output:\n\n```shell\nHello, Dagger on GitLab!\n```\n\n## Conclusion\n\nThis tutorial walked you through the process of creating a Dagger pipeline to continuously build and deploy a Go application on Google Cloud Run. It explained key concepts, objects and methods available in the Dagger SDKs to construct a Dagger pipeline.\n\nDagger executes your pipelines entirely as standard OCI containers. This means that pipelines can be tested and debugged locally, and that the same pipeline will run consistently on your local machine, a CI runner, a dedicated server, or any container hosting service. This portability is one of Dagger's key advantages, and this tutorial demonstrated it in action by using the same pipeline on the local host and on GitLab.\n\nUse the [API Key Concepts](../api/975146-concepts.md) page and the [Go](https://pkg.go.dev/dagger.io/dagger), [Node.js](../sdk/nodejs/reference/modules.md) and [Python](https://dagger-io.readthedocs.org/) SDK References to learn more about Dagger.\n\n## Appendix A: Create a GitLab repository with an example Go application\n\nThis tutorial assumes that you have a GitLab repository with a application. If not, follow the steps below to create a GitLab repository and commit a simple Go web application to it.\n\n1. Log in to GitLab using the GitLab CLI:\n\n  ```shell\n  glab auth login -h gitlab.com\n  ```\n\n1. Create a directory and module for the Go application:\n\n  ```shell\n  mkdir myapp\n  cd myapp\n  go mod init main\n  ```\n\n1. Install the Echo web framework:\n\n  ```shell\n  go get github.com/labstack/echo/v4\n  ```\n\n1. Create a file named `server.go` and add the following code to it to create a skeleton application:\n\n  ```go\n  package main\n\n  import (\n    \"net/http\"\n\n    \"github.com/labstack/echo/v4\"\n  )\n\n  func main() {\n    e := echo.New()\n    e.GET(\"/\", func(c echo.Context) error {\n      return c.String(http.StatusOK, \"Hello, Dagger!\")\n    })\n    e.Logger.Fatal(e.Start(\":1323\"))\n  }\n  ```\n\n1. Create a private repository in your GitLab account:\n\n  ```shell\n  glab repo create myapp\n  ```\n\n1. Commit and push the application code:\n\n  ```shell\n  git add .\n  git commit -a -m \"Initial commit\"\n  git push --set-upstream origin master\n  ```\n\n## Appendix B: Configure a self-hosted GitLab Runner for use with Dagger\n\nThis tutorial assumes that you have a GitLab Runner application to run your GitLab CI/CD pipelines. This could be either a GitLab-managed runner or a self-hosted runner. [Learn about GitLab Runner](https://docs.gitlab.com/runner/).\n\nTo use GitLab's managed runners, you must [associate a valid credit card with your GitLab account](https://about.gitlab.com/pricing/#why-do-i-need-to-enter-credit-debit-card-details-for-free-pipeline-minutes). Alternatively, you can configure a self-hosted runner on your local host by following the steps below.\n\n1. [Install GitLab Runner](https://docs.gitlab.com/runner/install/index.html) for your host's operating system.\n1. Navigate to the `Settings` -> `CI/CD` -> `Runners` page in the GitLab Web interface.\n1. Disable shared runners by unchecking the `Enable shared runners for this project` option.\n\n  ![Disable shared runners](/img/current/guides/gitlab-google-cloud/gitlab-disable-shared-runners.png)\n\n1. Copy the project-specific registration token, as shown below:\n\n  ![Runner registration token](/img/current/guides/gitlab-google-cloud/gitlab-self-hosted-runner-token.png)\n\n1. On your local host, register the runner using the command below. Replace the TOKEN placeholder with the registration token.\n\n  ```shell\n  sudo gitlab-runner register -n \\\n    --name dagger \\\n    --url https://gitlab.com/ \\\n    --executor docker \\\n    --docker-privileged \\\n    --docker-volumes /cache \\\n    --docker-volumes /certs/client \\\n    --docker-image docker:20.10.16 \\\n    --registration-token TOKEN\n  ```\n\n1. Navigate to the `Settings` -> `CI/CD` -> `Runners` page in the GitLab Web interface. Confirm that the newly-registered runner is active for the project, as shown below:\n\n  ![Runner registration](/img/current/guides/gitlab-google-cloud/gitlab-self-hosted-runner-active.png)","contentTitle":"Use Dagger with GitLab CI/CD and Google Cloud","excerpt":"Introduction","timestamp":1676073600000},{"path":"/home/vikram/public/vikram.dagger/docs/current/guides/768421-go-ci.md","frontMatter":{"slug":"/768421/go-ci","displayed_sidebar":"current","category":"guides","tags":["go","gitlab-ci","github-actions","circle-ci","jenkins"],"authors":["Jeremy Adams"],"date":"2022-12-13"},"content":"# Dagger Go SDK in CI\n\nimport Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';\n\n<Tabs defaultValue=\"github-actions\"\ngroupId=\"ci-environment\"\nvalues={[\n{label: 'GitHub Actions', value: 'github-actions'},\n{label: 'CircleCI', value: 'circleci'},\n{label: 'GitLab', value: 'gitlab'},\n{label: 'Jenkins', value: 'jenkins'},\n]}>\n\n<TabItem value=\"github-actions\">\n\n```yaml title=\".github/workflows/dagger.yml\" file=./snippets/go-ci/actions.yml\n```\n\n</TabItem>\n\n<TabItem value=\"circleci\">\n\n```yaml title=\".circleci/config.yml\" file=./snippets/go-ci/circle.yml\n```\n\n</TabItem>\n\n<TabItem value=\"gitlab\">\n\n```yaml title=\".gitlab-ci.yml\" file=./snippets/go-ci/gitlab.yml\n```\n\n</TabItem>\n\n<TabItem value=\"jenkins\">\n\n```groovy title=\"Jenkinsfile\" file=./snippets/go-ci/Jenkinsfile\n```\n\nRequires `docker` client and `go` installed on your Jenkins agent, a Docker host available (can be `docker:dind`), and agents labeled in Jenkins with `dagger`.\n\n</TabItem>\n\n</Tabs>","contentTitle":"Dagger Go SDK in CI","excerpt":"<Tabs defaultValue=\"github-actions\"","timestamp":1670889600000}]